#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
% https://tex.stackexchange.com/questions/43743/how-to-reduce-line-space-leading-within-an-enumerate-environment
\usepackage{enumitem}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Informal introduction to Python 3 for scientific computing
\end_layout

\begin_layout Author
Juha Jeronen
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="45text%">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="45text%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Department of
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
phantom{spacer}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Laboratory of
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mathematical Information Technology
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Electrical Energy Engineering
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
University of Jyväskylä
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tampere University of Technology
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
juha.jeronen@{jyu,tut}.fi
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 2cm
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
LECTURE NOTES
\begin_inset Newline newline
\end_inset

Version 1.0.0
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Foreword
\end_layout

\begin_layout Standard
These lecture notes are aimed mostly at students and researchers interested
 in learning Python, studying or working in scientific computing, and already
 having experienced MATLAB and/or Fortran.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 No previous background in computer science is assumed or required, but
 basic or intermediate programming skill is useful.
\end_layout

\end_inset

 We assume no previous background in computer science or software engineering,
 but basic or intermediate programming skill is useful.
\end_layout

\begin_layout Standard
This does 
\emph on
not
\emph default
 aim to be a comprehensive general guide to Python for general-purpose programmi
ng.
 For that, see the book by Mark Lutz
\emph on
: Learning Python, 5th ed., O'Reilly, 2013
\emph default
.
 For newcomers to programming in general, there is also Zed A.
 Shaw: 
\emph on
Learn Python
\begin_inset space ~
\end_inset

3 the Hard Way, Addison–Wesley, 2017
\emph default
.
\end_layout

\begin_layout Standard
Instead, these notes bring together — in an extremely compressed form —
 various aspects of Python as seen through the lens of scientific computing.
 Unfortunately, it is impossible to cover everything at a hands-on level,
 because that would expand this material into a proper book, which I don't
 have the time to write right now.
\end_layout

\begin_layout Standard
Hence, links to existing online material are provided, and the reader is
 expected to follow them where appropriate.
 All the links are clickable.
 Although the text does show the raw URLs so that no information is lost
 when printing, it may be more convenient to read this material digitally
 (and while connected to the internet) than to print it out.
\end_layout

\begin_layout Standard
Still, this material is rather long.
 Wherever this does not stem simply from my own failure to summarize adequately,
 it
\begin_inset space ~
\end_inset

is because programming in Python, even when restricted to the use case of
 scientific computing, is a large topic.
 The task of explaining Python briefly is akin to that of explaining large-defor
mation elasticity in five minutes — up to, and including, tensor calculus
 in general coordinate systems.
\end_layout

\begin_layout Standard
Some aspects not traditionally emphasized in a scientific computing context
 are explored, including the very basics of software engineering.
 From my somewhat unusual vantage point, which is a superposition state,
 
\begin_inset Formula ${\scriptstyle 1/\sqrt{3}}$
\end_inset

 each, of information technology, pure and applied mathematics, and physics
 and engineering sciences, I feel that IT and CS have a lot to offer to
 scientists who program, and especially to those who either apply or study
 numerics.
\end_layout

\begin_layout Standard
Of all things, why software engineering? In an online essay on Python, physicist
 Steve Byrnes
\begin_inset Foot
status open

\begin_layout Plain Layout
Appendix 3 in 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://sjbyrnes.com/python/"

\end_inset


\end_layout

\end_inset

 makes the point that scientists often write code, but many scientists do
 not know how to write 
\emph on
good, correct software quickly
\emph default
.
 But this is a solved problem! Software engineering is, precisely, a set
 of tools and practices to do exactly that.
 It is not only for software professionals, and contrary to popular belief,
 it's not scary.
\end_layout

\begin_layout Standard
Of course, an awareness of the very basics is more than enough to get started
 in a scientific setting, and that is the extent to which we will touch
 upon this topic in the final advanced section of these notes.
 In fact, with MATLAB, you may have already used some software engineering
 tools: a debugger, a performance profiler, and a (realtime) static code
 analyzer that alerts you to problems such as assigned to but unused variables.
\end_layout

\begin_layout Standard
In my own research work, I have used MATLAB in 2008–2012, and Python since
 2012, at which point I felt it provided all the tools that my work needed,
 and that the benefits outweighed the cost of switching.
 The practical motivating factor behind writing these notes is that there
 has now been interest toward Python for scientific computing, at both Universit
y of Jyväskylä and at Tampere University of Technology.
\end_layout

\begin_layout Standard
Why teach Python right now? In my personal opinion: Python's capabilities
 have for the most part equalled, and in some respects, surpassed MATLAB;
 Python
\begin_inset space ~
\end_inset

3 can be considered a stable platform to build science on; and Python's
 popularity shows not the faintest sign of waning — having observed, for
 the last 15 years, Python take the programming world by storm in slow motion.
 I'm by no means an early adopter of new programming languages!
\end_layout

\begin_layout Standard
Although there are those who swear by the names of even more advanced languages
 such as Haskell and Scheme, Python has the advantage that it has entered
 the mainstream, and comes with ample software libraries and community support.
 Someone, somewhere on the internet always knows how to do the particular
 technical thing you want — and likely, also how to obtain optimal performance
 while at it.
\end_layout

\begin_layout Standard
Also, Python is a huge step up in a scientist's productivity when compared
 to C, C++ and Fortran.
 Simultaneously, Python is a proper general-purpose programming language,
 in contrast to a domain-specific collection of tools like MATLAB.
 
\emph on
Python is a general high-level language done right (at least to a large
 extent)
\emph default
.
\end_layout

\begin_layout Standard
This material contains a large number of links to the internet.
 If any links have gone dead, or if you find mistakes, please do tell me.
 Or even, feel free to send a PR on GitHub.
\end_layout

\begin_layout Standard
Oh, and, welcome to the revolution.
\end_layout

\begin_layout Standard
–JJ 2017-10-07
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
License
\end_layout

\begin_layout Standard
BY-CC-SA 4.0
\family sans
: 
\begin_inset CommandInset href
LatexCommand href
target "https://creativecommons.org/licenses/by-sa/4.0/"

\end_inset


\end_layout

\begin_layout Section*
Homepage
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Technologicat/python-3-scicomp-intro"

\end_inset


\end_layout

\begin_layout Standard
(Please excuse the temporary lack of proper branding.)
\end_layout

\begin_layout Section*
Changelog
\end_layout

\begin_layout Standard
This project adheres to 
\series bold
semantic versioning
\series default
:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://semver.org/"

\end_inset


\end_layout

\begin_layout Standard
...as far as it makes sense for a set of lecture notes to adhere to a standard
 of 
\emph on
software
\emph default
 versioning.
 Thus, we interpret the rules as follows:
\end_layout

\begin_layout Standard

\emph on
The API
\emph default
 is the table of contents (TOC).
 If the TOC changes in any way that would invalidate existing external reference
s to this text by section number, the major version will change (e.g.
 1.0.0 to 2.0.0).
 Note that page numbers, on the other hand, are not considered stable, and
 should not be used to refer to parts of this text.
\end_layout

\begin_layout Standard

\emph on
Backwards-compatible changes in functionality
\emph default
 are any changes in content that do not break the API.
 This includes content changes in existing sections.
 This also implies that new sections or subsections may still be added,
 as long as any existing references by section number remain valid.
 Changes of this kind bump the minor version (e.g.
 1.0.0 to 1.1.0).
\end_layout

\begin_layout Standard

\emph on
Backwards-compatible bugfixes
\emph default
 only correct mistakes, without breaking the API or introducing changes
 in content.
 Changes of this kind bump the patch version (e.g.
 1.0.0 to 1.0.1).
\end_layout

\begin_layout Standard
Version history below.
\end_layout

\begin_layout Itemize
v1.0.0 [2017-10-07]: initial release
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{section}{-1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Motivation
\begin_inset CommandInset label
LatexCommand label
name "sec:Motivation"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% horizontal separator line
\end_layout

\begin_layout Plain Layout

% https://tex.stackexchange.com/questions/19579/horizontal-line-spanning-the-entir
e-document-in-latex
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
hsepline}{ 
\backslash
noindent
\backslash
makebox[
\backslash
linewidth]{
\backslash
rule{
\backslash
textwidth}{0.4pt}} }
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
What is Python?
\series default
 Let's hear it from the horse's mouth:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

jje@arcturus:~$ man python
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PYTHON(1)                   General Commands Manual                  PYTHON(1)
\end_layout

\begin_layout Plain Layout

        [...]
\end_layout

\begin_layout Plain Layout

        DESCRIPTION           Python is an interpreted, interactive, object-orie
nted
\end_layout

\begin_layout Plain Layout

                              programming language that combines remarkable
 power
\end_layout

\begin_layout Plain Layout

                              with very clear syntax.
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\begin_layout Plain Layout


\backslash
hskip 0.5cm
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Why use Python?
\series default
 Of course the answer depends on the scientist, but let's see if we can
 find a common theme.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.25cm
\end_layout

\end_inset

Paraphrasing an online essay by physicist Steve Byrnes, 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://sjbyrnes.com/python/"

\end_inset


\family default
:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Free and open source
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Cleaner syntax compared to MATLAB
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

General-purpose programming language, with extensive examples already on
 the internet on how to do 
\emph on
almost anything a computer can do
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Very high abstraction level, but easy(-ish) tools available also for writing
 performance-critical parts
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Python is a valuable career skill (true for MATLAB, too)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Rising trend; more and more of your current and future colleagues know Python
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Easy to learn; many learning resources available
\end_layout

\begin_layout Standard
From a blog post by data scientist Steve Tjoa, 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stevetjoa.com/305/"

\end_inset


\family default
:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Completely free
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

General–purpose language
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Beautiful syntax
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Inherently object-oriented
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Features that make easy many tasks that are difficult in other languages
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

See e.g.
 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/101268/hidden-features-of-python"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

High level, easy to learn, fast to develop in (true for MATLAB, too)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Popular and has a great community
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Libraries for almost everything already exist
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Specifically in signal processing, can do nearly everything MATLAB does
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Demand for Python programmers is increasing
\end_layout

\begin_layout Standard
From another essay, by Ph.D.
 student Hoyt Koepke, 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.stat.washington.edu/~hoytak/blog/whypython.html"

\end_inset


\family default
:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Holistic language design
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Readability
\begin_inset Index idx
status open

\begin_layout Plain Layout
Readability
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Balance of high level and low level programming
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Language interoperability
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Documentation system
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Hierarchical module system
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Data structures
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Available libraries
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm
\end_layout

\end_inset

Testing framework
\end_layout

\begin_layout Standard
Summarizing the above, Python is a 
\series bold
clear, general-purpose, high-level, well-designed, complete programming
 solution
\series default
 that is 
\series bold
easy to learn
\series default
, has 
\series bold
extensive libraries
\series default
 already available, and is 
\series bold
free and open source
\series default
.
\series bold

\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.25cm 
\backslash
hskip 0.38cm 
\end_layout

\end_inset


\begin_inset Formula $\Rightarrow$
\end_inset

 
\series bold
a complete programming solution
\end_layout

\end_inset


\series default
 Note that 
\emph on
complete
\emph default
 includes scientific computing.
\end_layout

\begin_layout Standard
Also, as Python core developer Nick Coghlan writes (emphasis mine):
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

It is important to keep in mind that CPython already has a significant user
 base (sufficient to see Python 
\series bold
ranked by IEEE Spectrum in 2014 as one of the top 5 programming languages
 in the world
\series default
), [...]
\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://python-notes.curiousefficiency.org/en/latest/python3/multicore_python.html#multicore-python "

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Practical things first
\begin_inset CommandInset label
LatexCommand label
name "sec:Practical-things-first"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
hello.py
\family default

\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

print("Hello, world!")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Minimal 
\emph on
hello, world!
\emph default
 in Python 3.
 To run it:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

python3 hello.py
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 1cm
\end_layout

\end_inset

Let's make note of some practical things:
\end_layout

\begin_layout Itemize
Two major versions of the Python language exist at the time of this writing.
 In this material, we will (almost everywhere) ignore the legacy version,
 and concentrate only on the current one, namely Python
\begin_inset space ~
\end_inset

3.
\end_layout

\begin_layout Itemize
Rigorously speaking, 
\begin_inset Quotes eld
\end_inset

Python
\begin_inset Quotes erd
\end_inset

 is a language 
\emph on
specification
\emph default
, just like 
\begin_inset Quotes eld
\end_inset

C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

Fortran
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Different implementations of this specification exist, including CPython
\begin_inset Index idx
status open

\begin_layout Plain Layout
CPython (standard Python interpreter)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!interpreter!CPython (standard)
\end_layout

\end_inset

, Jython
\begin_inset Index idx
status open

\begin_layout Plain Layout
Jython (Python interpreter)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!interpreter!Jython
\end_layout

\end_inset

, IronPython
\begin_inset Index idx
status open

\begin_layout Plain Layout
IronPython (Python interpreter)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!interpreter!IronPython
\end_layout

\end_inset

, and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyPy (Python interpreter)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!interpreter!PyPy
\end_layout

\end_inset

PyPy.
\end_layout

\begin_layout Itemize

\emph on
CPython
\emph default
 is however the de facto standard implementation; all the others occupy
 only small niches.
 CPython is what you get when you install Python, and also what people almost
 always mean when talking about Python, the programming language.
\end_layout

\begin_layout Itemize
Do not confuse CPython with 
\emph on
Cython
\emph default
, which is a compiler for performance-critical code (more later).
\end_layout

\end_deeper
\begin_layout Itemize
Some code examples online 
\begin_inset Quotes erd
\end_inset


\family typewriter
from mymodule import *
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
import *
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
This injects everything from 
\family typewriter
mymodule
\family default
 into the current namespace.
\end_layout

\begin_layout Itemize
This is useful in an interactive session, where constantly typing in module
 paths gets in the way of your actual work.
\end_layout

\begin_layout Itemize
But in a program, resist the temptation.
 Namespacing is a highly useful practical feature for improving code readability
\begin_inset Index idx
status open

\begin_layout Plain Layout
Readability
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Organization of this material:
\end_layout

\begin_deeper
\begin_layout Itemize
Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Motivation"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Understanding-Python"

\end_inset

 cover practicalities and background.
\end_layout

\begin_deeper
\begin_layout Itemize
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Practical-things-first"

\end_inset

 for tools, installation and such.
\end_layout

\begin_layout Itemize
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Python-vs.-MATLAB"

\end_inset

 for similarities and differences between Python, and MATLAB and Fortran.
\begin_inset Newline newline
\end_inset

Library recommendations for scientific use are also listed here.
\end_layout

\begin_layout Itemize
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Understanding-Python"

\end_inset

 places Python in the broad context of programming languages.
\end_layout

\end_deeper
\begin_layout Itemize
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:How-to-Python"

\end_inset

 for Python hands-on.
 Links to tutorials, and a collection of information useful for beginners
 that I have not seen gathered into one place in other beginner materials.
\end_layout

\begin_layout Itemize
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Advanced-topics"

\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

Part II
\begin_inset Quotes erd
\end_inset

 of this course, containing a selection of advanced topics.
 Feel free to browse and pick what you need.
 The final subsection on the very basics of software engineering is recommended.
\end_layout

\end_deeper
\begin_layout Subsection
Apps and tools
\end_layout

\begin_layout Itemize
At the bare minimum, you will want to bring at least your favorite terminal
 and shell (command prompt), and a syntax highlighting text editor (e.g.
 Notepad++, gedit, or TextWrangler for Windows, Linux, or OS X, respectively).
\end_layout

\begin_layout Itemize
You will likely want also 
\emph on
IPython
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
IPython
\end_layout

\end_inset

, which adds several helpful features to the interactive session, such as
 command history (via GNU readline), tab completion, and colored syntax
 highlighting in the interactive session.
 This is highly useful for quick interactive prototyping (think 
\begin_inset Quotes eld
\end_inset

MATLAB console for Python
\begin_inset Quotes erd
\end_inset

).
 IPython is also integrated into many IDEs (integrated development environments).
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://ipython.org/"

\end_inset


\end_layout

\begin_layout Itemize
IPython has a graphical cousin, 
\emph on
Jupyter Notebook
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Jupyter Notebook
\end_layout

\end_inset

, which nowadays supports many programming languages (still including Python).
 
\begin_inset Quotes eld
\end_inset

Notebook
\begin_inset Quotes erd
\end_inset

 here refers to the style of interactive math scripting, with inline plotting,
 that was popularized, among other programs, by Mathematica.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

At least in Linux, Jupyter installs as a command-line application.
 Invoking 
\begin_inset Quotes eld
\end_inset


\family typewriter
jupyter notebook
\family default

\begin_inset Quotes erd
\end_inset

 (note the space) in the terminal starts the local server, and pops up the
 GUI in your default web browser.
 You can also play around with Jupyter online, without installing it, at:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://try.jupyter.org/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

This may be convenient for interactive experimentation while learning Python.
 If you use try.jupyter.org and want to save your work, be sure to 
\begin_inset Quotes eld
\end_inset

File 
\begin_inset Formula $\rhd$
\end_inset

 Download as 
\begin_inset Formula $\rhd$
\end_inset

 Notebook (.ipynb)
\begin_inset Quotes erd
\end_inset

 it when you finish.
\end_layout

\begin_layout Itemize
You may also want an IDE (Integrated Development Environment)
\begin_inset Index idx
status open

\begin_layout Plain Layout
IDE (Integrated Development Environment)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Integrated Development Environment (IDE)
\end_layout

\end_inset

, especially the one called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset


\series bold
Spyder
\series default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Spyder — The Scientific PYthon Development EnviRonment
\emph default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/spyder-ide/spyder"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

This is currently the closest to the MATLAB IDE (in a good way) you will
 get in Python.
 Spyder strikes a balance between interactive, scientific use oriented and
 software development oriented features, along with sufficient support for
 keeping multi-file projects together.
 It also provides a Jupyter console.
\end_layout

\begin_layout Itemize

\emph on
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PyCharm (IDE)
\end_layout

\end_inset

PyCharm
\emph default
 is a commercial alternative aimed at professional software development.
 The freeware community edition is fine, but advanced users (and users who
 aim at becoming advanced in the future) should be aware that Cython features
 in PyCharm are only available via a commercial support license, which can
 be relatively expensive.
\end_layout

\begin_layout Itemize

\emph on
Eclipse
\begin_inset Index idx
status open

\begin_layout Plain Layout
Eclipse (IDE)
\end_layout

\end_inset


\emph default
 with the 
\emph on
PyDev
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyDev (Eclipse add-on)
\end_layout

\end_inset


\emph default
 add-on is focused on the development of large traditional (i.e.
 not scientific computing) applications.
 Advanced profiling requires a license for an add-on called 
\emph on
pyvmmonitor
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
Pyzo
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pyzo (IDE)
\end_layout

\end_inset


\emph default
 is aimed at lightweight development for scientists, but lacks management
 for multi-file projects.
\end_layout

\begin_layout Itemize

\emph on
IDLE
\begin_inset Index idx
status open

\begin_layout Plain Layout
IDLE (IDE)
\end_layout

\end_inset


\emph default
 comes with Python, but is very spartan, difficult to use, and seriously
 outdated.
 It is only mentioned here because the name may turn up in online conversations
 and documentation.
\end_layout

\end_deeper
\begin_layout Subsection
Installing Python
\end_layout

\begin_layout Itemize
An all-in-one scientific Python distribution
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scientific Python distributions
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!distributions for scientific users
\end_layout

\end_inset

 is an easy option regardless of the OS platform.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Anaconda
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Anaconda (Python distribution)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!distribution!Anaconda
\end_layout

\end_inset

 [Windows, Linux, OS X]:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.anaconda.com/"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
Enthought Python Distribution
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!distribution!Enthought
\end_layout

\end_inset


\emph on
Enthought Python Distribution
\emph default
 [Windows, Linux, OS X]:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.enthought.com/product/enthought-python-distribution/"

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Python(x,y)
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Python(x,y) (Python distribution)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!distribution!Python(x,y)
\end_layout

\end_inset

 [Windows; possibly no longer maintained, latest release 2015]:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://python-xy.github.io/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Scientific Python distributions typically have pre-installed the most common
 scientific libraries (e.g.
 NumPy, SciPy, Matplotlib) and all their dependencies (e.g.
 BLAS and LAPACK).
\end_layout

\begin_layout Itemize
In Linux and OS X, the OS itself comes with Python pre-installed.
 Some programmers however frown (for good reason) on using the system Python
 installation for software development, because it is then theoretically
 possible that, if you install system-level library upgrades due to the
 needs of your own project, this may break the OS.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

(...but very unofficially — and strictly at one's own risk — one can often
 get away with the system Python.)
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Installing and uninstalling Python packages (libraries)
\end_layout

\begin_layout Standard
If you use Anaconda:
\end_layout

\begin_layout Itemize
Use the 
\family typewriter
conda
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
conda (Anaconda package manager)
\end_layout

\end_inset

 package manager.
\end_layout

\begin_layout Itemize
User manual:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://conda.io/docs/user-guide/tasks/manage-pkgs.html"

\end_inset


\end_layout

\begin_layout Itemize
As the user manual notes, some Python packages are not available in the
 Anaconda repository, and in these cases it is ok to use 
\family typewriter
pip
\family default
 (for general instructions, see below).
 But before you do, be sure to read this very short section of the user
 guide:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://conda.io/docs/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages"

\end_inset


\end_layout

\begin_layout Standard
If you use a separately installed Python on *nix (Linux, OS X):
\end_layout

\begin_layout Itemize
Use the 
\family typewriter
pip
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pip package manager
\end_layout

\end_inset

 package manager (included with Python):
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
pip install packagename --user
\end_layout

\begin_layout Itemize
This installs the Python package called 
\family typewriter
packagename
\family default
 just for you, without touching the OS.
 Administrative privileges are not required.
\end_layout

\begin_layout Itemize
If you install things that include command-line apps, such as Cython, you
 may need to to modify your 
\family typewriter
PATH
\family default
 (on the OS level) to look for binaries in the appropriate place (which
 depends on the OS).
\end_layout

\begin_layout Itemize
When, as above, no explicit URL is specified, 
\family typewriter
pip
\family default
 will install from PyPI
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyPI (PYthon Package Index)
\end_layout

\end_inset

, the 
\emph on
Python Package Index
\emph default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://pypi.python.org/pypi"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Most Python-based projects push their releases here, since this is the one
 place that pretty much everyone in the Python community is aware of.
\end_layout

\begin_layout Itemize

\family typewriter
pip 
\family default
automatically manages dependencies at the Python package level; any required
 other packages are automatically installed.
 However, note that 
\family typewriter
pip
\family default
 cannot manage low-level (C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

 or Fortran
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

) dependencies; you still have to install libraries such as BLAS and LAPACK
 by other methods.
\end_layout

\end_deeper
\begin_layout Itemize
If the package is not on PyPI, check if the project has a page on GitHub.
\end_layout

\begin_deeper
\begin_layout Itemize
The README often contains installation instructions.
\end_layout

\begin_layout Itemize
Many packages are made using 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
setuptools
\end_layout

\end_inset

setuptools
\family default
; in that case:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
python setup.py install --user
\end_layout

\end_deeper
\begin_layout Itemize
To uninstall, use 
\family typewriter
pip
\family default
:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
pip uninstall packagename
\end_layout

\begin_layout Itemize
No need to specify 
\family typewriter
--user
\family default
 for 
\family typewriter
uninstall
\family default
; 
\family typewriter
pip
\family default
 will automatically look there first.
\end_layout

\begin_layout Itemize

\family typewriter
pip 
\family default
is able to uninstall most packages, including any that use 
\family typewriter
setuptools
\family default
, even if 
\family typewriter
pip
\family default
 itself did not install the package.
 Basically, only packages created using legacy 
\family typewriter
distutils
\family default
 contain no metadata, and thus cannot be uninstalled automatically.
\end_layout

\begin_layout Itemize
If you have accidentally installed several versions of the same package
 (mainly a concern with installs not managed by 
\family typewriter
pip
\family default
), you can just run the uninstall command several times until 
\family typewriter
pip
\family default
 says that the package is not installed (it will uninstall the different
 versions one by one).
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
pip list
\family default
 shows the package names of all currently installed packages (along with
 version numbers).
\end_layout

\begin_layout Itemize

\family typewriter
pip show packagename
\family default
 gives a short description of an installed package, including version number,
 install location, and homepage URL.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Language versions: Python 3 (current) vs.
 Python 2 (legacy)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!2 (legacy) and 3 (current)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Python 3.x is the current major version of the language — 
\series bold
use it!
\end_layout

\begin_deeper
\begin_layout Itemize
Also known unoffficially as 
\emph on
Python 3000
\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!3000 (Python 3)
\end_layout

\end_inset


\emph default
 or 
\emph on
py3k
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
py3k (Python 3)
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Depending on your Python installation, as of late 2017, you may still need
 to invoke Python
\begin_inset space ~
\end_inset

3 explicitly as 
\family typewriter
python3
\family default
, if bare 
\family typewriter
python
\family default
 for some reason still points to an installation of Python
\begin_inset space ~
\end_inset

2.7.
 (For example, some Linux distributions are still in the process of migrating
 to Python
\begin_inset space ~
\end_inset

3, or have only recently migrated.)
\end_layout

\begin_layout Itemize

\family typewriter
python --version
\family default
 to make sure.
\end_layout

\begin_layout Itemize
Some Python
\begin_inset space ~
\end_inset

3 tips for scientists in particular, but mainly aimed at those migrating
 from Python
\begin_inset space ~
\end_inset

2:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://python-3-for-scientists.readthedocs.io/en/latest/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Python 2.7 is the 
\emph on
final
\emph default
 legacy version (released 2010)
\end_layout

\begin_deeper
\begin_layout Itemize
Legacy support will be completely dropped by the year 2020; 
\series bold
do not use
\series default
 Python 2 any more!
\end_layout

\begin_deeper
\begin_layout Itemize
(...unless you absolutely have to, and you know what you are doing.)
\end_layout

\end_deeper
\begin_layout Itemize
There will be 
\emph on
no
\emph default
 official Python 2.8, as stated in the official 
\emph on
Python 2.8 Un-release Schedule
\family sans
\emph default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0404/"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
The official upgrade path for existing Python
\begin_inset space ~
\end_inset

2 codes is to port them to Python
\begin_inset space ~
\end_inset

3.
\end_layout

\begin_layout Itemize
All major scientific projects — and 
\emph on
almost
\emph default
 all libraries, in general — have already ported.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.python3statement.org/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To a very large extent, Python 3 and Python 2 are the same language, but
 there are some important differences, and a major break in backward compatibili
ty that was required to support Unicode properly.
\end_layout

\begin_layout Itemize
The Python language developers have promised not to break backward compatibility
 again, until something really major happens in IT (of a magnitude similar
 to the popularization of the internet in the late 1990s, which eventually
 led to Unicode).
 See:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Nick Coghlan: Why Python 4.0 won't be like Python 3.0
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://www.curiousefficiency.org/posts/2014/08/python-4000.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Nick Coghlan: The transition to multilingual programming [
\series bold
human
\series default
, not computer, languages!]
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://www.curiousefficiency.org/posts/2014/08/multilingual-programming.html "

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Brett Cannon: Why Python 3 exists:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://snarky.ca/why-python-3-exists/"

\end_inset


\end_layout

\begin_layout Itemize
Just like Fortran
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

 or C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

, the Python language is still evolving.
 Just to give a taste, some exciting recent developments include:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Literal string interpolation (f-strings
\begin_inset Index idx
status open

\begin_layout Plain Layout
f-strings (string formatting)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!formatting!f-strings
\end_layout

\end_inset

)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Literal string interpolation (f-strings)
\end_layout

\end_inset

 (3.6+):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0498/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Additional unpacking generalizations
\begin_inset Index idx
status open

\begin_layout Plain Layout
Unpacking!generalizations in Python 3.5+
\end_layout

\end_inset

 (3.5+):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0448/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Coroutines
\begin_inset Index idx
status open

\begin_layout Plain Layout
Coroutine
\end_layout

\end_inset

 with async and await syntax (3.5+):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0492/"

\end_inset


\end_layout

\begin_layout Itemize
PEP
\begin_inset Index idx
status open

\begin_layout Plain Layout
PEP (Python Enhancement Proposal)
\end_layout

\end_inset

 stands for 
\emph on
Python Enhancement Proposal
\emph default
.
 It is the primary process through which new language features are introduced
 to Python.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Python_(programming_language)#Development"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Finally, is Python stable enough as a platform to create future-proof scientific
 computing software, considering that Fortran software written decades ago
 still compiles and runs?
\end_layout

\begin_layout Plain Layout
Only time will tell.
 My personal take is that Python
\begin_inset space ~
\end_inset

3, probably so.
\end_layout

\begin_layout Plain Layout
Judging by the availability of scientific libraries, many other programmers
 in scientific computing seem to have reached the same conclusion.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Python vs.
 MATLAB (and Fortran)
\begin_inset CommandInset label
LatexCommand label
name "sec:Python-vs.-MATLAB"

\end_inset


\end_layout

\begin_layout Standard
Let us look, from a pragmatic viewpoint, at how Python compares to a long-time
 favorite in scientific computing, namely MATLAB.
 In the final subsection, we will also list some important practical points
 to keep in mind when working with Python, coming from a background in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset

MATLAB and/or 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

Fortran.
\end_layout

\begin_layout Standard
There are things that both Python and MATLAB do well, and then there are
 aspects where one of them is a better choice.
 We will now look at each of the three categories in detail.
\end_layout

\begin_layout Standard
By necessity, the following list is incomplete, but hopefully sufficient
 as a first overview.
\end_layout

\begin_layout Subsection
Things both Python and MATLAB do well (and where to look in Python)
\end_layout

\begin_layout Standard
After fundamental core functionality, in no particular order.
 In MATLAB, some of the following may require toolboxes.
\end_layout

\begin_layout Standard
Takeaway message: 
\series bold
NumPy, SciPy, Matplotlib
\series default
.
 Add others as needed.
\end_layout

\begin_layout Itemize
Array-based (
\begin_inset Quotes eld
\end_inset

vectorized
\begin_inset Quotes erd
\end_inset

) math 
\begin_inset Formula $\rightarrow$
\end_inset

 NumPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
import numpy as np
\end_layout

\begin_deeper
\begin_layout Itemize
Pretty much everyone renames the 
\family typewriter
numpy
\family default
 namespace to 
\family typewriter
np
\family default
 upon loading; even the official NumPy documentation uses this convention.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
np.array
\family default
: similar to MATLAB's matrices, but based on cartesian tensors.
\end_layout

\begin_layout Itemize
See also 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Numexpr
\end_layout

\end_inset

Numexpr, which can eliminate temporaries, giving slightly higher performance
 and (potentially much) lower memory use in cases where this matters.
 Numexpr also gives multithreading.
\end_layout

\end_deeper
\begin_layout Itemize
Linear equation system solvers, eigenvalue solvers 
\begin_inset Formula $\rightarrow$
\end_inset

 NumPy
\end_layout

\begin_deeper
\begin_layout Itemize
Online manual:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

E.g.
 for linear algebra, go to NumPy Reference 
\begin_inset Formula $\rhd$
\end_inset

 Linear algebra:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/reference/routines.linalg.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sparse matrices, sparse solvers 
\begin_inset Formula $\rightarrow$
\end_inset

 SciPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
SciPy
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
import scipy.sparse
\end_layout

\begin_layout Itemize
Online manual:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/scipy/reference/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

For example, sparse linear algebra:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/scipy/reference/sparse.linalg.html"

\end_inset


\end_layout

\begin_layout Itemize
As of late 2017, bleeding edge: 
\begin_inset Formula $\rightarrow$
\end_inset

 PyRSB add-on for fast multithreaded sparse matrices
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/michelemartone/pyrsb"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Support for MATLAB's 
\family typewriter
.mat
\family default
 file format 
\begin_inset Formula $\rightarrow$
\end_inset

 SciPy
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
import scipy.io
\end_layout

\begin_layout Itemize

\family typewriter
scipy.io.loadmat()
\family default
, 
\family typewriter
scipy.io.savemat()
\end_layout

\end_deeper
\begin_layout Itemize
Special functions (Airy, Bessel, 
\begin_inset Formula $\Gamma$
\end_inset

, ...) 
\begin_inset Formula $\rightarrow$
\end_inset

 SciPy
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
import scipy.special
\end_layout

\end_deeper
\begin_layout Itemize
Numerical integration, ODE (IVP) solvers 
\begin_inset Formula $\rightarrow$
\end_inset

 SciPy
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
import scipy.integrate
\end_layout

\end_deeper
\begin_layout Itemize
Signal processing (sampled time series, like audio) 
\begin_inset Formula $\rightarrow$
\end_inset

 SciPy
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
import scipy.signal
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Plotting 
\begin_inset Formula $\rightarrow$
\end_inset

 Matplotlib
\begin_inset Index idx
status open

\begin_layout Plain Layout
Matplotlib
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
import matplotlib.pyplot as plt
\end_layout

\begin_deeper
\begin_layout Itemize
MATLAB-style procedural API
\begin_inset Index idx
status open

\begin_layout Plain Layout
API (application programming interface)
\end_layout

\end_inset

: 
\family typewriter
figure()
\family default
, 
\family typewriter
plot()
\family default
, 
\family typewriter
xlabel()
\family default
, 
\family typewriter
axis()
\family default
, 
\family typewriter
title()
\family default
, 
\family typewriter
savefig()
\family default
, etc.
\end_layout

\end_deeper
\begin_layout Itemize
How to Matplotlib, with code examples:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://matplotlib.org/gallery.html"

\end_inset


\end_layout

\begin_layout Itemize
Matplotlib is the Swiss army chainsaw of plotting, and if you want maximum
 tweakability for publi\SpecialChar softhyphen
cation-quality graphics, this is where you want to
 go.
 However, it was mainly designed as a plotter for NumPy, and sometimes can
 be tedious to use.
 For example, in data analysis, there are use cases in which Matplotlib
 is not very convenient.
 Many things have significantly improved in Matplotlib 2.0 (released 2017),
 but the following online essay from 2012 is still at least partly current
\family sans
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
Karl Vogel: Will it Python? Machine Learning for Hackers Chapter 1, Part
 5: Trellis graphs.
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://slendermeans.org/ml4h-ch1-p5.html"

\end_inset


\end_layout

\begin_layout Itemize
Look also at other libraries in case those better suit your particular needs:
\end_layout

\begin_deeper
\begin_layout Itemize
ggplot
\begin_inset Index idx
status open

\begin_layout Plain Layout
ggplot (Grammar of Graphics based plotter)
\end_layout

\end_inset

: Grammar of Graphics based plotter for Python; professional plots in very
 few lines of code
\end_layout

\begin_layout Itemize
VisPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
VisPy (plotter)
\end_layout

\end_inset

: new contender for high-performance scientific visualization using OpenGL.
\end_layout

\begin_deeper
\begin_layout Itemize
Aims to handle 
\begin_inset Formula $10^{7}$
\end_inset

 primitives in realtime.
\end_layout

\begin_layout Itemize
Luke Campagnola: VisPy — Harnessing The GPU For Fast, High Level Visualization
\family sans
:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://www.youtube.com/watch?v=_3YoaeoiIFI"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://conference.scipy.org/proceedings/scipy2015/pdfs/luke_campagnola-vispy.pdf"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Graphical debugger 
\begin_inset Formula $\rightarrow$
\end_inset

 Spyder
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Interactive session 
\begin_inset Formula $\rightarrow$
\end_inset

 IPython
\begin_inset Index idx
status open

\begin_layout Plain Layout
IPython
\end_layout

\end_inset

, Jupyter Notebook
\begin_inset Index idx
status open

\begin_layout Plain Layout
Jupyter Notebook
\end_layout

\end_inset

, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset

Spyder
\end_layout

\begin_layout Itemize
Documentation
\begin_inset Index idx
status open

\begin_layout Plain Layout
Documentation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Help system
\end_layout

\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
help(object)
\end_layout

\begin_deeper
\begin_layout Itemize
Also, 
\family typewriter
dir(object)
\family default
 to see what attributes it has.
\end_layout

\begin_layout Itemize

\family typewriter
help(object)
\family default
 prints 
\family typewriter
object
\family default
's 
\emph on
docstring
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
docstring
\end_layout

\end_inset

 Python software, just like the MATLAB library, is often extensively documented.
\end_layout

\begin_layout Itemize
In IPython, 
\family typewriter
object?
\family default
 usually also works, but in case of builtins such as 
\family typewriter
list
\family default
, might not show the full help.
 IPython's help screen (to open, just 
\family typewriter
?
\family default
) says that 
\family typewriter
object?
\family default
 shows details about 
\family typewriter
object
\family default
, and 
\family typewriter
help
\family default
 invokes Python's own help system.
\end_layout

\begin_layout Itemize
For those interested in keyboard commands, the help reader in terminal IPython
 is effectively 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GNU less (software)
\end_layout

\end_inset

GNU 
\family typewriter
less
\begin_inset Index idx
status open

\begin_layout Plain Layout
less (software)
\end_layout

\end_inset


\family default
 (as in 
\family typewriter
less
\family default
 is 
\family typewriter
more
\family default
 and all that).
\end_layout

\begin_deeper
\begin_layout Itemize
The most useful are 
\family typewriter
/
\family default
, 
\family typewriter
n
\family default
, 
\family typewriter
N
\family default
 (search) and 
\family typewriter
Esc
\family default
, 
\family typewriter
u
\family default
 (turn off search match highlighting — less visual noise once you've found
 what you need).
 Note that the search is case sensitive.
 Cheat sheet:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Less_(Unix)#Frequently_used_commands"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The Spyder
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset

 IDE has a graphical window for displaying documentation in pretty-rendered
 form, as long as the docstrings in the code conform to the NumpyDoc standard
 (e.g.
 NumPy, SciPy and Matplotlib all do).
\end_layout

\begin_deeper
\begin_layout Itemize
For the curious, the standard is described at:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt"

\end_inset


\end_layout

\begin_layout Itemize
See also Docstring Conventions:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0257/"

\end_inset


\end_layout

\begin_layout Itemize
It will in any case display the docstrings; just pretty-rendering is only
 available for NumpyDoc.
\end_layout

\end_deeper
\begin_layout Itemize
Also, online documentation:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/index.html"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Tip for 
\series bold
new IPython users
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
IPython configuration
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
ipython profile create
\begin_inset Newline newline
\end_inset

ipython locate profile
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

This first generates a default configuration file, and then shows where
 it is stored.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

At that location, there should now be a file called 
\family typewriter
ipython_config.py
\family default
.
 Open it in a text editor, change the value of 
\family typewriter
c.TerminalInteractiveShell.autocall
\family default
 to 1, and save.
 Restart IPython if already open.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

After this is done once, then in any interactive session, you can 
\family typewriter
help object
\family default
 without the parentheses, which is much faster to type.
\end_layout

\end_deeper
\begin_layout Itemize
Low-level interface for performance-critical code (like MATLAB's 
\begin_inset Index idx
status open

\begin_layout Plain Layout
MEX (MATLAB)
\end_layout

\end_inset

MEX) 
\begin_inset Formula $\rightarrow$
\end_inset

 Cython
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cython
\end_layout

\end_inset

, Numba
\begin_inset Index idx
status open

\begin_layout Plain Layout
Numba
\end_layout

\end_inset

, CFFI
\begin_inset Index idx
status open

\begin_layout Plain Layout
CFFI (C Foreign Function Interface)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
FFI (Foreign function interface)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Foreign function interface (FFI)
\end_layout

\end_inset

, f2py
\begin_inset Index idx
status open

\begin_layout Plain Layout
f2py (Fortran to Python interface)
\end_layout

\end_inset

.
 Here the options cover a spectrum of different approaches:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Cython
\emph default
 is a superset of the Python language, mainly for writing code operating
 on arrays at native (
\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

machine
\begin_inset Quotes erd
\end_inset

) speed.
 It is a compiled language that produces Python modules.
 Cython can also be used to interface with existing C libraries, but this
 is not its main use in a numerical context.
\end_layout

\begin_layout Itemize

\emph on
Numba
\emph default
 is a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
JIT (just-in-time compiler)
\end_layout

\end_inset

JIT (just-in-time) compiler for a subset of the Python language, based on
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
LLVM
\end_layout

\end_inset

LLVM.
\end_layout

\begin_layout Itemize

\emph on
CFFI
\emph default
 is the 
\emph on
C Foreign Function Interface
\emph default
, meant for interfacing Python with existing C code.
\end_layout

\begin_layout Itemize
Similarly, for Fortran users, 
\emph on
f2py
\emph default
 is the 
\emph on
Fortran to Python interface generator
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Parallel computing
\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)
\end_layout

\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 Cython
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cython
\end_layout

\end_inset

 (OpenMP), mpi4py
\begin_inset Index idx
status open

\begin_layout Plain Layout
mpi4py
\end_layout

\end_inset

 (MPI), 
\family typewriter
concurrent.futures.ProcessPoolExecutor
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
ProcessPoolExecutor
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
concurrent.futures.ProcessPoolExecutor
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0cm 
\backslash
hskip 3.5cm
\end_layout

\end_inset

 
\family typewriter
multiprocessing
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
multiprocessing (module)
\end_layout

\end_inset

, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Numexpr
\end_layout

\end_inset

Numexpr (easy multithreaded NumPy expressions), ZeroMQ
\begin_inset Index idx
status open

\begin_layout Plain Layout
ZeroMQ
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Symbolic math 
\begin_inset Formula $\rightarrow$
\end_inset

 SymPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
SymPy
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://docs.sympy.org/latest/index.html"

\end_inset


\end_layout

\begin_layout Itemize
Also has a code generator for C, C++, Fortran, Julia, Rust, Octave/MATLAB.
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://docs.sympy.org/dev/modules/utilities/codegen.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Hypergeometric functions (Gauss, Kummer, ...) 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
mpmath
\end_layout

\end_inset

mpmath
\end_layout

\begin_layout Itemize
Arbitrary-precision floating point (like MATLAB's VPA) 
\begin_inset Formula $\rightarrow$
\end_inset

 mpmath
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://mpmath.org/doc/current/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
GPGPU
\begin_inset Index idx
status open

\begin_layout Plain Layout
GPGPU
\end_layout

\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Theano
\end_layout

\end_inset

Theano
\end_layout

\begin_deeper
\begin_layout Itemize
GPGPU: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units"

\end_inset


\end_layout

\begin_layout Itemize
Theano allows computing with NumPy arrays on both CPU and GPU with the same
 code.
\end_layout

\end_deeper
\begin_layout Itemize
Convex optimization 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
cvxopt
\end_layout

\end_inset

cvxopt
\end_layout

\begin_layout Itemize
Data analysis for relational and labeled data 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pandas
\end_layout

\end_inset

pandas
\end_layout

\begin_layout Itemize
B-splines 
\begin_inset Formula $\rightarrow$
\end_inset

 bspline
\begin_inset Index idx
status open

\begin_layout Plain Layout
bspline
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Splines
\end_layout

\end_inset

 (for low-level work); 
\begin_inset Formula $\rightarrow$
\end_inset

 SciPy (
\family typewriter
scipy.interpolate
\family default
 for simple fitting)
\end_layout

\begin_layout Itemize
Image processing 
\begin_inset Formula $\rightarrow$
\end_inset

 scikit-image
\begin_inset Index idx
status open

\begin_layout Plain Layout
scikit-image
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The package name is scikit-image, but the actual loadable Python module
 is called 
\family typewriter
skimage
\family default
; i.e.
 to load this library in Python, 
\family typewriter
import skimage
\family default
.
 This naming convention is common to the scikits.
\end_layout

\end_deeper
\begin_layout Itemize
Machine learning 
\begin_inset Formula $\rightarrow$
\end_inset

 scikit-learn
\begin_inset Index idx
status open

\begin_layout Plain Layout
scikit-learn
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Conformal mapping 
\begin_inset Formula $\rightarrow$
\end_inset

 cmtoolkit
\begin_inset Index idx
status open

\begin_layout Plain Layout
cmtoolkit
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Wrappers for SuiteSparse routines:
\end_layout

\begin_deeper
\begin_layout Itemize
CHOLMOD
\begin_inset Index idx
status open

\begin_layout Plain Layout
CHOLMOD
\end_layout

\end_inset

 sparse solver 
\begin_inset Formula $\rightarrow$
\end_inset

 scikit-sparse
\begin_inset Index idx
status open

\begin_layout Plain Layout
scikit-sparse
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In Python, to load it, 
\family typewriter
import sksparse
\family default
.
\end_layout

\begin_layout Itemize
Be sure to use the new 
\family typewriter
sksparse
\family default
; an old, now obsolete version was called 
\family typewriter
scikits.sparse
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
SPQR
\begin_inset Index idx
status open

\begin_layout Plain Layout
SPQR (sparse QR)
\end_layout

\end_inset

 sparse solver 
\begin_inset Formula $\rightarrow$
\end_inset

 sparseqr
\begin_inset Index idx
status open

\begin_layout Plain Layout
sparseqr
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is the (very robust) 
\begin_inset Quotes eld
\end_inset

QR solver
\begin_inset Quotes erd
\end_inset

 that also MATLAB uses for sparse 
\begin_inset Quotes eld
\end_inset


\family typewriter
x = A 
\backslash
 b
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Note that both of these:
\end_layout

\begin_deeper
\begin_layout Itemize
Provide Python interfaces to functionality implemented in the SuiteSparse
 C++ library:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://faculty.cse.tamu.edu/davis/suitesparse.html"

\end_inset


\end_layout

\begin_layout Itemize
Play nicely with SciPy's sparse matrices.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
PDE solvers
\begin_inset Index idx
status open

\begin_layout Plain Layout
PDE solvers
\end_layout

\end_inset

 (with frameworks to build solvers for custom PDEs):
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
The FEniCS computing platform
\begin_inset Index idx
status open

\begin_layout Plain Layout
FEniCS computing platform
\end_layout

\end_inset


\emph default
 (developed at KTH
\family sans
):
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://www.fenicsproject.org/"

\end_inset


\family default
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Kratos Multiphysics
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kratos Multiphysics
\end_layout

\end_inset


\emph default
 (developed at CIMNE):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.cimne.com/websasp/kratos/"

\end_inset


\family default
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
SfePy: Simple Finite Elements in Python
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
SfePy (Simple Finite Elements in Python)
\end_layout

\end_inset

:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://sfepy.org/doc-devel/index.html"

\end_inset


\family default
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mesh import, e.g.
 
\begin_inset Formula $\rightarrow$
\end_inset

 GmshTranslator
\begin_inset Index idx
status open

\begin_layout Plain Layout
GmshTranslator (mesh loader)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Performance profiler GUI, with clickable reports that take you to the relevant
 line of code.
\end_layout

\begin_deeper
\begin_layout Itemize
Spyder IDE includes profiling
\begin_inset Index idx
status open

\begin_layout Plain Layout
Profiling!performance
\end_layout

\end_inset

 integration.
\end_layout

\begin_deeper
\begin_layout Itemize
Function-level profiling (Python's cProfile
\begin_inset Index idx
status open

\begin_layout Plain Layout
cProfile (performance profiler)
\end_layout

\end_inset

) is supported out of the box.
\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
Line-level profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
line_profiler
\end_layout

\end_inset

Line-level profiling (like MATLAB's) is available as an official add-on:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://github.com/spyder-ide/spyder-line-profiler"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
Memory-use profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
memory_profiler
\end_layout

\end_inset

Memory-use profiling is available as an official add-on:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://github.com/spyder-ide/spyder-memory-profiler"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Both Python and MATLAB run on all major OS platforms (Windows, Linux, OS
 X).
\end_layout

\begin_deeper
\begin_layout Itemize
Python is also available in many low-resource environments, such as smartphones
 and Raspberry
\begin_inset space ~
\end_inset

Pi.
\end_layout

\end_deeper
\begin_layout Itemize
In calls to library routines, no need to specify low-level details such
 as array sizes (contrast C, Fortran).
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
MATLAB advantages
\end_layout

\begin_layout Itemize
Commercial-product end-user convenience.
\end_layout

\begin_deeper
\begin_layout Itemize
Python is the bazaar to MATLAB's one-stop shop.
\end_layout

\begin_deeper
\begin_layout Itemize
In Python, sometimes you may need to install a library even to get a specific
 feature (e.g.
 SPQR).
\end_layout

\begin_layout Itemize
Installation is usually trivial, but it's one more step to take, and one
 more line for the 
\family sans
Dependencies
\family default
 section of your README.
\end_layout

\begin_layout Itemize
Regardless of whether you intend to publish your code, it's a good idea
 to write down which libraries it needs — so that you can still run your
 code on a different computer five years from now.
\end_layout

\end_deeper
\begin_layout Itemize
Python does not guess.
\end_layout

\begin_deeper
\begin_layout Itemize
To write performance-optimal code, you choose details such as sparse matrix
 storage formats and solver algorithms yourself — just like in Fortran.
\end_layout

\begin_layout Itemize
This is by design; the KISS principle
\begin_inset Index idx
status open

\begin_layout Plain Layout
KISS principle
\end_layout

\end_inset

 is part of the philosophy of the Python community
\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!philosophy
\end_layout

\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Community focused specifically on numerics.
\end_layout

\begin_deeper
\begin_layout Itemize
If it's not built-in, you can find it on MATLAB File Exchange.
\end_layout

\begin_layout Itemize
Many people working in numerics already use Python and publish libraries,
 but every esoteric thing developed by researchers writing their codes in
 MATLAB might not be (readily) available for Python.
\end_layout

\begin_deeper
\begin_layout Itemize
For example, in kernel density estimation, the automatic bandwidth estimation
 method of Botev, Grotowski and Kroese, where the original code was written
 in MATLAB, is only available for Python in the library PyQt-Fit, which
 is old and has not been ported to Python
\begin_inset space ~
\end_inset

3.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Highly polished, complete IDE for scientists.
\end_layout

\begin_deeper
\begin_layout Itemize
Python is getting there (Spyder), but some features such as automated refactorin
g are not available.
\end_layout

\begin_layout Itemize
Different Python IDEs offer different features (incl.
 refactoring); but Spyder is overall best for scientists.
\end_layout

\end_deeper
\begin_layout Itemize
Interactive figure editor.
\end_layout

\begin_deeper
\begin_layout Itemize
Matplotlib
\begin_inset Index idx
status open

\begin_layout Plain Layout
Matplotlib
\end_layout

\end_inset

 provides only very basic interactivity for exploration (zooming, panning,
 rotation for 3D).
\end_layout

\begin_layout Itemize
Not a big deal; script your annotations, too.
 Or export to 
\family typewriter
.svg
\family default
 (or 
\family typewriter
.pdf
\family default
), and annotate in Inkscape
\begin_inset Index idx
status open

\begin_layout Plain Layout
Inkscape (vector graphics app)
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Surprisingly clean 3D plotting
\begin_inset Index idx
status open

\begin_layout Plain Layout
3D plotting
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Plotting (3D)
\end_layout

\end_inset

 API
\begin_inset Index idx
status open

\begin_layout Plain Layout
API (application programming interface)
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
For historical reasons, in Python can't just 
\family typewriter
plot3()
\family default
 anywhere, but must create a 3D axis object:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html"

\end_inset


\end_layout

\begin_layout Itemize
Start with 
\family typewriter
import mpl_toolkits.mplot3d.axes3d.Axes3D as Axes3D
\family default
, and see code examples.
\end_layout

\end_deeper
\begin_layout Itemize
Maybe some specific algorithms built into MATLAB not yet available in Python?
\end_layout

\begin_deeper
\begin_layout Itemize
Usually there are alternatives.
\end_layout

\end_deeper
\begin_layout Itemize
SimuLink
\begin_inset Index idx
status open

\begin_layout Plain Layout
SimuLink (MATLAB)
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
No equivalent alternative exists.
 This is a textbook example of a software niche that is a more likely target
 for commercial products than open-source projects.
\end_layout

\begin_layout Itemize
If you really need this functionality in Python, and are comfortable with
 scripting, you may want to look at the Python Block Model Simulator.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/masfaraud/BMSpy"

\end_inset


\end_layout

\begin_layout Itemize
For a few more alternative suggestions, see:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.quora.com/When-will-there-be-a-Simulink-like-alternative-for-Python"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Python advantages
\end_layout

\begin_layout Itemize
Anything outside scientific computing that your code may also want to do,
 such as:
\end_layout

\begin_deeper
\begin_layout Itemize
Graphical user interfaces (GUI)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Graphical user interface (GUI)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
GUI (graphical user interface)
\end_layout

\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 Kivy
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kivy
\end_layout

\end_inset

, PyQt
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyQt
\end_layout

\end_inset

, PyGTK
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyGTK
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Plotting in a GUI 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyQtGraph
\end_layout

\end_inset

PyQtGraph
\end_layout

\end_deeper
\begin_layout Itemize
Command-line interfaces (CLI)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Command-line interface (CLI)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
CLI (command-line interface)
\end_layout

\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
argparse
\begin_inset Index idx
status open

\begin_layout Plain Layout
argparse (module)
\end_layout

\end_inset


\family default
 in the standard library
\end_layout

\begin_layout Itemize
Web apps
\begin_inset Index idx
status open

\begin_layout Plain Layout
Web apps
\end_layout

\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 Flask
\begin_inset Index idx
status open

\begin_layout Plain Layout
Flask
\end_layout

\end_inset

, Django
\begin_inset Index idx
status open

\begin_layout Plain Layout
Django
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Databases
\begin_inset Index idx
status open

\begin_layout Plain Layout
Databases
\end_layout

\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
sqlite3
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
sqlite3 (databases)
\end_layout

\end_inset

, MySQL Connector/Python
\begin_inset Index idx
status open

\begin_layout Plain Layout
MySQL Connector/Python (databases)
\end_layout

\end_inset

, python-sql
\begin_inset Index idx
status open

\begin_layout Plain Layout
python-sql (databases)
\end_layout

\end_inset

, TinyDB
\begin_inset Index idx
status open

\begin_layout Plain Layout
TinyDB (databases)
\end_layout

\end_inset

, redis-py
\begin_inset Index idx
status open

\begin_layout Plain Layout
redis-py (databases)
\end_layout

\end_inset

, python-memcached
\begin_inset Index idx
status open

\begin_layout Plain Layout
python-memcached (databases)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Computer science, such as natural language processing (NLP) 
\begin_inset Formula $\rightarrow$
\end_inset

 nltk
\begin_inset Index idx
status open

\begin_layout Plain Layout
nltk (library for natural language processing)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Scripting at the OS level (a very powerful replacement for shell scripts/bat
 files)
\end_layout

\begin_deeper
\begin_layout Itemize
Integration (as in making existing software packages talk to each other)
\end_layout

\end_deeper
\begin_layout Itemize
Scripting inside apps that support Python scripts
\end_layout

\begin_deeper
\begin_layout Itemize
Blender3D was one of the first popular apps to include a Python API
\begin_inset Index idx
status open

\begin_layout Plain Layout
API (application programming interface)
\end_layout

\end_inset

 (added in v2.25 in 2002).
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Cleanness of code and design.
\end_layout

\begin_deeper
\begin_layout Itemize
Python has been jokingly described as 
\begin_inset Quotes eld
\end_inset

executable pseudocode
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pseudocode
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Pseudocode"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Clarity and simplicity are guiding principles, both in the language itself,
 and in the Python community.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!philosophy
\end_layout

\end_inset

The philosophy mirrors that of:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
It seems that perfection is attained not when there is nothing more to add,
 but when there is nothing more to remove.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

–Antoine de Saint Exupéry
\end_layout

\begin_layout Itemize

\emph on
Everything should be made as simple as possible, but not simpler
\emph default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\emph on
–Albert Einstein? (Maybe not in these words: 
\family sans
\emph default

\begin_inset CommandInset href
LatexCommand href
target "https://quoteinvestigator.com/2011/05/13/einstein-simple/"

\end_inset


\emph on
)
\end_layout

\end_deeper
\begin_layout Itemize
For example, aggressive namespacing
\begin_inset Index idx
status open

\begin_layout Plain Layout
Namespace
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
You will almost always immediately know which module or library each function
 call comes from.
\end_layout

\begin_layout Itemize
If no explicit module path in the call itself, look for a 
\family typewriter
from mymodule import foo
\family default
 in the file (importing just that function directly into the current namespace)
\end_layout

\begin_layout Itemize
If the module path does not ring any bells for you, look for an 
\family typewriter
import a.b.c as mymodule
\family default
 in the file, to see if it was renamed locally.
\end_layout

\begin_layout Itemize
Failing that, internet.
 With very little detective work, you now already have two pieces of information
: not only the function name, but also its (original) module path, which
 together are sufficient to identify the function uniquely.
\end_layout

\begin_layout Itemize
Contrast C, Fortran; where finding where a function comes from may require
 major detective work.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
A mature full software ecosystem with automatic dependency management, and
 tools to package and publish your own software in this ecosystem.
\begin_inset Note Note
status open

\begin_layout Plain Layout
...although as a packager, as of this writing, it is still rather difficult
 to make 
\family typewriter
setuptools
\begin_inset Index idx
status open

\begin_layout Plain Layout
setuptools
\end_layout

\end_inset


\family default
 understand what exactly it is that you want.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Free of cost.
\end_layout

\begin_deeper
\begin_layout Itemize
Unlimited instances, excellent for supercomputers and clusters.
\end_layout

\begin_layout Itemize
Also convenient for small businesses and home users.
\end_layout

\end_deeper
\begin_layout Itemize
Open source.
\end_layout

\begin_deeper
\begin_layout Itemize
Open toolchain improves transparency and reproducibility of computational
 science.
\end_layout

\begin_deeper
\begin_layout Itemize
Although to be fair, MATLAB is not typical proprietary software; its documentati
on often states which algorithms it uses.
\end_layout

\end_deeper
\begin_layout Itemize
Ensures quality of code at least in widely used projects, as reputation
 is important.
\end_layout

\begin_layout Itemize
Practically all libraries are also open source.
 Sometimes a library does 99% of what you need...
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
NumPy basics, and key practical differences between Python, and MATLAB or
 Fortran
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy
\end_layout

\end_inset

To translate your MATLAB
\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB!knowledge into Python, translating
\end_layout

\end_inset

 knowledge into Python, read this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

...and for matrices, use 
\family typewriter
np.array
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
np.array
\end_layout

\end_inset

, as indeed recommended there.
 No one uses 
\family typewriter
np.matrix
\family default
 or the 
\family typewriter
matlib
\family default
 wrapper module, but as of late 2017, that part of the documentation has
 still not been removed.
\end_layout

\begin_layout Standard

\series bold
Python is case-sensitive
\series default
, unlike MATLAB
\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset

 and Fortran
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

.
 This also applies to names (variables); 
\family typewriter
A
\family default
 and 
\family typewriter
a
\family default
 are different.
\end_layout

\begin_layout Standard

\series bold
NumPy is based on multidimensional arrays
\series default
, instead of matrices like MATLAB.
 Multidimensional arrays can be thought of as 
\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!array!rank, in the sense of tensors
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Rank!array, in the sense of tensors
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Array rank (number of dimensions)
\end_layout

\end_inset

rank-
\begin_inset Formula $n$
\end_inset

 
\series bold
cartesian tensors
\series default
 for general 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

.
 Matrices are a special case of rank-2 tensors.
 Vectors are usually treated as rank-1 tensors; there is no need to distinguish
 between row and column vectors (unlike in the matrix formalism).
 Following tensor terminology, N-dimensional arrays are called 
\emph on
rank-N arrays
\emph default
.
 To get a feel for how to think in NumPy, see for example the documentation
 for 
\family typewriter
np.dot()
\family default
 and 
\family typewriter
np.einsum()
\family default
.
\end_layout

\begin_layout Standard

\series bold
Fundamental arithmetic operators
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Operator!arithmetic
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Arithmetic operators
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiplication!arithmetic
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
* operator!multiplication
\end_layout

\end_inset


\series bold
 +, -, *, /, ** always operate elementwise
\series default
, like MATLAB's 
\family typewriter
.+
\family default
, 
\family typewriter
.-
\family default
, 
\family typewriter
.*
\family default
, 
\family typewriter
.
\family default
/, 
\family typewriter
.
\family default
^.
 
\series bold
Exponentiation
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Exponentiation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
** operator!exponentiation
\end_layout

\end_inset

 
\series bold
uses **
\series default
 (two stars), not ^ like in many other languages.
 Matrix and vector operations are mainly performed by calling functions
 or methods.
 However, for the particularly common use case of matrix multiplication,
 the operator 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

 (
\family typewriter
operator.matmul
\family default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Operator!
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

 (matrix multiplication)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Matrix multiplication operator, 
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

!matrix multiplication in Python 3.5+
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiplication!matrices
\end_layout

\end_inset

 was introduced in Python
\begin_inset space ~
\end_inset

3.5, released in 2015.
\end_layout

\begin_layout Standard
(
\begin_inset Quotes eld
\end_inset

A dedicated infix operator for matrix multiplication
\begin_inset Quotes erd
\end_inset

:
\family sans
 
\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0465/"

\end_inset


\family default
)
\end_layout

\begin_layout Standard

\series bold
All matrices in NumPy are general
\series default
; symmetricity is not checked.
 Special routines (or flags) may exist for the symmetric case, but not always.
 Under the hood, for dense matrices NumPy and SciPy use LAPACK
\begin_inset Index idx
status open

\begin_layout Plain Layout
LAPACK (Linear Algebra PACKage)
\end_layout

\end_inset

, but not all routines have a Python interface.
 In the rare case where this matters, advanced users programming in Cython
 may want to know about the module 
\family typewriter
scipy.cython_lapack
\family default
, which provides direct low-level access to LAPACK.
\end_layout

\begin_layout Standard

\series bold
\begin_inset Index idx
status open

\begin_layout Plain Layout
Sparse matrices
\end_layout

\end_inset

Sparse matrix storage format
\series default
 in SciPy must be specified explicitly when creating the matrix.
 Usually, a good strategy is to use COO (coordinate format) when creating
 the matrix; and then convert it by one of the methods 
\family typewriter
tocsr()
\family default
 and 
\family typewriter
tocsc()
\family default
 before handing it in to a solver.
 See example below.
 Unlike in Fortran, using the wrong storage format won't break anything,
 but it will significantly decrease performance, because an extra conversion
 then occurs internally each time the sparse matrix is passed into a function
 that expects a different format.
\end_layout

\begin_layout Standard
For those new to the technical details of sparse matrix storage formats,
 Wikipedia provides an overview:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Sparse_matrix#Storing_a_sparse_matrix"

\end_inset


\end_layout

\begin_layout Standard
Like in MATLAB, 
\series bold
explicit looping in Python is very slow
\series default
 (compared to C and Fortran).
 Unlike in MATLAB, in Python the loop will 
\emph on
not
\emph default
 automatically accelerate after running for a while.
 Thus, when programming with NumPy, vectorized operations ought to be preferred,
 even more so than in MATLAB.
\end_layout

\begin_layout Standard
In MATLAB, the automatic acceleration of loops is due to a JIT
\begin_inset Index idx
status open

\begin_layout Plain Layout
JIT (just-in-time compiler)
\end_layout

\end_inset

 (just-in-time) compiler, which is automatically invoked based on run time
 heuristics about code performance.

\family sans
 
\family default
By design, Python does not guess; but there is an explicit, easy-to-use
 JIT compiler called Numba
\begin_inset Index idx
status open

\begin_layout Plain Layout
Numba
\end_layout

\end_inset

, that can be used for acceleration.
\end_layout

\begin_layout Standard
(On JIT in MATLAB, see
\family sans
 
\begin_inset CommandInset href
LatexCommand href
target "https://hips.seas.harvard.edu/blog/2013/05/13/jit-compilation-in-matlab/"

\end_inset

)
\end_layout

\begin_layout Standard
Another option for performance-critical, inherently serial parts of the
 code is to use Cython
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cython
\end_layout

\end_inset

 (roughly, the Python equivalent to MATLAB's MEX
\begin_inset Index idx
status open

\begin_layout Plain Layout
MEX (MATLAB)
\end_layout

\end_inset

), to compile those parts of the project into native machine code.
 Cython can natively access data in NumPy arrays.
\end_layout

\begin_layout Standard

\series bold
NumPy is single-threaded
\series default
 by design, for process-based parallelization
\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)
\end_layout

\end_inset

.
 However, it uses BLAS for implementing things such as 
\family typewriter
np.dot()
\family default
, so a parallel BLAS makes NumPy parallel.
 For easy multi-threaded evaluation of NumPy expressions, see Numexpr.
 For more control of parallelization, see advanced topics at the end of
 these notes.
\end_layout

\begin_layout Standard

\series bold
Python uses 0-based indexing
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing
\end_layout

\end_inset

 everywhere, including NumPy.
 
\series bold
NumPy uses C storage order by default
\series default
 — i.e., for contiguous memory access, the 
\emph on
last
\emph default
 index changes the fastest — unless you explicitly request otherwise.
 Contrast MATLAB and Fortran, which use 1-based indexing and Fortran storage
 order (the first index changes the fastest).
\end_layout

\begin_layout Standard
In Python, the 
\series bold
indexing operator
\series default
 is 
\family typewriter
[]
\family default
; e.g.
 
\family typewriter
A[1,3]
\family default
.
 The 
\family typewriter
()
\family default
 operator denotes a function call; e.g.
 
\family typewriter
A(1,3)
\family default
 calls the function 
\begin_inset Quotes eld
\end_inset


\family typewriter
A
\family default

\begin_inset Quotes erd
\end_inset

 with the given argument values.
\end_layout

\begin_layout Standard
In NumPy, you can specifically request Fortran storage order by setting
 the optional keyword argument 
\family typewriter
order
\family default
 to 
\family typewriter
'F'
\family default
, i.e.
 
\family typewriter
order='F'
\family default
.
 This is accepted by many functions that create new arrays.
 Note that this does not affect your indexing, but only the 
\emph on
internal memory layout
\emph default
 of the array; e.g.
 in a 2D array, the first index always refers to the row, regardless of
 storage format.
 The 
\family typewriter
order
\family default
 argument is especially useful with 
\family typewriter
scipy.cython_lapack
\family default
.
 In general, the main use case for 
\family typewriter
order='F'
\family default
 is interfacing with low-level external libraries that expect Fortran arrays;
 almost all of the time, there is no need to touch this.
\end_layout

\begin_layout Standard

\series bold
Array slicing
\begin_inset Index idx
status open

\begin_layout Plain Layout
Slicing
\end_layout

\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Array slicing
\end_layout

\end_inset

 in Python is 
\family typewriter
start:end:step
\family default
, where 
\family typewriter
end
\family default
 is non-inclusive; contrast MATLAB's 
\family typewriter
start:step:stop
\family default
.
 In Python, negative indices
\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing!negative numbers in
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Negative numbers in indexing
\end_layout

\end_inset

 index from the end of the array (
\begin_inset Formula $-1$
\end_inset

 = last element).
 If omitted, start defaults to beginning, stop to one-past-end, and step
 to 1.
\end_layout

\begin_layout Standard
Unlike MATLAB, in Python the slice syntax can only be used within the indexing
 operator 
\family typewriter
[]
\family default
.
 In NumPy, see 
\family typewriter
np.linspace()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
linspace() (NumPy)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
np.linspace()
\end_layout

\end_inset

 and 
\family typewriter
np.arange()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
arange() (NumPy)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
np.arange()
\end_layout

\end_inset

 for the other common use case of slicing for MATLAB-ists.
 NumPy also provides an indexable dummy object 
\family typewriter
np.r_
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
np.r_[] (slice to array)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
r_[] (NumPy slice to array)
\end_layout

\end_inset

 that generates 1D arrays from slice syntax à la MATLAB, but the other options
 usually look more readable.
\end_layout

\begin_layout Standard
Examples of slicing:
\end_layout

\begin_layout Itemize
From the second element onward: 
\family typewriter
A[1:]
\end_layout

\begin_layout Itemize
Up to but not including the last element: 
\family typewriter
A[:-1]
\end_layout

\begin_layout Itemize
Every other element, starting from the fifth element: 
\family typewriter
A[4::2]
\end_layout

\begin_layout Itemize
All elements
\begin_inset Index idx
status open

\begin_layout Plain Layout
: (slicing, indexing)
\end_layout

\end_inset

: 
\family typewriter
A[:]
\end_layout

\begin_deeper
\begin_layout Itemize
Main use case:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

A[:] = B
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

 forces a write into array 
\family typewriter
A
\family default
, whereas 
\family typewriter
A = B
\family default
 overwrites the 
\emph on
name
\emph default
 
\family typewriter
A
\family default
, pointing it to the same object as 
\family typewriter
B
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
All elements in reverse order: 
\family typewriter
A[::-1]
\end_layout

\begin_deeper
\begin_layout Itemize
Here the default start and stop take into account the negative step.
\end_layout

\end_deeper
\begin_layout Standard
In NumPy, the magic index 
\family typewriter
...
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Ellipsis (...)!slicing, indexing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
...
 (Ellipsis)!slicing, indexing
\end_layout

\end_inset

 (literally, three dots; 
\family typewriter
Ellipsis
\family default
) means 
\emph on
insert as many 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 here as necessary
\emph default
.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/118370/how-do-you-use-the-ellipsis-slicing-syntax-in-python"

\end_inset


\end_layout

\begin_layout Standard
Or, in other words:
\end_layout

\begin_layout Standard

\emph on
The dots (
\family typewriter
...
\family default
) represent as many colons as needed to produce a complete indexing tuple.
 For example, if x is a rank 5 array (i.e., it has 5 axes), then
\end_layout

\begin_layout Itemize

\family typewriter
x[1,2,...]
\family default
 
\emph on
is equivalent to
\emph default
 
\family typewriter
x[1,2,:,:,:]
\family default
,
\end_layout

\begin_layout Itemize

\family typewriter
x[...,3]
\family default
 
\emph on
to
\emph default
 
\family typewriter
x[:,:,:,:,3]
\family default
 
\emph on
and
\end_layout

\begin_layout Itemize

\family typewriter
x[4,...,5,:]
\family default
 
\emph on
to
\emph default
 
\family typewriter
x[4,:,:,5,:]
\family default
.
 
\end_layout

\begin_layout Standard

\family sans
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip -0.3cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://scipy.github.io/old-wiki/pages/Tentative_NumPy_Tutorial#Indexing.2C_Slicing_and_Iterating"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\begin_inset Index idx
status open

\begin_layout Plain Layout
Linear equation systems
\end_layout

\end_inset

Linear equation systems
\series default
 are solved by 
\family typewriter
x = np.linalg.solve(A, b)
\family default
.
 This is an explicit function call to a library, like in Fortran; but the
 objects 
\family typewriter
A
\family default
 and 
\family typewriter
b
\family default
 themselves keep track of their size metadata, like in MATLAB.
 For sparse systems, use 
\family typewriter
x = scipy.sparse.linalg.spsolve(A, b)
\family default
, or 
\family typewriter
x = sparseqr.solve(A, b)
\family default
 if you use 
\family typewriter
sparseqr
\family default
.
\end_layout

\begin_layout Standard
The 
\series bold
rank
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!array!rank, in the sense of linear algebra
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Rank!array, in the sense of linear algebra
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Matrix rank
\end_layout

\end_inset


\series bold
 of a matrix
\series default
, in the sense of linear algebra, is obtained by 
\family typewriter
np.linalg.matrix_rank(A)
\family default
.
 The function 
\family typewriter
np.rank(A)
\family default
 returns the 
\emph on
array rank
\emph default
 (tensor rank), which is the number of array dimensions
\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!array!rank, in the sense of tensors
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Rank!array, in the sense of tensors
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Array rank (number of dimensions)
\end_layout

\end_inset

 (number of indices).
\end_layout

\begin_layout Standard
It is possible to use Python procedurally, in a manner similar to MATLAB
 scripts.
 However, 
\series bold
Python is object-oriented
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Object-oriented programming
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!object-oriented
\end_layout

\end_inset

.
 Often, object instances will have a method that does the same thing as
 some procedural call, e.g.
 
\family typewriter
np.dot(u, v)
\family default
 is equivalent to 
\family typewriter
u.dot(v)
\family default
, and in Python
\begin_inset space ~
\end_inset

3.5 and later, also to 
\family typewriter
u @ v
\family default
 (this will internally translate to 
\family typewriter
u.matmul(v)
\family default
).
\end_layout

\begin_layout Standard
Sometimes this matters; for example, in sparse matrix multiplication, the
 
\family typewriter
dot()
\family default
 method of the object instance gives much better performance than 
\family typewriter
np.dot()
\family default
, because the latter is designed for dense matrices.
\end_layout

\begin_layout Standard

\series bold
Arrays are created explicitly
\series default
 (examples below).
 Beside the usual options, NumPy provides also an option to create an 
\emph on
empty
\emph default
 array, where the contents will be uninitialized.
 This is useful, if you are going to immediately write into all elements
 anyway, because then no time is wasted initially filling the array with
 values (e.g.
 zeroes or ones) that will never be used.
\end_layout

\begin_layout Standard
The most commonly used 
\series bold
data types
\begin_inset Index idx
status open

\begin_layout Plain Layout
Data types (dtypes)
\end_layout

\end_inset


\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dtypes (data types)
\end_layout

\end_inset

 (
\family typewriter
dtype
\family default
s) for NumPy arrays are 
\family typewriter
np.float64
\family default
 (
\begin_inset Index idx
status open

\begin_layout Plain Layout
IEEE-754 floating point
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Floating point number, IEEE-754
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Number!floating point, IEEE-754
\end_layout

\end_inset

IEEE-754 double; C: double; Fortran: DOUBLE PRECISION i.e.
 REAL*8) and 
\family typewriter
np.complex128
\family default
 (C: double complex; Fortran: COMPLEX*16).
 These are the same as the default real and complex types in MATLAB.
\end_layout

\begin_layout Standard
For boolean arrays, set dtype to 
\family typewriter
bool
\family default
.
 For integer arrays, to be explicit about the integer size, use 
\family typewriter
np.int32
\family default
 and 
\family typewriter
np.int64
\family default
.
 As of this writing: the dtype 
\family typewriter
np.intc
\family default
 is an alias for 
\family typewriter
np.int32
\family default
.
 Trying to set the dtype of an array to 
\family typewriter
int
\family default
 (which, strictly speaking, represents 
\emph on
Python's
\emph default
 integer type), actually sets the dtype to 
\family typewriter
np.int64
\family default
.
\end_layout

\begin_layout Standard
Once you get some experience with NumPy, you may also want to know about
 
\series bold
broadcasting rules
\begin_inset Index idx
status open

\begin_layout Plain Layout
Broadcasting rules (array operations)
\end_layout

\end_inset


\series default
 for array shapes:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html"

\end_inset


\end_layout

\begin_layout Standard
These rules govern which array shapes (beside exactly matching ones) are
 compatible to be used in the same elementwise operation, and what exactly
 NumPy does in the nontrivial cases.
 It's a pretty short read.
\end_layout

\begin_layout Standard
There is also another (rather old) document on this, with pictures:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc"

\end_inset


\end_layout

\begin_layout Standard
Also, note that there are ready-made functions for common indexing tricks
\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing!tricks for NumPy
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
np.ravel() (meshgrid indexing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
ravel() (NumPy, meshgrid indexing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
np.unravel() (meshgrid indexing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
unravel() (NumPy, meshgrid indexing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Meshgrid indexing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing!meshgrids
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
np.ix_() (subarray indexing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
ix_() (NumPy, subarray indexing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Subarray indexing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing!subarrays
\end_layout

\end_inset

, especially 
\family typewriter
np.ravel()
\family default
 and 
\family typewriter
np.unravel()
\family default
 for meshgrids, and 
\family typewriter
np.ix_()
\family default
 for MATLAB-style subarrays given index vectors along each dimension.
\end_layout

\begin_layout Standard
Examples:
\begin_inset Index idx
status open

\begin_layout Plain Layout
Singleton!length-1 dimension in array (NumPy)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing!by vectors
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# empty: uninitialized memory
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# size:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# 1D: (n,)
\end_layout

\begin_layout Plain Layout

# 2D: (m, n): rows, cols
\end_layout

\begin_layout Plain Layout

# 3D: (k, m, n)
\end_layout

\begin_layout Plain Layout

# ...
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

A = np.empty((5,5), dtype=np.float64)
\end_layout

\begin_layout Plain Layout

A[:,:] = 3  # fill the whole array with threes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# array filled with zeroes
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

B = np.zeros((5,5), dtype=np.float64)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# array filled with ones
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

C = np.ones((5,5), dtype=np.float64)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# array initialized from Python lists
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

M = np.array( [ [1, 2, 3],
\end_layout

\begin_layout Plain Layout

                [4, 5, 6],
\end_layout

\begin_layout Plain Layout

                [7, 8, 9] ], dtype=np.float64 )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# to convert the other way, NumPy array to Python list:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

N = M.tolist()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# can also initialize a NumPy array from an existing NumPy array
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

K = np.array( M )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# the same, maybe more readable
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

L = M.copy()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# DANGER: this makes just an alias for the same object instance
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

V = M
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# linear view into M (a.k.a.
 linearly indexed view, one-subscript view)
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# "view" means that writing into W will write into M
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

W = M.reshape(-1)  # -1 = count number of elements automatically
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# arange is sometimes useful: like range(), but creates 1D np.array
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

R = np.arange(9)  # [0,1,2,3,4,5,6,7,8]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# this is valid, because the input is a scalar
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

M[:] = 4  # fill M with fours
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# but this is an error due to shape mismatch:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

M[:] = R  # ValueError!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# solution a), use the linear view:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

W[:] = R  # OK!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# solution b), reshape the input:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

M[:,:] = np.reshape(R, M.shape)  # OK!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# inserting/suppressing "singleton dimensions" (see NumPy documentation)
\end_layout

\begin_layout Plain Layout

# to unify indexing in code that must support both NumPy arrays and scalars:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

P = np.atleast_1d( 42.0 )  # --> 1D array of one element
\end_layout

\begin_layout Plain Layout

p = np.squeeze(P)          # --> back to scalar
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# multidimensional indexing to get a subarray: difference to MATLAB:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

I = np.array( (0,1,2), dtype=int )  # rows
\end_layout

\begin_layout Plain Layout

J = np.array( (1,2), dtype=int )    # columns
\end_layout

\begin_layout Plain Layout

M[I,J]          # IndexError!
\end_layout

\begin_layout Plain Layout

M[np.ix_(I,J)]  # OK! (array containing columns 1,2 from rows 0,1,2 of M,
\end_layout

\begin_layout Plain Layout

                #      like MATLAB's M(I,J))
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# indexing a multidimensional array by vectors means something different
 in NumPy:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# M[I[0],J[0]], M[I[1],J[1]], ...
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

I = np.array( (0,2), dtype=int )  # rows
\end_layout

\begin_layout Plain Layout

J = np.array( (1,2), dtype=int )  # columns
\end_layout

\begin_layout Plain Layout

M[I,J]  # OK! -->[ M[0,1], M[2,2] ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# identity matrix
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# note: no shape tuple, always 2D and square, so just the size
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

I = np.eye(5, dtype=np.float64)  # size 5x5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# diagonal matrix
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

D = np.diag( np.arange(10) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# tridiagonal matrix (from the 1D laplacian)
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

n = 10
\end_layout

\begin_layout Plain Layout

d = -2 * np.ones( (n,), dtype=np.float64 )
\end_layout

\begin_layout Plain Layout

s = np.ones( (n-1,),  dtype=np.float64 )
\end_layout

\begin_layout Plain Layout

d = np.diag(d)      # main diagonal
\end_layout

\begin_layout Plain Layout

u = np.diag(s, +1)  # upper subdiagonal
\end_layout

\begin_layout Plain Layout

l = np.diag(s, -1)  # lower subdiagonal
\end_layout

\begin_layout Plain Layout

T = l + d + u       # summing arrays elementwise
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# sparse matrix
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# (dr[k],dc[k],data[k]) is the kth nonzero matrix element.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

import scipy.sparse
\end_layout

\begin_layout Plain Layout

dr   = (0, 1, 4)  # row
\end_layout

\begin_layout Plain Layout

dc   = (3, 2, 4)  # column
\end_layout

\begin_layout Plain Layout

data = (1, 2, 3)
\end_layout

\begin_layout Plain Layout

S = scipy.sparse.coo_matrix( (data, (dr,dc)), shape=(5,5), dtype=np.float64
 )
\end_layout

\begin_layout Plain Layout

S = S.tocsr()
\end_layout

\begin_layout Plain Layout

print(type(S))  # it's now a scipy.sparse.csr.csr_matrix
\end_layout

\begin_layout Plain Layout

print(S)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Linear algebra at the bazaar
\end_layout

\begin_layout Standard
Sometimes, you may notice that at first glance, an identical routine exists
 in both NumPy and SciPy.
 Historically, this has indicated that they have been developed independently,
 and either one could be better; either for your particular application,
 or possibly just strictly better, depending on the library versions.
\end_layout

\begin_layout Standard
However, recently there has been a push toward NumPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy
\end_layout

\end_inset

 to provide a "basic" routine, and SciPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
SciPy
\end_layout

\end_inset

 an "advanced" one.
 From the SciPy tutorial, 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html"

\end_inset


\family default
:
\end_layout

\begin_layout Standard

\emph on
scipy.linalg contains all the functions in numpy.linalg, plus some other more
 advanced ones not contained in numpy.linalg.
\end_layout

\begin_layout Standard

\emph on
Another advantage of using scipy.linalg over numpy.linalg is that it is always
 compiled with BLAS/LAPACK support, while for numpy this is optional.
\end_layout

\begin_layout Standard

\emph on
Therefore, the scipy version might be faster depending on how numpy was
 installed.
\end_layout

\begin_layout Standard

\emph on
Therefore, unless you don’t want to add scipy as a dependency to your numpy
 program, use scipy.linalg instead of numpy.linalg.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Let's look at some examples.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Least-squares solvers
\series default
, 
\family typewriter
numpy.linalg.lstsq()
\family default
 vs.
 
\family typewriter
scipy.linalg.lstsq()
\family default
.
\end_layout

\begin_layout Itemize
NumPy dispatches to LAPACK
\begin_inset Index idx
status open

\begin_layout Plain Layout
LAPACK (Linear Algebra PACKage)
\end_layout

\end_inset

's *GELSD.
\end_layout

\begin_layout Itemize
Historically, SciPy used to dispatch to *GELSS, but as of August 2017, the
 driver has been made switchable (in SciPy 0.17.0), and now uses *GELSD by
 default.
\end_layout

\begin_layout Itemize
*GELSD is (much) faster, but uses more memory, when compared to *GELSS.
\end_layout

\begin_layout Itemize
*GELSY is also available via SciPy; may be slightly faster than *GELSD.
\end_layout

\begin_layout Standard
The conclusion is that:
\end_layout

\begin_layout Itemize
NumPy used to be much faster, but used more memory.
\end_layout

\begin_layout Itemize
Now both use the same driver (NumPy always, SciPy by default).
\end_layout

\begin_layout Itemize
SciPy now also allows switching the driver, so it offers the same performance
 by default, but is also more flexible; it is the 
\begin_inset Quotes eld
\end_inset

advanced
\begin_inset Quotes erd
\end_inset

 routine, while NumPy's is a 
\begin_inset Quotes eld
\end_inset

basic
\begin_inset Quotes erd
\end_inset

 one.
\end_layout

\begin_layout Itemize
See:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/29372559/what-is-the-difference-between-numpy-linalg-lstsq-and-scipy-linalg-lstsq"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Linear equation system solvers
\series default
, 
\family typewriter
numpy.linalg.solve()
\family default
 vs.
 
\family typewriter
scipy.linalg.solve()
\family default
.
\end_layout

\begin_layout Itemize
NumPy always dispatches to LAPACK's *GESV.
\end_layout

\begin_layout Itemize
SciPy has an option to specify that the matrix 
\family typewriter
A
\family default
 is generic, symmetric, hermitian or positive-definite; dispatching to *GESVX,
 *SYSVX, *HESVX and *POSVX, respectively.
\end_layout

\begin_deeper
\begin_layout Itemize
As was mentioned, NumPy arrays are always generic (e.g.
 no special type for symmetric matrices).
 Testing a general dense data array for symmetricity is expensive, hence
 the use of an explicit option.
\end_layout

\begin_layout Itemize
The *X version also provides some error analysis, the "X" stands for "expert".
\end_layout

\end_deeper
\begin_layout Itemize
Here too, SciPy provides an advanced routine, NumPy a basic one.
\end_layout

\begin_layout Itemize
See:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://source.ggy.bris.ac.uk/wiki/LinAlgebraPacks"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://scicomp.stackexchange.com/questions/10980/can-numpy-linalg-solve-use-back-substitution-when-possible"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\series bold
Eigenvalue solvers
\series default
, 
\family typewriter
numpy.linalg.eig()
\family default
 vs.
 
\family typewriter
scipy.linalg.eig()
\family default
.
\end_layout

\begin_layout Itemize
NumPy solves the standard linear eigenvalue problem 
\begin_inset Formula $\boldsymbol{A}\boldsymbol{x}=\lambda\boldsymbol{x}$
\end_inset

, using LAPACK's *GEEV.
\end_layout

\begin_layout Itemize
SciPy solves either the standard 
\series bold
or the generalized
\series default
 linear eigenvalue problem 
\begin_inset Formula $\boldsymbol{A}\boldsymbol{x}=\lambda\boldsymbol{B}\boldsymbol{x}$
\end_inset

.
\end_layout

\begin_layout Itemize
See:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Understanding Python
\begin_inset CommandInset label
LatexCommand label
name "sec:Understanding-Python"

\end_inset


\end_layout

\begin_layout Standard
Now, let's delve into Python.
 This section provides an overview, mainly from a rather basic theoretical
 viewpoint.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The target audience is everyone who has programmed in a language other than
 Python, and especially scientists who program, but whose background is
 not in computer science.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The big-picture overview
\end_layout

\begin_layout Standard
Let us start by asking: 
\series bold
What kind of programming language is Python?
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!philosophy
\end_layout

\end_inset

The guiding principles of Python's design are embodied in the 20 one-line
 aphorisms — of which 19 have been written down — of 
\emph on
The Zen of Python
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Zen of Python, The
\end_layout

\end_inset

, by Tim Peters:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0020/"

\end_inset


\end_layout

\begin_layout Standard
In its entirety, the text reads:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Beautiful is better than ugly.
\end_layout

\begin_layout Standard
Explicit is better than implicit.
\end_layout

\begin_layout Standard
Simple is better than complex.
\end_layout

\begin_layout Standard
Complex is better than complicated.
\end_layout

\begin_layout Standard
Flat is better than nested.
\end_layout

\begin_layout Standard
Sparse is better than dense.
\end_layout

\begin_layout Standard
Readability counts.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Readability
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Special cases aren't special enough to break the rules.
\end_layout

\begin_layout Standard
Although practicality beats purity.
\end_layout

\begin_layout Standard
Errors should never pass silently.
\end_layout

\begin_layout Standard
Unless explicitly silenced.
\end_layout

\begin_layout Standard
In the face of ambiguity, refuse the temptation to guess.
\end_layout

\begin_layout Standard
There should be one— and preferably only one —obvious way to do it.
\end_layout

\begin_layout Standard
Although that way may not be obvious at first unless you're Dutch.
\end_layout

\begin_layout Standard
Now is better than never.
\end_layout

\begin_layout Standard
Although never is often better than 
\emph on
right
\emph default
 now.
\end_layout

\begin_layout Standard
If the implementation is hard to explain, it's a bad idea.
\end_layout

\begin_layout Standard
If the implementation is easy to explain, it may be a good idea.
\end_layout

\begin_layout Standard
Namespaces are one honking great idea — let's do more of those!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The text is also available as an easter egg in Python itself (
\family typewriter
import this
\family default
).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
In a more concrete sense, condensed into a list of bullet points, Python
 is:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}[itemsep=-0.1cm]
\end_layout

\begin_layout Plain Layout

    
\backslash
item Imperative
\backslash
index{Imperative programming (paradigm)}
\end_layout

\begin_layout Plain Layout

    
\backslash
item Interpreted
\backslash
index{Interpreted language}
\end_layout

\begin_layout Plain Layout

    
\backslash
item Object-oriented
\backslash
index{Object-oriented programming}
\backslash
index{Programming!object-oriented}
\end_layout

\begin_layout Plain Layout

    
\backslash
item Lexically scoped
\backslash
index{Lexical scoping}
\backslash
index{Scoping!lexical (static)}
\end_layout

\begin_layout Plain Layout

    
\backslash
item Duck-typed
\backslash
index{Duck typing}
\end_layout

\begin_layout Plain Layout

    
\backslash
item Call by sharing (call by object)
\backslash
index{Call by!sharing (object)}
\end_layout

\begin_layout Plain Layout

    
\backslash
item Reflective
\backslash
index{Reflection (programming)}
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's now go through each of these in detail:
\end_layout

\begin_layout Enumerate

\series bold
\emph on
Imperative
\series default
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Imperative programming (paradigm)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!paradigm!imperative
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!paradigm
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Paradigms (programming)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Or to borrow a physics term, classical.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

C, C++
\begin_inset Index idx
status open

\begin_layout Plain Layout
C++
\end_layout

\end_inset

, Fortran
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

, Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

, MATLAB
\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset

 are also imperative languages.
 Imperative programs consist of an explicit sequence of elementary steps
 for the computer to perform.
\end_layout

\begin_layout Itemize
Contrast 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Declarative programming (paradigm)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!paradigm!declarative
\end_layout

\end_inset


\emph on
declarative programming
\emph default
 (Prolog
\begin_inset Index idx
status open

\begin_layout Plain Layout
Prolog (declarative programming language)
\end_layout

\end_inset

), and its subcategory 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Functional programming!paradigm
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!paradigm!functional
\end_layout

\end_inset


\emph on
functional programming
\emph default
 (Haskell
\begin_inset Index idx
status open

\begin_layout Plain Layout
Haskell (functional programming language)
\end_layout

\end_inset

, Scheme
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scheme (functional programming language)
\end_layout

\end_inset

)
\begin_inset Note Note
status open

\begin_layout Plain Layout
; 
\emph on
data-driven programming
\emph default
 (sed, AWK)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Data-driven programming (paradigm)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!paradigm!data-driven
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Programming_paradigm"

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Imperative_programming"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Peter van Roy: Programming Paradigms for Dummies: What Every Programmer
 Should Know:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf"

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\emph on
Interpreted
\series default
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Interpreted language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!language!interpreted
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Language!interpreted
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Contrast 
\emph on
compiled
\emph default
, such as C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

 and Fortran
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Compiled language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!language!compiled
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Language!compiled
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Although strictly speaking, Python is a mix of both: at load time, Python
 source is compiled to 
\emph on
bytecode
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Bytecode
\end_layout

\end_inset

, which runs on the Python 
\emph on
virtual machine
\emph default
 (VM)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Virtual!machine (VM)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
VM (virtual machine)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!virtual machine (VM)
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
This kind of hybrid design is common in many modern interpreted languages
 (also Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

).
\end_layout

\end_deeper
\begin_layout Itemize
This is not as slow as it may at first sound.
 The VM runs pretty fast, and compiled bytecode is kept on disk, to avoid
 unnecessary re-compiling if the source code has not changed.
 Libraries ship with their bytecode pre-compiled.
\end_layout

\begin_layout Itemize
Compiled bytecode can be 
\emph on
disassembled
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Disassembly (bytecode)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Bytecode!disassembly
\end_layout

\end_inset

 for inspection, which advanced users may occasionally find useful.
 (I've needed this feature exactly once — actually, while preparing these
 notes.)
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Interpreted_language"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Compiled_language"

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\emph on
Object-oriented
\series default
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Object-oriented programming!paradigm
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!paradigm!object-oriented
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Procedural programming (paradigm)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!paradigm!procedural
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Everything is an object (yes, also functions)
\end_layout

\begin_deeper
\begin_layout Itemize
Even 
\emph on
types of objects
\emph default
 are objects
\end_layout

\end_deeper
\begin_layout Itemize
Technically, at the top of the class hierarchy, everything 
\emph on
inherits from
\emph default
 
\family typewriter
object
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
object (default base class)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Nowadays (Python
\begin_inset space ~
\end_inset

3) this is implicit when you define a class, and don't explicitly inherit
 it from something else (e.g.
 from one of your own classes).
\end_layout

\begin_layout Itemize
When reading legacy codes (Python
\begin_inset space ~
\end_inset

2), and discussions on Python, keep in mind that in legacy versions, inheritance
 from 
\family typewriter
object
\family default
 had to be specified manually.
 Classes inheriting from 
\family typewriter
object
\family default
 used to be called 
\emph on
new-style classes
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
New-style classes (legacy term)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
class!new-style (legacy term)
\end_layout

\end_inset

, to distinguish them from 
\begin_inset Quotes eld
\end_inset

old-style classes
\begin_inset Index idx
status open

\begin_layout Plain Layout
Old-style classes (legacy term)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
class!old-style (legacy term)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 that didn't.
\end_layout

\end_deeper
\begin_layout Itemize
Python supports 
\emph on
multiple inheritance
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiple!inheritance
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Inheritance, multiple
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Python has no 
\family typewriter
struct
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
struct
\end_layout

\end_inset

, by design.
 To create a data structure with named fields, make a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
class
\end_layout

\end_inset

class.
\end_layout

\begin_deeper
\begin_layout Itemize
Classes can be defined anywhere, also inside functions.
\end_layout

\end_deeper
\begin_layout Itemize
Python is not as strict about object-oriented programming as e.g.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

Java, where you cannot even have a 
\family typewriter
main()
\family default
 function
\begin_inset Index idx
status open

\begin_layout Plain Layout
main() function
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function, main()
\end_layout

\end_inset

 (where program execution starts) without placing it inside a class.
 
\emph on
Practicality beats purity.
\end_layout

\begin_layout Itemize
Contrast 
\emph on
procedural
\emph default
; although Python supports that, too.
\end_layout

\begin_deeper
\begin_layout Itemize
Python is not as strict about the conventions there, either.
 In Python, just like in MATLAB, you don't even 
\emph on
need
\emph default
 a 
\family typewriter
main()
\family default
 function unless you 
\emph on
want
\emph default
 to have one.
 If all you need is a short script, feel free to write just the commands;
 that is valid Python, too.
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Object-oriented_programming"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Procedural_programming"

\end_inset


\family default

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\emph on
Lexically scoped
\series default
\emph default
 (a.k.a.
 
\emph on
statically scoped
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Static!scoping (lexical scoping)
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
Scoping!static (lexical)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Lexical (static) scoping
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Scoping!lexical (static)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Just like the C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

 language.
 Contrast 
\emph on
dynamically scoped
\emph default
.
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping_vs._dynamic_scoping"

\end_inset


\family default

\begin_inset Note Note
status open

\begin_layout Plain Layout
This is important.
 Since not many mainstream languages are dynamically scoped, let's be explicit.
 The linked Wikipedia page says (emphasis mine):
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm 
\end_layout

\end_inset

In 
\series bold
lexical
\series default
 scoping, if a variable name's scope is a certain function, then its scope
 is 
\series bold
the program text of the function definition
\series default
: within that text, the variable name exists, and is bound to the variable's
 value, but outside that text, the variable name does not exist.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm 
\end_layout

\end_inset

By contrast, in 
\series bold
dynamic
\series default
 scoping, if a variable name's scope is a certain function, then its scope
 is 
\series bold
the time-period during which the function is executing
\series default
: while the function is running, the variable name exists, and is bound
 to its value, but after the function returns, the variable name does not
 exist.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm 
\end_layout

\end_inset


\emph default
It is easy to see that this has implications as to which names exist during
 a function call.
 Consider a piece of a program calling a function that is defined somewhere
 else in the program, and refer to the above definitions.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The smallest unit of scope in Python is the function.
\end_layout

\begin_deeper
\begin_layout Itemize
Unlike in C, a 
\family typewriter
for
\family default
 loop
\begin_inset Index idx
status open

\begin_layout Plain Layout
for loop!scope of in Python
\end_layout

\end_inset

 does 
\emph on
not
\emph default
 have its own internal scope.
 The loop counter will overwrite the same name in the surrounding scope!
\end_layout

\begin_layout Itemize
Further reading by Eli Bendersky (advanced)
\family sans
: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://eli.thegreenplace.net/2015/the-scope-of-index-variables-in-pythons-for-loops/"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
\emph on

\begin_inset Quotes erd
\end_inset

In this writeup I want to explore why this is so, why it's unlikely to change,
 and also use it as a tracer bullet to dig into some interesting parts of
 the CPython compiler.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
In Python 3, 
\emph on
list comprehensions
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset

 do not 
\begin_inset Quotes eld
\end_inset

leak
\begin_inset Quotes erd
\end_inset

 their loop counter this way.
 Example, as a 
\family typewriter
for
\family default
 loop:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

i = 100
\end_layout

\begin_layout Plain Layout

L = []
\end_layout

\begin_layout Plain Layout

for i in range(5):
\end_layout

\begin_layout Plain Layout

    L.append(i)
\end_layout

\begin_layout Plain Layout

print(i)  # 4
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
The same example, using a list comprehension:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

i = 100
\end_layout

\begin_layout Plain Layout

L = [i for i in range(5)]
\end_layout

\begin_layout Plain Layout

print(i)  # 100
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Name lookup starts from the current innermost scope, and proceeds outward
 in the surrounding scopes until a match is found.
 If the name does not exist anywhere in the current hierarchy of scopes,
 
\family typewriter
NameError
\family default
 is raised.
\end_layout

\begin_deeper
\begin_layout Itemize
To be technically accurate, the hierarchy is the 
\emph on
scope
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Scope
\end_layout

\end_inset

, and its parts are 
\emph on
namespaces
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Namespace
\end_layout

\end_inset

, but often these terms are used interchangeably even in textbooks.
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://softwareengineering.stackexchange.com/a/273507"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
LEGB rule (scoping)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Scoping!LEGB rule
\end_layout

\end_inset

LEGB rule: 
\series bold
L
\series default
ocal, 
\series bold
E
\series default
nclosing, 
\series bold
G
\series default
lobal, 
\series bold
B
\series default
uilt-in.
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/292502"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Sebastian Raschka: A Beginner's Guide to Python's Namespaces, Scope Resolution,
 and the LEGB Rule:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
(Otherwise very informative, but contains a small mistake in the introduction:
 
\family typewriter
for
\family default
 loops do not create their own namespace — as the author himself notes in
 the warning at the very end.) 
\family sans

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
\emph on
Duck-typed
\series default
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Duck typing
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Definition:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
"If it walks like a duck and it quacks like a duck, then it must be a duck.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Any object may be used in any context, up until it is used in a way that
 it does not support.
\end_layout

\begin_deeper
\begin_layout Itemize
Validity of a particular usage is 
\emph on
only discovered at run time
\emph default
 (contrast 
\emph on
compile time
\emph default
).
 This is one kind of 
\emph on
dynamic type checking
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Dynamic type checking
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!checking, dynamic
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Duck_typing"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\emph on
No variables!
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Variable
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Names (variables in Python)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Types are attached to 
\emph on
values
\emph default
 (i.e.
 
\emph on
object instances
\emph default
), which are referred to by untyped 
\emph on
names.
\end_layout

\begin_layout Itemize

\emph on
Names
\emph default
 are just labels.
 At any time, a name can be reassigned to point to a different object instance,
 of any type.
\end_layout

\begin_layout Itemize
Contrast C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

, where variables have a type, and accept only values of that type.
\end_layout

\begin_layout Itemize
Sometimes terminology is used loosely, and names are called 
\begin_inset Quotes eld
\end_inset

variables
\begin_inset Quotes erd
\end_inset

.
 This can lead to confusion, as these concepts imply different behavior.
\end_layout

\begin_layout Itemize
A good (beginner to intermediate) reference is:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\emph on
Ned Batchelder: Facts and myths about Python names and values
\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://nedbatchelder.com/text/names.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Sometimes it is said that Python is both 
\emph on
dynamically typed
\emph default
 and 
\emph on
strongly typed
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Dynamically typed language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Strongly typed language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Weakly typed language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Dynamic type checking
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!checking, dynamic
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Static!type checking
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!checking, static
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!system (programming)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Dynamically typed
\emph default
: long story short, from 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Type_system"

\end_inset


\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\emph on
The main purpose of a type system is to reduce possibilities for bugs in
 computer programs by defining interfaces between different parts of a computer
 program, and then checking that the parts have been connected in a consistent
 way.
 This checking can happen 
\series bold
statically
\series default
 (at compile time), 
\series bold
dynamically
\series default
 (at run time), or as a combination of static and dynamic checking.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

[...]
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Programming languages that 
\series bold
include dynamic type checking but not static type checking
\series default
 are often called "
\series bold
dynamically typed
\series default
 programming languages".
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Strongly typed
\emph default
: there is no consensus on an exact definition, but often the use of the
 term implies things such as 
\begin_inset Quotes eld
\end_inset

no implicit type conversion
\begin_inset Quotes erd
\end_inset

.
 This means that for example, a string containing only digits does not automatic
ally become a number (unlike in Perl!).
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/11328980"

\end_inset


\family default
, StackOverflow user Fred Foo writes:
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset

The strength of the type system in a dynamic language such as Python is
 really determined by how its primitives and library functions respond to
 different types.
 E.g., 
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

 is overloaded so that it works on two numbers or two strings, but not a
 string and a number.
 This is a design choice made when 
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

 was implemented, but not really a necessity following from the language's
 semantics.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Static type checking is making some inroads:
\end_layout

\begin_deeper
\begin_layout Itemize
Type hints (3.5+)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!hint (annotation)
\end_layout

\end_inset


\family sans
:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0484/"

\end_inset


\end_layout

\begin_layout Itemize
Mypy
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mypy (static type checker)
\end_layout

\end_inset

, an experimental optional static type checker for Python
\family sans
:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://mypy-lang.org/"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Finally, see:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Strong_and_weak_typing"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/11328920/is-python-strongly-typed"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
name "https://wiki.python.org/moin/Why is Python a dynamic language and also a strongly typed language"
target "https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Type_system"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
\emph on
Call by sharing
\series default
\emph default
 (a.k.a.
 
\emph on
call by object
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Call by!sharing (object)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Here Python differs from many other languages.
\end_layout

\begin_layout Itemize
Contrast 
\emph on
call by value
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Call by!value
\end_layout

\end_inset

; 
\emph on
call by reference
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Call by!reference
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In 
\emph on
call by sharing
\emph default
, the caller and callee 
\emph on
share the same object instance
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Specifically in Python, at the callee's end, assigning to the same name
 that was passed in the call, just creates a new name in the local namespace,
 masking (hiding) the one that was passed in.
 Once the call returns, the local namespace is destroyed.
 Thus, such 
\begin_inset Quotes eld
\end_inset

changes by assignment
\begin_inset Quotes erd
\end_inset

 will not be reflected at the caller's end.
 This aspect behaves like 
\emph on
call by value
\emph default
.
\end_layout

\begin_layout Itemize
If the passed object instance is mutable, any changes made to it by the
 callee will be visible at the caller's end, because both access the same
 object instance.
 This behaves like 
\emph on
call by reference
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Useful essays:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://effbot.org/zone/python-objects.htm"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://effbot.org/zone/call-by-object.htm"

\end_inset


\end_layout

\begin_layout Itemize
Paul Graham: What made LISP
\begin_inset Index idx
status open

\begin_layout Plain Layout
LISP
\end_layout

\end_inset

 different
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://paulgraham.com/icad.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing"

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\emph on
Reflective
\series default
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Reflection (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Introspection (programming)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Almost anything can be modified, at any time.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Reflection_(computer_programming)"

\end_inset


\end_layout

\begin_layout Itemize
Python's extensive 
\emph on
introspection
\emph default
 facilities tie into this; it is possible to programmatically inspect things
 such as what attributes object instances or their classes have, or whether
 a given instance's class inherits from a given class.
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Introspection_(computer_science)"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.learnpython.org/en/Code_Introspection"

\end_inset


\end_layout

\begin_layout Itemize
Reflection allows 
\emph on
monkey patching
\emph default
 (a.k.a.
 
\emph on
duck punching
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Monkey patching (duck punching)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Duck punching (monkey patching)
\end_layout

\end_inset

, i.e.
 dynamic modifications to a program's own code while it is running.
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Monkey_patch"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
Much of this can be achieved using rather mild tools (
\family typewriter
setattr()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
setattr
\end_layout

\end_inset

 on class objects at most).
\end_layout

\begin_layout Itemize
For the ultimate power, see the built-in functions 
\family typewriter
compile()
\family default
, 
\family typewriter
eval()
\family default
, and 
\family typewriter
exec()
\family default
, which operate on source code provided (or generated) at run time.
\end_layout

\begin_deeper
\begin_layout Itemize
The symbolic computation package 
\begin_inset Index idx
status open

\begin_layout Plain Layout
SymPy
\end_layout

\end_inset

SymPy has 
\family typewriter
lambdify()
\family default
, which takes a SymPy expression and returns a compiled function that can
 be used with NumPy arrays.
\end_layout

\end_deeper
\begin_layout Itemize
There is also an 
\family typewriter
ast
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
AST (abstract syntax tree)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Abstract syntax tree (AST)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Syntax tree!abstract (AST)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
CST (concrete syntax tree)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concrete syntax tree (CST)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Syntax tree!concrete (CST)
\end_layout

\end_inset

 module in the standard library; Python can parse and analyze Python code.
\end_layout

\begin_deeper
\begin_layout Itemize
AST: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Abstract_syntax_tree"

\end_inset


\end_layout

\begin_layout Itemize
AST vs.
 CST: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
SymPy
\end_layout

\end_inset

SymPy builds on this, avoiding the need for a new mini-language, since the
 symbolic math expressions can be Python.
\end_layout

\begin_layout Itemize
The static function call dependency analyzer
\emph on
 pyan
\emph default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
pyan (static function call dependency analyzer)
\end_layout

\end_inset

also uses 
\family typewriter
ast
\family default
 to analyze the given source code.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/davidfraser/pyan/"

\end_inset


\end_layout

\begin_layout Itemize
In the context of packaging Python libraries, someone suggested using 
\family typewriter
ast
\family default
 to pull the version number from the actual source code of the software
 itself, thus ensuring the version of the package always matches what is
 actually inside.
 The principle behind this approach is known as Don't Repeat Yourself.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/12413800"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?DontRepeatYourself"

\end_inset


\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Don't Repeat Yourself (programming principle)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!principle!Don't Repeat Yourself
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The downside is that, in principle, the high reflectivity makes Python code
 impossible to reason about statically.
\end_layout

\begin_deeper
\begin_layout Itemize
However, in practice, this power is very rarely used to its full extent,
 so static code analyzers
\begin_inset Index idx
status open

\begin_layout Plain Layout
Static!code analysis
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Code analysis, static
\end_layout

\end_inset

 for Python do exist, and almost always give acceptable results.
 
\begin_inset Formula $\rightarrow$
\end_inset

 pyan, 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pyflakes (static code analyzer)
\end_layout

\end_inset

Pyflakes, Pylint
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pylint (static code analyzer)
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Some other features that bear pointing out are:
\end_layout

\begin_layout Itemize

\emph on
Automatic memory management
\emph default
 (a.k.a.
 
\emph on
garbage collection
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Garbage collection (memory management)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Memory management
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Automatic memory management
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
No need to destroy object instances explicitly.
\end_layout

\begin_layout Itemize
Similar to Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

, MATLAB
\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset

; contrast C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

, and 
\family typewriter
new
\family default
/
\family typewriter
delete
\family default
 of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
C++
\end_layout

\end_inset

C++.
\end_layout

\begin_layout Itemize
However, in the rare case where you 
\emph on
specifically want to
\emph default
 destroy an instance immediately (e.g.
 a multi-gigabyte array that you no longer need), use the 
\family typewriter
del
\family default
 keyword
\begin_inset Index idx
status open

\begin_layout Plain Layout
del keyword
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!del
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Deleting object instances
\end_layout

\end_inset

.
 (This destroys the 
\emph on
name
\emph default
; but if it was the last reference to the instance, the instance gets destroyed
 too.)
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\emph on
First-class functions
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
First-class functions
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Functions, first-class
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A function is just an object.
 It can be assigned to a name, returned as a return value, passed as an
 argument, and so on.
 Functions can be defined anywhere in the code (also inside other functions).
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/First-class_function"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Some 
\emph on
functional programming
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Functional programming
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!functional
\end_layout

\end_inset

 constructs
\end_layout

\begin_deeper
\begin_layout Itemize
Anonymous functions
\begin_inset Index idx
status open

\begin_layout Plain Layout
Anonymous function (lambda)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Lambda (anonymous function)
\end_layout

\end_inset

, keyword 
\family typewriter
lambda
\family default
 (after 
\emph on
lambda calculus
\emph default
), analogous to MATLAB's 
\family typewriter
@(x)
\family default
.
\end_layout

\begin_deeper
\begin_layout Itemize
For the curious
\begin_inset Index idx
status open

\begin_layout Plain Layout
Lambda calculus
\end_layout

\end_inset

: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Lambda_calculus"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
functools
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
functools (module)
\end_layout

\end_inset

 in the standard library
\end_layout

\begin_deeper
\begin_layout Itemize
Partial application (of function arguments)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Partial application (of function arguments)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Partial_application"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Special case: 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Currying (functional programming)
\end_layout

\end_inset

currying
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Currying"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
functools.reduce()
\family default
 can be occasionally useful.
\begin_inset Index idx
status open

\begin_layout Plain Layout
reduce (functional programming)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
reduce()
\family default
 is a 
\begin_inset Quotes eld
\end_inset

friend
\begin_inset Quotes erd
\end_inset

 of the built-ins 
\family typewriter
map()
\family default
 and 
\family typewriter
filter()
\family default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
map (functional programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
filter (functional programming)
\end_layout

\end_inset

 but in Python, 
\emph on
list comprehensions
\emph default
 and 
\emph on
generators
\emph default
 nowadays offer a much more readable alternative for most use cases of the
 latter two.
\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Generator
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
See also decorator 
\family typewriter
@functools.wraps
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Decorator!
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

functools.wraps
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Itemize
In makeindex, a literal @ sign must be escaped with 
\begin_inset Quotes eld
\end_inset

:
\begin_inset Newline newline
\end_inset

https://www.math.utah.edu/~beebe/talks/1998/idxtips.pdf
\end_layout

\begin_layout Itemize
LyX mangles the 
\begin_inset Quotes eld
\end_inset

, unless it is ERT'd (see the source view for the paragraph)
\end_layout

\end_inset

; occasionally useful.
 (Copies metadata, importantly the docstring
\begin_inset Index idx
status open

\begin_layout Plain Layout
docstring
\end_layout

\end_inset

, from the wrapped function to the wrapper.)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\emph on
No declaration of names
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Names (variables in Python)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Variable
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Assigning to a name creates it (in the current namespace) if it does not
 already exist.
\end_layout

\begin_layout Itemize
So, just like in MATLAB
\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset

, be sure to avoid typos on the LHS of assignment statements.
\end_layout

\begin_deeper
\begin_layout Itemize
Pretty much all other use cases involve looking up the undefined name, which
 will raise 
\family typewriter
NameError
\family default
.
\end_layout

\begin_layout Itemize
The only exception to the rule are statements supporting the optional 
\family typewriter
as
\family default
 keyword, since that effectively causes an assignment.
 These are 
\family typewriter
with
\family default
 (
\emph on
context manager
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
with!context manager
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Context manager (with)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!with
\end_layout

\end_inset

, 
\family typewriter
except
\family default
 (
\emph on
exception handler
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Exception handler (except)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!except
\end_layout

\end_inset

, and 
\family typewriter
import
\family default
 (module loader)
\begin_inset Index idx
status open

\begin_layout Plain Layout
import (module loader)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Module loader (import)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!import
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Similar to MATLAB; contrast: 
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

C, Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Expressions
\emph default
 vs.
 
\emph on
statements
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Expression (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Statement (programming)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
An expression produces a value, a statement does not.
 A statement just 
\emph on
does
\emph default
 something (i.e.
 causes 
\emph on
side effects
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Side effect (programming)
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
In some situations this matters; e.g., statements cannot be passed as function
 arguments.
\end_layout

\end_deeper
\begin_layout Itemize
This is a classical distinction, made in many imperative languages.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Named arguments
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Named arguments
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!named
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!named
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Argument passing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Passing arguments to functions
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Function 
\emph on
arguments can be passed also by name
\emph default
, not only by position in the argument list.
\end_layout

\begin_layout Itemize
Eliminates a common category of bugs where the arguments were given in the
 wrong order or off-by-one.
\end_layout

\begin_layout Itemize
Improves readability
\begin_inset Index idx
status open

\begin_layout Plain Layout
Readability
\end_layout

\end_inset

, as less often used optional arguments can be passed by name.
\end_layout

\begin_layout Itemize
Optional; can also use traditional positional arguments, or any mix of both.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Positional arguments
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!positional
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!positional
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions"

\end_inset


\end_layout

\begin_layout Itemize
Python
\begin_inset space ~
\end_inset

3 added also 
\emph on
keyword-only arguments
\emph default
 (i.e.
 arguments that can be passed 
\emph on
only
\emph default
 by name)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword-only arguments
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!keyword-only
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!keyword-only
\end_layout

\end_inset

:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-3102/"

\end_inset


\family default

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Whitespace is semantic
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Whitespace
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Indentation (code)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Code blocks are identified by their level of indentation 
\emph on
only.
\end_layout

\begin_deeper
\begin_layout Itemize
Improves readability
\begin_inset Index idx
status open

\begin_layout Plain Layout
Readability
\end_layout

\end_inset

 by reducing visual noise, as there is no block terminator symbol.
\end_layout

\end_deeper
\begin_layout Itemize
Hence, consistent indentation within the same source file is required by
 the language syntax.
\end_layout

\begin_deeper
\begin_layout Itemize
This also improves code readability
\begin_inset Index idx
status open

\begin_layout Plain Layout
Readability
\end_layout

\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Strings, Unicode, and why you should care
\begin_inset Index idx
status open

\begin_layout Plain Layout
String!and Unicode
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Unicode
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Handling text data, i.e.
 strings, is something programmers often have to deal with.
 It is mostly beyond the scope of this text, as we focus scientific computing.
\end_layout

\begin_layout Standard
Nevertheless, even numerical code typically cannot completely avoid dealing
 with strings.
 Not everything is expressible ASCII
\begin_inset Index idx
status open

\begin_layout Plain Layout
ASCII (character encoding)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Character encoding!ASCII
\end_layout

\end_inset

 or Latin-1
\begin_inset Index idx
status open

\begin_layout Plain Layout
Latin-1 (character encoding)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Character encoding!Latin-1
\end_layout

\end_inset

 (e.g.
 
\begin_inset Formula $\partial$
\end_inset

 
\begin_inset Formula $\int$
\end_inset

 
\begin_inset Formula $\alpha$
\end_inset

 
\begin_inset Formula $\equiv$
\end_inset

 for printed messages); and in any case, in order to write conceptually
 correct programs — i.e.
 to avoid conflating unrelated concepts — it is crucial to understand the
 basics.
\end_layout

\begin_layout Standard
The takeaway message from this section is, as some university courses put
 it, the:
\end_layout

\begin_layout Itemize

\series bold
DUE process
\series default
: 
\series bold
D
\series default
ecode, 
\series bold
U
\series default
nicode, 
\series bold
E
\series default
ncode
\end_layout

\begin_deeper
\begin_layout Itemize
Also known as the 
\series bold
Unicode sandwich
\series default
, because we:
\end_layout

\begin_layout Itemize

\series bold
Decode
\series default
 
\series bold
input
\series default
 from bytes; handle as 
\series bold
Unicode
\series default
 string; then 
\series bold
encode output
\series default
 to bytes.
\end_layout

\begin_layout Itemize
The Unicode string is essentially just a sequence of integers, each representing
 a Unicode codepoint.
\end_layout

\begin_layout Itemize
The popular 
\family typewriter
utf-8
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
utf-8 (character encoding)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Character encoding!utf-8
\end_layout

\end_inset


\emph on
 encoding
\emph default
 is a bytestream format (serialization format; protocol) that is used for
 disk storage, network transmission, input and output; it is not 
\begin_inset Quotes eld
\end_inset

Unicode
\begin_inset Quotes erd
\end_inset

 in the sense of 
\begin_inset Quotes eld
\end_inset

Unicode string
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
To make sense out of that, here are some pointers:
\end_layout

\begin_layout Itemize
Unicode and strings in Python:
\end_layout

\begin_deeper
\begin_layout Itemize
Ned Batchelder, PyCon 2012: Pragmatic Unicode, or, How do I stop the pain?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://nedbatchelder.com/text/unipain.html"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
(Graphical, comprehensive, short, to the point; 
\series bold
recommended
\series default
.)
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Nick Coghlan: Processing Text Files in Python 3:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://python-notes.curiousefficiency.org/en/latest/python3/text_file_processing.html"

\end_inset


\end_layout

\begin_layout Itemize
Differences between legacy and current:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://portingguide.readthedocs.io/en/latest/strings.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Python Unicode HOWTO:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/howto/unicode.html"

\end_inset


\end_layout

\begin_layout Itemize
On Unicode in general:
\end_layout

\begin_deeper
\begin_layout Itemize
Most of the time, one Unicode codepoint represents one character, but not
 always; combined characters exist, made up of several codepoints.
 Some of them even have alternative single-codepoint versions available.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Precomposed_character"

\end_inset


\end_layout

\begin_layout Itemize
Unicode standardizes the representation of very many characters, including
 over 2000 emoji:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://unicode.org/emoji/charts/full-emoji-list.html"

\end_inset


\end_layout

\begin_layout Itemize
Joel Spolsky: The Absolute Minimum Every Software Developer Absolutely,
 Positively Must Know About Unicode and Character Sets (No Excuses!)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
To summarize
\series default
:
\end_layout

\begin_layout Standard
An 
\emph on
encoding
\emph default
 specifies how the sequence of Unicode codepoints is represented as a stream
 of individual bytes.
 An encoding is used when the data needs to be transmitted between systems
 or stored.
 In general, different codepoints may need a different number of bytes to
 encode, and in fact, 
\family typewriter
utf-8
\family default
 is such a 
\emph on
variable-length encoding
\emph default
.
 Historically, variable-length encodings were introduced to save space,
 and to make the single-byte (actually 7-bit) ASCII into a proper subset
 of Unicode.
\end_layout

\begin_layout Standard
An example may be useful here.
 The first 128 Unicode codepoints, numbered 0–127, are defined as identical
 to ASCII, and in 
\family typewriter
utf-8
\family default
, they are also represented identically at the bytestream level.
\end_layout

\begin_layout Standard
Unicode codepoints 128–255 are defined as identical to those in the single-byte
 ISO-8859-1 (a.k.a.
 Latin-1) encoding; but at the bytestream level, 
\family typewriter
utf-8
\family default
 represents these codepoints as two-byte sequences.
\end_layout

\begin_layout Standard
An identical bytestream representation for codepoints 128–255 is clearly
 impossible, because Latin-1 takes up a full byte, and 
\family typewriter
utf-8
\family default
 needs to be able to represent also Unicode codepoints outside the range
 of Latin-1.
 Hence the first byte of each codepoint (in its 
\family typewriter
utf-8
\family default
 bytestream representation) must be able to include a signal indicating
 whether a the codepoint takes up several bytes.
\end_layout

\begin_layout Standard

\emph on
A Python
\begin_inset space ~
\end_inset

3 string is essentially a sequence of Unicode codepoints
\emph default
.
\end_layout

\begin_layout Standard
Once the input text is received as bytes and decoded into text, this — i.e.
 Unicode text — is what your Python program will deal with 99% of the time.
 Only at output time does the encoding come back into play.
 And in Python
\begin_inset space ~
\end_inset

3, even that is mostly automatic.
\end_layout

\begin_layout Standard
Just be sure to save your Python program (from your text editor) using the
 
\family typewriter
utf-8
\family default
 encoding.
\end_layout

\begin_layout Standard
If you find that you need details, see especially the HOWTO and N.
 Batchelder's presentation slides; both of these are highly informative.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
How to Python
\begin_inset CommandInset label
LatexCommand label
name "sec:How-to-Python"

\end_inset


\end_layout

\begin_layout Standard
We will not get hands-on with 
\emph on
all
\emph default
 the basics in these notes, so let us begin with some useful external material.
\end_layout

\begin_layout Standard
The very basics of interactive use of Python (5–15 minutes, 
\series bold
recommended
\series default
):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/tutorial/introduction.html"

\end_inset


\end_layout

\begin_layout Standard
A beginner tutorial, covering Python, Numpy and Matplotlib (
\series bold
recommended
\series default
):
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://cs231n.github.io/python-numpy-tutorial/"

\end_inset


\end_layout

\begin_layout Itemize
Matt Harrison: Learn 90% of Python in 90 minutes
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.slideshare.net/MattHarrison4/learn-90"

\end_inset


\end_layout

\begin_layout Itemize
David Goodger: Code Like a Pythonista: Idiomatic Python
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

This is a one-presentation crash course on Python that has some overlap
 with our present one.
\end_layout

\begin_layout Itemize
A large collection of Python tutorials:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://wiki.python.org/moin/BeginnersGuide/Programmers"

\end_inset


\end_layout

\begin_layout Itemize
Official Python tutorial:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/tutorial/"

\end_inset


\end_layout

\begin_layout Itemize
Official NumPy quickstart tutorial (intermediate):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/user/quickstart.html"

\end_inset


\end_layout

\begin_layout Itemize
Official SciPy tutorial:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/scipy/reference/tutorial/index.html"

\end_inset


\end_layout

\begin_layout Itemize
Official Matplotlib gallery (example plots and the codes that generate them):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://matplotlib.org/gallery.html"

\end_inset


\end_layout

\begin_layout Subsection
Built-in types: primitives and containers
\begin_inset Index idx
status open

\begin_layout Plain Layout
Built-in types
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!built-in
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Object instances of 
\series bold
primitive types
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Primitive types
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!primitive
\end_layout

\end_inset

 in Python are immutable, i.e.
 cannot change value once created:
\end_layout

\begin_layout Itemize

\family typewriter
str
\family default
: string, Unicode in Python
\begin_inset space ~
\end_inset

3
\begin_inset Index idx
status open

\begin_layout Plain Layout
str (primitive type)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!str, primitive type
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
int
\family default
: integer, no size limit
\begin_inset Index idx
status open

\begin_layout Plain Layout
int (primitive type)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/13795758/what-is-sys-maxint-in-python-3"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
(Answer: there isn't.)
\end_layout

\begin_deeper
\begin_layout Itemize
If, for algorithmic reasons, you need a value that is larger than any number,
 just use 
\begin_inset Formula $\infty$
\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

inf = float('+inf')
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

and don't worry that it's a float; it will compare correctly to integers,
 too.
 Also available:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

minf = float('-inf')
\end_layout

\begin_layout Plain Layout

nan  = float('nan')
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
float
\family default
: floating point number
\begin_inset Index idx
status open

\begin_layout Plain Layout
float (primitive type)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In practice, always IEEE-754
\begin_inset Index idx
status open

\begin_layout Plain Layout
IEEE-754 floating point
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Floating point number, IEEE-754
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Number!floating point, IEEE-754
\end_layout

\end_inset

 double precision (C: double; Fortran: DOUBLE PRECISION i.e.
 REAL*8)
\end_layout

\begin_layout Itemize

\family typewriter
import sys; print(sys.float_info)
\family default
 on your machine for details:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/sys.html#sys.float_info"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
complex
\family default
: complex number
\begin_inset Index idx
status open

\begin_layout Plain Layout
complex (primitive type)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
j
\family default
 denotes the imaginary part (as often in engineering), but only as a suffix
 of a numeric constant
\end_layout

\begin_layout Itemize
When you want just 
\begin_inset Formula $\sqrt{-1}$
\end_inset

 on its own, use 
\family typewriter
1j
\family default
 (to avoid any font issues here, that is 
\begin_inset Quotes eld
\end_inset

one jay
\begin_inset Quotes erd
\end_inset

)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Imaginary unit (
\begin_inset Formula $\sqrt{-1}$
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The trick 
\family typewriter
a+0j
\family default
, where 
\family typewriter
a
\family default
 is a float, is useful when you want to force Python to interpret the datatype
 of your real-valued constant as 
\family typewriter
complex
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
bytes
\family default
: arbitrary binary data
\begin_inset Index idx
status open

\begin_layout Plain Layout
bytes (primitive type)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are also abstract base classes for the numeric types, meant for things
 like 
\family typewriter
isinstance(x, numbers.Integral)
\family default
.
\end_layout

\begin_layout Standard
Among the 
\emph on
built-in types
\emph default
, beside the primitives, there are 
\series bold
containers
\series default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Container types
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Type!container
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These are mutable (with the exception of 
\family typewriter
tuple
\family default
, below), i.e.
 elements can be inserted, deleted and replaced after the creation of the
 container object instance.
\end_layout

\begin_layout Itemize

\family typewriter
list
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
list (container type)
\end_layout

\end_inset

 (ordered sequence): 
\family typewriter
L = [1, 2, 3]
\end_layout

\begin_deeper
\begin_layout Itemize
To create an empty list, 
\family typewriter
L = []
\end_layout

\begin_layout Itemize
Important methods:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
append()
\family default
 an item
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

L.append(4)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
extend()
\family default
 by another list (technically, by any 
\emph on
iterable
\emph default
)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

L.extend(K)
\end_layout

\begin_layout Plain Layout

L += K       # this is equivalent to L.extend(K)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
insert()
\family default
 an item before given index
\end_layout

\begin_layout Itemize

\family typewriter
pop()
\family default
 remove the item at given 
\series bold
index
\series default
 (default last) and return it
\end_layout

\begin_deeper
\begin_layout Itemize
Why 
\begin_inset Quotes eld
\end_inset

pop
\begin_inset Quotes erd
\end_inset

? A list can be used to implement a 
\emph on
stack
\emph default
, where the standard operations are called 
\emph on
push
\emph default
 and 
\emph on
pop
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Stack!abstract data type
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
remove()
\family default
 given 
\series bold
item
\series default
 (will search for it in the list)
\end_layout

\begin_layout Itemize

\family typewriter
sort()
\family default
 in-place
\end_layout

\begin_layout Itemize

\family typewriter
reverse()
\family default
 in-place
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
help(list)
\family default
 for more
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
set
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
set (container type)
\end_layout

\end_inset

 (unordered collection of unique elements): 
\family typewriter
S = {1, 2, 3}
\end_layout

\begin_deeper
\begin_layout Itemize
To create an empty set, 
\family typewriter
S = set()
\end_layout

\begin_deeper
\begin_layout Itemize
The notation 
\family typewriter
{}
\family default
, instead, refers to an empty dictionary.
 This is both for historical reasons (backwards compatibility), and because
 dictionaries are in practice used more often than sets.
\end_layout

\end_deeper
\begin_layout Itemize
The elements must be 
\emph on
hashable
\emph default
; 
\family typewriter
set
\family default
 uses a 
\emph on
hash table
\emph default
 to provide very fast lookup.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Hash!table
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Hashable
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Only 
\emph on
immutable
\emph default
 objects can be 
\emph on
hashable
\emph default
, as the hash value is related to contentwise equality, and Python assumes
 that the hash value for any given object instance remains constant.
\end_layout

\begin_layout Itemize
Primitive types are 
\emph on
hashable
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Important methods:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
add()
\family default
 an item
\end_layout

\begin_layout Itemize

\family typewriter
intersection()
\family default
, 
\family typewriter
union()
\family default
, 
\family typewriter
difference()
\family default
 between 
\family typewriter
set
\family default
s
\end_layout

\begin_layout Itemize

\family typewriter
remove()
\family default
 given item
\end_layout

\end_deeper
\begin_layout Itemize
Testing element membership
\begin_inset Index idx
status open

\begin_layout Plain Layout
Membership, of elements, testing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Operator!in (element membership)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Element membership, testing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
in (operator, element membership)
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

if a in S:
\end_layout

\begin_layout Plain Layout

    print("yes, object a is in set S")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if b not in S:
\end_layout

\begin_layout Plain Layout

    print("no, object b is not in set S")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

 This works for the other containers, too.
\end_layout

\begin_deeper
\begin_layout Itemize
For dictionaries, it will search the keys.
\end_layout

\begin_layout Itemize
For lists, the search will be slow (linear time; lists are not meant for
 searching).
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\family typewriter
dict
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
dict (container type)
\end_layout

\end_inset

 (unordered mapping from keys to values): 
\family typewriter
D = {1 : 42, 'banana' : 'fruit', '
\begin_inset Formula $\pi$
\end_inset

' : 3.14}
\end_layout

\begin_deeper
\begin_layout Itemize
To create an empty dict, 
\family typewriter
D = {}
\end_layout

\begin_layout Itemize
Yes, that's a Unicode key.
 But actually keys can be arbitrary 
\emph on
hashable object instances
\emph default
, not just primitives, as the dictionary uses a 
\emph on
hash table
\emph default
 for the keys.
 Values can be any object instances.
\end_layout

\begin_layout Itemize
To insert or get an item, index the dictionary by the key:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

D[k] = v  # insert (or replace existing)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D[k]  # get the value corresponding to key k
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\family typewriter

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
The assignment will overwrite if key 
\family typewriter
k
\family default
 already exists in 
\family typewriter
D
\family default
.
\family typewriter

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
Trying to retrieve by a key that does not exist in 
\family typewriter
D
\family default
 will raise 
\family typewriter
KeyError
\family default
.
\end_layout

\begin_layout Itemize
Important methods:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
pop()
\family default
 remove item having given key, return its value (or an optional default
 value if not there)
\end_layout

\begin_layout Itemize

\family typewriter
update()
\family default
 by another 
\family typewriter
dict
\family default
 (will insert any new keys, and overwrite items with matching keys)
\end_layout

\begin_layout Itemize
Element membership
\begin_inset Index idx
status open

\begin_layout Plain Layout
Membership, of elements, testing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Operator!in (element membership)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Element membership, testing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
in (operator, element membership)
\end_layout

\end_inset

, now in the set of keys, is tested using the 
\family typewriter
in
\family default
 keyword just like for 
\family typewriter
set
\family default
s:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

if k in D:
\end_layout

\begin_layout Plain Layout

    print("key k found in dictionary D")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Iteration by 
\family typewriter
keys()
\family default
, 
\family typewriter
values()
\family default
, 
\family typewriter
items()
\family default
.
 Examples:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# get (key,value) pairs:
\end_layout

\begin_layout Plain Layout

for k,v in D.items():
\end_layout

\begin_layout Plain Layout

    print("%s -> %s" % (k, v))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# just the keys
\end_layout

\begin_layout Plain Layout

for k in D.keys():
\end_layout

\begin_layout Plain Layout

    print(k)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# just the values (if you don't care which key each belongs to)
\end_layout

\begin_layout Plain Layout

for v in D.values():
\end_layout

\begin_layout Plain Layout

    print(v)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Creating a dictionary for reverse lookup
\begin_inset Index idx
status open

\begin_layout Plain Layout
dict, for reverse lookup
\end_layout

\end_inset

 (if the values of the original are hashable):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

R = { v: k for k,v in D.items() }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Here the RHS is a 
\emph on
dictionary comprehension
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Dict comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!dict
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
tuple
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
tuple (container type)
\end_layout

\end_inset

 (
\emph on
immutable
\emph default
 version of 
\family typewriter
list
\family default
): 
\family typewriter
T = (1, 2, 3)
\end_layout

\begin_deeper
\begin_layout Itemize
To create an empty tuple, 
\family typewriter
T = ()
\end_layout

\begin_deeper
\begin_layout Itemize
Technically, Python implements 
\family typewriter
()
\family default
 as a 
\emph on
singleton
\emph default
, i.e.
 there is only ever one instance of it.
 This is because the empty tuple is immutable and unique; it would make
 no sense for Python to create multiple copies of it.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Singleton!single-instance object
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To create a one-item tuple, 
\family typewriter
T = (youritem,)
\end_layout

\begin_deeper
\begin_layout Itemize
The trailing comma tells Python that this is meant as a tuple, not as a
 parenthesized expression.
\end_layout

\begin_layout Itemize
This is convenient when a function expects an iterable as input, and you
 want to give it just one item (e.g.
 array shape when creating 1D arrays).
\end_layout

\end_deeper
\begin_layout Itemize
Using a tuple (where applicable) instead of a list eliminates bugs by preventing
 accidental edits.
\end_layout

\begin_deeper
\begin_layout Itemize
Remember 
\emph on
call-by-sharing
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Call by!sharing (object)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Tuples are 
\emph on
hashable
\emph default
, so can be used as keys in dictionaries (and added to sets).
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
frozenset
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
frozenset (container type)
\end_layout

\end_inset

 (
\emph on
immutable
\emph default
 version of 
\family typewriter
set
\family default
): 
\family typewriter
F = frozenset( (1, 2, 3) )
\end_layout

\begin_deeper
\begin_layout Itemize
The parameter to the constructor must be an iterable.
\end_layout

\end_deeper
\begin_layout Standard
See 
\emph on
built-in types
\emph default
 in the documentation:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/stdtypes.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Tricks for containers, iteration, data structures
\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing!negative numbers in
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Negative numbers in indexing
\end_layout

\end_inset

Negative numbers index from the end.
 For example, 
\family typewriter
L[-1]
\family default
 is the last element of 
\family typewriter
L
\family default
 regardless of its length.
 Similarly, 
\family typewriter
A[-1,:]
\family default
 refers to the last row of the 2D array 
\family typewriter
A
\family default
.
\end_layout

\begin_layout Itemize
NumPy arrays behave like (although are not!) lists of lists.
 So if you need to, you can iterate over rows like:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# given a 2D NumPy array A:
\end_layout

\begin_layout Plain Layout

for v in A:
\end_layout

\begin_layout Plain Layout

    # v = A[0,:], A[1,:], ...
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

To iterate over columns, transpose first:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# given a 2D NumPy array A:
\end_layout

\begin_layout Plain Layout

for v in A.T:
\end_layout

\begin_layout Plain Layout

    # v = A[:,0], A[:,1], ...
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
List comprehensions
\emph default
 for processing lists
\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
Usage:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
B = [ dostuff(x) for x in A if condition(x) ]
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

where 
\family typewriter
dostuff()
\family default
 and 
\family typewriter
condition()
\family default
 are functions, 
\family typewriter
A
\family default
 is the original list to be processed, and 
\family typewriter
B
\family default
 is the result.
 Some of the parts are optional; these are also OK:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
B = [ dostuff(x) for x in A ]
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
B = [ x for x in A if condition(x) ]
\end_layout

\begin_layout Itemize
Similarly, 
\emph on
set comprehensions
\emph default
 and 
\emph on
dict comprehensions:
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Set comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!set
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Dict comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!dict
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
S = { i**2 for i in range(10) }
\end_layout

\begin_layout Itemize

\family typewriter
D = { i : i**2 for i in range(10) }
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Comprehensions.html"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://www.secnetix.de/olli/Python/list_comprehensions.hawk"

\end_inset


\family default
 (old, Python
\begin_inset space ~
\end_inset

2)
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/List_comprehension"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Generator expressions
\emph default
 are a cousin of list comprehensions, creating the elements 
\emph on
lazily
\emph default
, i.e.
 as they are needed.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Generator expression
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Generator
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In general, a generator instance can be iterated over only once; the elements
 are not saved.
\end_layout

\begin_layout Itemize
Example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

g = ( dostuff(x) for x in A if condition(x) )
\end_layout

\begin_layout Plain Layout

for x in g:
\end_layout

\begin_layout Plain Layout

    print(x)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Generators are not limited to these expressions; more complex generators
 can be created by writing functions that use the 
\family typewriter
yield
\family default
 keyword.
 
\end_layout

\end_deeper
\begin_layout Itemize
For more magic, see 
\family typewriter
itertools
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
itertools (module)
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\emph on
This module implements a number of iterator building blocks inspired by
 constructs from APL, Haskell, and SML.
 [...] Together, they form an “iterator algebra” making it possible to construct
 specialized tools succinctly and efficiently in pure Python.
\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/itertools.html"

\end_inset


\end_layout

\begin_layout Itemize
See 
\family typewriter
collections
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
collections (module)
\end_layout

\end_inset

 in the standard library for some more containers.
 For example, 
\family typewriter
collections.OrderedDict
\family default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
collections.OrderedDict
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
OrderedDict
\end_layout

\end_inset

provides a dictionary that remembers the order items were inserted; and
 
\family typewriter
collections.deque
\family default
 a double-ended queue
\begin_inset Index idx
status open

\begin_layout Plain Layout
collections.deque
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
deque
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Double-ended queue
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Queue!double-ended
\end_layout

\end_inset

.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
If you need more advanced data structures that perform some particular task
 well, it is likely someone has already implemented them.
 For example:
\end_layout

\begin_deeper
\begin_layout Itemize
SciPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
SciPy
\end_layout

\end_inset

 provides a kd-tree as 
\family typewriter
scipy.spatial.cKDTree
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
kd-tree
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This gives fast nearest-neighbor searches against a set of points in 
\begin_inset Formula $k$
\end_inset

 space dimensions.
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

 prefix just means it's the fast C implementation of SciPy's KDTree.
\end_layout

\end_deeper
\begin_layout Itemize
The standard library provides a min-heap
\begin_inset Index idx
status open

\begin_layout Plain Layout
Min-heap (data structure)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Heap (data structure)
\end_layout

\end_inset

 as 
\family typewriter
heapq
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
heapq (module)
\end_layout

\end_inset

.
 This is useful as a 
\emph on
priority queue
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Priority queue
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Queue!priority
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A priority queue is a queue where you can insert items with an associated
 priority.
 When you 
\family typewriter
heappop()
\family default
 an item off the queue, you will automatically get the item that currently
 has the highest priority.
 Python's 
\family typewriter
heapq
\family default
 uses a min-heap, so a smaller number means higher priority.
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Heap_(data_structure)"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
If you need named fields, define a class
\begin_inset Index idx
status open

\begin_layout Plain Layout
class!defining a
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
struct!defining (using class)
\end_layout

\end_inset

.
 It's simple:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

At the bare minimum, a class doesn't need much beside the fields (instance
\begin_inset Index idx
status open

\begin_layout Plain Layout
Member!instance
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Instance member
\end_layout

\end_inset

 or static members
\begin_inset Index idx
status open

\begin_layout Plain Layout
Static!member
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Member!static
\end_layout

\end_inset

, depending on what you want):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

class MyData:
\end_layout

\begin_layout Plain Layout

    z = 42  # static member, common for all instances of MyData
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def __init__(self, x, y):  # constructor
\end_layout

\begin_layout Plain Layout

        # instance members
\end_layout

\begin_layout Plain Layout

        self.x = x  # RHS is the x passed as argument, LHS names the field
 to store it in.
\end_layout

\begin_layout Plain Layout

        self.y = y
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

And done.
 Usage:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# store some data
\end_layout

\begin_layout Plain Layout

m1 = MyData(2, 3)
\end_layout

\begin_layout Plain Layout

m2 = MyData(x=5, y=17)  # passing by name is also fine (then order does
 not matter)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print(MyData.z)  # 42
\end_layout

\begin_layout Plain Layout

print(m1.z)      # also 42, since a single copy of z is shared across all
 instances
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print(m1.x)      # 2
\end_layout

\begin_layout Plain Layout

print(m2.x)      # 5
\end_layout

\begin_layout Plain Layout

print(MyData.x)  # AttributeError, does not exist since x is an instance
 member
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

By convention, in Python class names are capitalized in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
CamelCase
\end_layout

\end_inset

CamelCase.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

The first argument to all instance methods is passed automatically, and
 always refers to the current object instance.
 The standard name for it is 
\family typewriter
self
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
self (current object instance)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
As a curious aside, to see what generators
\begin_inset Index idx
status open

\begin_layout Plain Layout
Generator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Coroutine
\end_layout

\end_inset

 can do at the extreme — up to and including implementation of an academic
 multitasking operating system — see the presentation slides (advanced):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

David Beazley: A Curious Course on Coroutines and Concurrency:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.dabeaz.com/coroutines/"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family default
Note, however, that although extremely well written, the material is old;
 support for asynchronous tasks has since been improved in Python
\begin_inset space ~
\end_inset

3.5, and coroutines have been decoupled from generators (to help programmers
 avoid wrong intuitions).
 See:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0492/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0380/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/asyncio-task.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
* and **: unpacking tuples, lists and dictionaries
\end_layout

\begin_layout Standard

\emph on
Unpacking
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Unpacking
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Star operator (unpacking)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Double-star operator (unpacking)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
* operator!unpacking
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
** operator!unpacking
\end_layout

\end_inset

 is best explained by example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# given:
\end_layout

\begin_layout Plain Layout

def f(a, b, c):
\end_layout

\begin_layout Plain Layout

    return a+b+c
\end_layout

\begin_layout Plain Layout

data = range(1,4)  # (start,one-past-end): we get [1, 2, 3]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# we can:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a,b,c = data    # tuple unpacking; must have correct number of names on
 the LHS
\end_layout

\begin_layout Plain Layout

a,*rest = data  # but this is also OK: data[0] -> a, (data[1], ...) -> rest
\end_layout

\begin_layout Plain Layout

*rest,c = data  # and similarly, this too
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s = f(a,b,c)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# we can also unpack in the call:
\end_layout

\begin_layout Plain Layout

s = f(*data)  # data[0] -> first arg, data[1] -> second arg, ...
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

 The 
\emph on
star operator
\emph default
 works also in the argument list.
 By convention, 
\family typewriter
args
\family default
 is the standard name, but it can be anything:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def h(*args):
\end_layout

\begin_layout Plain Layout

    # any positional arguments passed in are now
\end_layout

\begin_layout Plain Layout

    # available as args[0], args[1], args[2], ...
\end_layout

\begin_layout Plain Layout

    pass
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

h(a,b,c)  # a,b,c will be collected into args
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Dictionary unpacking works similarly, but with a double star:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f(**kwargs):
\end_layout

\begin_layout Plain Layout

    # kwargs is now a dict containing named arguments
\end_layout

\begin_layout Plain Layout

    for k,v in kwargs.items():
\end_layout

\begin_layout Plain Layout

        print( "%s -> %s" % (k,v) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f(a=2, b='coffee')  # a and b will be packed into kwargs
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

The 
\begin_inset Quotes eld
\end_inset

inverse
\begin_inset Quotes erd
\end_inset

 of the previous example is also available:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f(a, b):
\end_layout

\begin_layout Plain Layout

    # almost anything can display itself as a string, so %s is a safe choice.
\end_layout

\begin_layout Plain Layout

    print("a = %s" % a)
\end_layout

\begin_layout Plain Layout

    print("b = %s" % b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The dictionary keys here must match the named arguments of f()
\end_layout

\begin_layout Plain Layout

# so that Python knows what to pass in where.
\end_layout

\begin_layout Plain Layout

D = { a : 42, b : 'qwerty' }
\end_layout

\begin_layout Plain Layout

f(**D)  # equivalent to f(a=42, b='qwerty')
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

See
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/2921847/what-does-the-star-operator-mean"

\end_inset


\end_layout

\begin_layout Standard
Extended iterable unpacking (3.0+):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-3132/"

\end_inset


\end_layout

\begin_layout Standard
Additional unpacking generalizations
\begin_inset Index idx
status open

\begin_layout Plain Layout
Unpacking!generalizations in Python 3.5+
\end_layout

\end_inset

 (3.5+):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0448/"

\end_inset


\end_layout

\begin_layout Subsection
Python math vs.
 NumPy math
\end_layout

\begin_layout Standard
Due to immutability of the primitive types, scalar math expressions in pure
 Python essentially work by creating new object instances at each step.
\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!math
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!math
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Math!NumPy
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Math!Python
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
NumPy arrays
\series default
 are a different story.
 For them, the 
\series bold
\emph on
size
\emph default
 is immutable, but the content is mutable
\series default
.
 This is because NumPy essentially makes C-level arrays accessible from
 Python.
 Note that NumPy arrays typically use C-compatible numeric types such as
 
\family typewriter
np.float64
\family default
 (C 
\begin_inset Quotes eld
\end_inset


\family typewriter
double
\family default

\begin_inset Quotes erd
\end_inset

) and 
\family typewriter
np.int64
\family default
 instead of Python's own types, although they 
\emph on
can
\emph default
 store arbitrary Python objects if desired.
\end_layout

\begin_layout Standard
Be aware that the Python and NumPy semantics do not always match down to
 the last detail, as the Python language itself and the numerics community
 have different design goals.
 For example, if you create a NumPy array out of literal integers without
 manually specifying a dtype (data type), you will get 
\emph on
an array with an integer dtype
\emph default
.
 To avoid that, either force your numbers to 
\family typewriter
float
\family default
 (e.g.
 
\family typewriter
5.0
\family default
 or equivalently 
\family typewriter
5.
\family default
, instead of just 
\family typewriter
5
\family default
), or specify 
\family typewriter
dtype=np.float64
\family default
 when you create the array.
\end_layout

\begin_layout Standard
Incidentally, the immutability of the size of NumPy arrays gets rid of a
 common MATLAB anti-pattern
\begin_inset Index idx
status open

\begin_layout Plain Layout
Anti-pattern
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pattern!the opposite of
\end_layout

\end_inset

, namely that of continually resizing arrays on the fly, simply by making
 it inconvenient to implement.
 (Such unnecessary resizing often causes a performance hit in carelessly
 written MATLAB code.)
\end_layout

\begin_layout Standard
To change the size of a NumPy array, a new array must be explicitly created,
 and the data copied over.
 Instead, if the array is immediately allocated at its final size, it needs
 to be created only once.
 Recall above (from NumPy basics) 
\family typewriter
np.zeros()
\family default
, 
\family typewriter
np.ones()
\family default
, 
\family typewriter
np.empty()
\family default
.
\end_layout

\begin_layout Standard
Although the size is immutable, 
\series bold
it is possible to change the 
\emph on
shape
\series default
\emph default
 (e.g.
 create a view with a linear index; or transpose/roll axes), as long as
 
\family typewriter
prod(shape)
\family default
 (i.e.
 the total number of elements) stays constant.
\end_layout

\begin_layout Standard
Finally, note also that the 
\family typewriter
math
\family default
 module of the standard library operates only on scalars; e.g.
 in 
\family typewriter
math.sin(x)
\family default
, the argument 
\family typewriter
x
\family default
 must be scalar (not an array).
\end_layout

\begin_layout Standard

\series bold
Vectorized math functions
\series default
 for NumPy arrays live in the NumPy namespace.
 For example, 
\family typewriter
np.sin(x)
\family default
 computes 
\family typewriter
sin
\family default
 elementwise for all elements of the NumPy array 
\family typewriter
x
\family default
.
 This is efficient, as then NumPy performs the looping internally in
\begin_inset space ~
\end_inset

C.
\end_layout

\begin_layout Standard
The Python standard library includes some number types for exotic situations:
\end_layout

\begin_layout Itemize
A software implementation of base-10 fixed point and base-10 floats:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/decimal.html"

\end_inset


\end_layout

\begin_layout Itemize
Exact fractions:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/fractions.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Useful construct: for/else
\begin_inset Index idx
status open

\begin_layout Plain Layout
for/else
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Python's 
\family typewriter
for
\family default
 loops have a little-known feature that sometimes comes in handy: 
\family typewriter
for
\family default
/
\family typewriter
else
\family default
.
 Consider this rather artificial example of looking for an item in a tuple
 by explicitly walking over it:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

T = tuple(range(10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

found = False
\end_layout

\begin_layout Plain Layout

for i in T:
\end_layout

\begin_layout Plain Layout

    if i == 42:
\end_layout

\begin_layout Plain Layout

       found = True
\end_layout

\begin_layout Plain Layout

       break
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if not found:
\end_layout

\begin_layout Plain Layout

    print("no 42 in T")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

 With 
\family typewriter
for
\family default
/
\family typewriter
else
\family default
, the example reduces to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

T = tuple(range(10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for i in T:
\end_layout

\begin_layout Plain Layout

    if i == 42:
\end_layout

\begin_layout Plain Layout

       break
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    print("no 42 in T")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which is, disregarding the line that creates 
\family typewriter
T
\family default
, 2/7
\begin_inset space ~
\end_inset

lines
\begin_inset space ~
\end_inset


\begin_inset Formula $\approx$
\end_inset


\begin_inset space ~
\end_inset

28.6% shorter (obviously this is the best case).
 It also avoids polluting the local namespace with a temporary flag variable
 (that the classical version leaves lying around), which would be a potential
 source of bugs, if the same function needs to do this in two different
 places and the programmer forgets to reset the flag.
\end_layout

\begin_layout Standard
This particular example is artificial, because in Python, normally one would
 just
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

T = tuple(range(10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if 42 not in T:
\end_layout

\begin_layout Plain Layout

    print("no 42 in T")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

but the 
\family typewriter
for
\family default
/
\family typewriter
else
\family default
 feature is useful also in real-world use cases that exhibit a similar pattern.
\end_layout

\begin_layout Standard
Mnemonic: 
\begin_inset Quotes eld
\end_inset


\family typewriter
for
\family default
/
\family typewriter
break
\family default
/
\family typewriter
else
\family default

\begin_inset Quotes erd
\end_inset

; the 
\family typewriter
else
\family default
 block runs if no 
\family typewriter
break
\family default
 occurred.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Error handling: try/except
\begin_inset Index idx
status open

\begin_layout Plain Layout
Error handling (try/except)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
try/except (error handling)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Exception handler (except)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As many object-oriented languages, in error handling Python follows the
 
\emph on
EAFP paradigm
\emph default
: it is 
\series bold
\emph on
E
\series default
asier to 
\series bold
A
\series default
sk for 
\series bold
F
\series default
orgiveness than 
\series bold
P
\series default
ermission
\emph default
.
 In contrast to requiring the caller to explicitly check the return value
 for an error code each time a function is called, like in C, errors are
 signaled by raising 
\emph on
exceptions
\emph default
 (like in C++, Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

, and MATLAB).
\end_layout

\begin_layout Standard
Many OO languages call the signaling of an error 
\begin_inset Quotes eld
\end_inset


\emph on
throwing
\emph default
 an exception
\begin_inset Quotes erd
\end_inset

; Python prefers the term 
\begin_inset Quotes eld
\end_inset


\emph on
raising
\emph default

\begin_inset Quotes erd
\end_inset

.
 The language keyword to signal an error is 
\family typewriter
raise
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
raise keyword
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!raise
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
try keyword
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!try
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
except keyword
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!except
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
finally keyword
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!finally
\end_layout

\end_inset

, as in
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

raise ValueError('got %s, but valid values are {"sandwich", "coffee"}.' %
 (s))
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This example also demonstrates a convention: in the Python community, it
 is considered polite to include as much useful information about the error
 into the error message as reasonably possible.
 For example, if it's string-representable, showing the offending data value
 is often useful, so that the programmer can spot that they actually requested
 a 
\begin_inset Quotes eld
\end_inset

snadwich
\begin_inset Quotes erd
\end_inset

 from this routine (thus making the bug easier to find).
\end_layout

\begin_layout Standard
Example of dealing with exceptions:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import os
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

    result = os.stat("this_file_does_not_exist.txt")
\end_layout

\begin_layout Plain Layout

except FileNotFoundError as e:
\end_layout

\begin_layout Plain Layout

    pass  # ignore the error (we could also do something else here)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

The 
\family typewriter
try
\family default
 block is self-explanatory; we 
\emph on
try to do this
\emph default
, in case no errors occur.
 Errors are caught by 
\emph on
exception handlers
\emph default
 represented by 
\family typewriter
except
\family default
 blocks, specific to each exception type (or optionally, a tuple of types).
\end_layout

\begin_layout Standard
The full construct follows the pattern:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

except ExceptionType1 as e:
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

except (ExceptionType2, ExceptionType3) as e:
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

finally:
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Similar to 
\family typewriter
for
\family default
/
\family typewriter
else
\family default
, the 
\family typewriter
else
\family default
 block runs after the 
\family typewriter
try
\family default
 block is done, if no exception occurred
\begin_inset Note Note
status open

\begin_layout Plain Layout
(mnemonic: 
\begin_inset Quotes eld
\end_inset


\family typewriter
try
\family default
/
\family typewriter
except
\family default
/
\family typewriter
else
\family default

\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

.
 The 
\family typewriter
finally
\family default
 block runs last, whether or not an exception occurred — and even if the
 code in the 
\family typewriter
try
\family default
 block encountered a 
\family typewriter
return
\family default
.
 It is mainly useful for freeing any resources (such as closing open files)
 that were allocated in the 
\family typewriter
try
\family default
 block (but see the 
\family typewriter
with
\family default
 keyword below).
\end_layout

\begin_layout Standard
Note that the 
\family typewriter
except
\family default
 and 
\family typewriter
else
\family default
 blocks are also allowed to raise exceptions!
\begin_inset Index idx
status open

\begin_layout Plain Layout
try/except/else
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This may be useful:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/6051934/purpose-of-else-and-finally-in-exception-handling"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
And when writing code, beware of the 
\begin_inset Quotes eld
\end_inset

old chestnut
\begin_inset Quotes erd
\end_inset

 (search for it):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://medium.com/@acboulder/type-hints-are-scary-f52d07a36a31#.yt2e91emo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An exception does not always indicate an error.
 Exceptions are sometimes used for program flow control.
 For example, an iterable raises 
\family typewriter
StopIteration
\family default
 when it is exhausted; and pressing 
\family typewriter
Ctrl+C
\family default
 in the terminal, to stop the running Python program, will raise 
\family typewriter
KeyboardInterrupt
\family default
.
\end_layout

\begin_layout Standard
Finally, just like everything else, exceptions are objects; they may carry
 additional information about the particular error that occurred.
\end_layout

\begin_layout Standard
Built-in exception types are listed and explained in the documentation,
 along with what data they contain:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/exceptions.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
The context manager: with
\begin_inset Index idx
status open

\begin_layout Plain Layout
with!context manager
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Context manager (with)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!with
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
with!keyword
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Any allocated resources must be freed correctly, no matter how the code
 block terminates (i.e.
 whether by falling through normally, 
\family typewriter
return
\family default
, or an exception).
\end_layout

\begin_layout Standard
Since memory management in Python is automatic, this mainly concerns things
 such as open files and database connections.
 Enter the context manager.
\end_layout

\begin_layout Standard
Strictly speaking, it is possible to do this using 
\family typewriter
try
\family default
, but getting all the corner cases correct is tedious and error-prone.
 Thus, already in Python
\begin_inset space ~
\end_inset

2.5, a new syntax element was introduced to simplify this common use case.
\end_layout

\begin_layout Standard
To make sure that the file 
\family typewriter
f
\family default
 is closed when the processing is done, use the 
\family typewriter
with
\family default
 keyword: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

with open("my_utf8_text_file.txt", "rt", encoding="utf-8") as f:
\end_layout

\begin_layout Plain Layout

    for line in f:
\end_layout

\begin_layout Plain Layout

        print(line.strip())
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

And that's it.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Automatically closing files
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Closing files automatically
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Files, closing automatically
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Advanced: Adding context manager support to your own class
\end_layout

\begin_layout Standard
Your own classes can also support 
\family typewriter
with
\family default
.
 Example (performance benchmarking):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import time
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class SimpleTimer:
\end_layout

\begin_layout Plain Layout

    def __init__(self, label="", n=None):
\end_layout

\begin_layout Plain Layout

        self.label = label
\end_layout

\begin_layout Plain Layout

        self.n     = n      # number of repetitions (for averaging)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # this runs when the "with" block is entered
\end_layout

\begin_layout Plain Layout

    def __enter__(self):
\end_layout

\begin_layout Plain Layout

        self.t0 = time.time()
\end_layout

\begin_layout Plain Layout

        return self  # this return value goes into the "as s" below
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # this runs when the "with" block exits
\end_layout

\begin_layout Plain Layout

    def __exit__(self, errtype, errvalue, traceback):
\end_layout

\begin_layout Plain Layout

        dt         = time.time() - self.t0
\end_layout

\begin_layout Plain Layout

        identifier = ("%s" % self.label) if len(self.label) else "time taken:
 "
\end_layout

\begin_layout Plain Layout

        avg        = (", avg.
 %gs per run" % (dt/self.n)) if self.n is not None else ""
\end_layout

\begin_layout Plain Layout

        print( "%s%gs%s" % (identifier, dt, avg) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    print("Benchmarking do_stuff():")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    with SimpleTimer(label=("    done in ")) as s:
\end_layout

\begin_layout Plain Layout

        do_stuff()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    reps = 100
\end_layout

\begin_layout Plain Layout

    with SimpleTimer(label=("    %d reps done in " % (reps)), n=reps) as
 s:
\end_layout

\begin_layout Plain Layout

        for k in range(reps):
\end_layout

\begin_layout Plain Layout

            do_stuff()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example is again somewhat artificial; for this use case, IPython has
 the 
\family typewriter
%timeit
\family default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
%timeit command (IPython)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Performance!benchmarking (IPython)
\end_layout

\end_inset

magic command; one could just import this module and 
\family typewriter
%timeit do_stuff()
\family default
.
\end_layout

\begin_layout Standard

\series bold
Takeaway message
\series default
: to support 
\family typewriter
with
\family default
, an object just needs to have the methods 
\family typewriter
__enter__()
\family default
 and 
\family typewriter
__exit__()
\family default
, and generally, when 
\family typewriter
__enter__()
\family default
 finishes, it should 
\family typewriter
return self
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Saving and loading NumPy arrays
\begin_inset Index idx
status open

\begin_layout Plain Layout
Saving and loading NumPy arrays
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!array!saving and loading
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are a few different ways to do this.
\end_layout

\begin_layout Standard
All the methods for saving and loading arrays have one thing in common.
 When loading a data file, no loader will inject variables from the loaded
 data into the current namespace à la MATLAB; and to force Python to do
 that is hard if not impossible.
 This is by design; Python prefers to keep things clean and predictable.
\end_layout

\begin_layout Standard
Instead, each loader gives you a Python dictionary, from which you should
 grab what you need.
\end_layout

\begin_layout Subsubsection
Optional: The Bunch pattern
\begin_inset Index idx
status open

\begin_layout Plain Layout
Bunch (pattern)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pattern!Bunch
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Manually grabbing each array can quickly get tedious when the file contains
 a lot of arrays.
 Consider:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

A = data["A"]
\end_layout

\begin_layout Plain Layout

B = data["B"]
\end_layout

\begin_layout Plain Layout

C = data["C"]
\end_layout

\begin_layout Plain Layout

[...]
\end_layout

\begin_layout Plain Layout

Z = data["Z"]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

and surely, the alternative 
\begin_inset Quotes eld
\end_inset

do nothing
\begin_inset Quotes erd
\end_inset

, i.e.
 just refer to the arrays as 
\family typewriter
data[
\begin_inset Quotes eld
\end_inset

A
\begin_inset Quotes erd
\end_inset

]
\family default
 etc.
 everywhere they are used, is not a practical option.
\end_layout

\begin_layout Standard
Thus, is there a way to automate this, to reduce the amount of both typing
 and repetitive-looking code?
\end_layout

\begin_layout Standard
It turns out that, although it is difficult to inject names into the current
 namespace, automatically creating and populating 
\emph on
fields of an object
\emph default
 is easy, via what is known in the programming community as 
\emph on
the Bunch pattern
\emph default
.
 A Bunch takes in a dictionary, and results in an object that has the dictionary
 keys as the names of its fields.
\end_layout

\begin_layout Standard

\series bold
Variant A1 — minimalist
\series default
, 
\emph on
namespace injection by setattr()
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
setattr
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

class Bunch:
\end_layout

\begin_layout Plain Layout

    def __init__(self, **kwargs):
\end_layout

\begin_layout Plain Layout

        for key in kwargs:
\end_layout

\begin_layout Plain Layout

            setattr(self, key, kwargs[key])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# usage (data is a dict)
\end_layout

\begin_layout Plain Layout

b = Bunch(**data)
\end_layout

\begin_layout Plain Layout

print(b.A)  # assuming there was a data["A"]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Variant A2 — minimalist
\series default
, 
\emph on
directly manipulating self.__dict__
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
self.__dict__
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The takeaway message here is really that 
\family typewriter
self.__dict__
\family default
 stores the mapping, from an object's attribute names, to the actual attributes.
 It is just a dictionary like any other.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

class Bunch:
\end_layout

\begin_layout Plain Layout

    def __init__(self, adict):
\end_layout

\begin_layout Plain Layout

        self.__dict__.update(adict)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# usage (data is a dict)
\end_layout

\begin_layout Plain Layout

b = Bunch(data)
\end_layout

\begin_layout Plain Layout

print(b.A)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Variant B — comprehensive
\end_layout

\begin_layout Standard
This one is 
\family typewriter
print()
\family default
able
\begin_inset Index idx
status open

\begin_layout Plain Layout
Printable class
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
class!printable
\end_layout

\end_inset

 (i.e.
 knows how to make a string representation of itself), deep-copyable (the
 
\family typewriter
copy()
\family default
 method copies the data, does not just make a reference), and can convert
 back to 
\family typewriter
dict
\family default
.
 Source:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://stackoverflow.com/questions/2597278/python-load-variables-in-a-dict-into-namespace"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

class Bunch(object):
\end_layout

\begin_layout Plain Layout

    def __init__(self, adict):
\end_layout

\begin_layout Plain Layout

        self.__dict__.update(adict)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def __str__(self):
\end_layout

\begin_layout Plain Layout

        return str(self.__dict__)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def as_dict(self):
\end_layout

\begin_layout Plain Layout

        return self.__dict__
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def copy(self):
\end_layout

\begin_layout Plain Layout

        return Bunch(self.__dict__)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# usage (data is a dict)
\end_layout

\begin_layout Plain Layout

b = Bunch(data)
\end_layout

\begin_layout Plain Layout

print(b.A)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Variant C — use a library
\end_layout

\begin_layout Standard
If you prefer, install 
\begin_inset Formula $\rightarrow$
\end_inset

 bunch from PyPI, which gives you a ready-made Bunch and some utility functions.
 (But will it remain maintained? This is simple, so perhaps better to roll
 your own to avoid introducing dependencies.)
\end_layout

\begin_layout Standard
Now, let's look at the options for saving and loading NumPy arrays.
\end_layout

\begin_layout Subsubsection
MATLAB .mat files
\end_layout

\begin_layout Standard
If you need to interact with MATLAB (or MATLAB users), this is convenient.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import scipy.io
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# saving
\end_layout

\begin_layout Plain Layout

data = { 'A' : A }  # dict; name --> object
\end_layout

\begin_layout Plain Layout

scipy.io.savemat('my_datafile.mat', mdict=data) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# loading
\end_layout

\begin_layout Plain Layout

data = scipy.io.loadmat('my_datafile.mat')  # --> dict
\end_layout

\begin_layout Plain Layout

A = data["A"]  # get matrix "A" from the dict
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
NumPy .npz files
\end_layout

\begin_layout Standard
NumPy's own binary format, gzip compressed.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# saving
\end_layout

\begin_layout Plain Layout

data = { 'A' : A }  # dict; name --> object
\end_layout

\begin_layout Plain Layout

np.savez_compressed('my_datafile.npz', **data)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# loading
\end_layout

\begin_layout Plain Layout

with np.load('my_datafile.npz') as data:
\end_layout

\begin_layout Plain Layout

    A = data['A']
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The documentation for 
\family typewriter
np.load()
\family default
 states that an 
\family typewriter
.npz
\family default
 file must be closed when done, so we use a 
\family typewriter
with
\family default
 block (which 
\family typewriter
np.load()
\family default
 supports for 
\family typewriter
.npz
\family default
 files).
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/reference/routines.io.html"

\end_inset


\end_layout

\begin_layout Standard
Note that since in Python the smallest unit of scope is the function, the
 name 
\family typewriter
A
\family default
 created inside the 
\family typewriter
with
\family default
 block will remain alive outside of it (which is of course what we want).
\end_layout

\begin_layout Subsubsection
Serialization (pickling)
\begin_inset Index idx
status open

\begin_layout Plain Layout
pickle (module)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pickling (serialization)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Serialization (pickling)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Python, almost any object instance can be 
\emph on
serialized
\emph default
; or in plain English, converted into a bytestream, which can be saved to
 disk, or sent over the network, and then converted back later.
\end_layout

\begin_layout Standard
This is a huge benefit of Python, and of high-level languages in general.
 Traditionally, serialization has involved a lot of tedious manual work
 toward supporting it from the part of the developer; essentially, writing
 routines to save all relevant data from a given type of object, and to
 read it back in and populate a new object instance with it.
\end_layout

\begin_layout Standard
This can be used for saving NumPy arrays; either directly in the case of
 a single array, or if multiple arrays, by storing them into a dictionary
 (which can also keep their names, as keys) and serializing that.
 Serialization is also useful for inter-process communication
\begin_inset Index idx
status open

\begin_layout Plain Layout
IPC (inter-process communication)
\end_layout

\end_inset

 (IPC) in parallel computing; incidentally, this is how mpi4py
\begin_inset Index idx
status open

\begin_layout Plain Layout
mpi4py
\end_layout

\end_inset

 transmits Python objects.
\end_layout

\begin_layout Standard
Python calls serialization 
\emph on
pickling
\emph default
, after the 
\family typewriter
pickle
\family default
 module (in the standard library) that implements it.
\end_layout

\begin_layout Standard
If a particular type of object cannot be pickled, its documentation (or
 the documentation of the library that object belongs to) will usually state
 so.
 This is sometimes the case for objects implemented in native extension
 modules, where supporting serialization may require large amounts of extra
 work from the library developer.
\end_layout

\begin_layout Standard
Note that the pickle format has no file header, or even a magic identifier
\begin_inset Index idx
status open

\begin_layout Plain Layout
Magic!file format identifier
\end_layout

\end_inset

, so the file type will not be recognized by the 
\family typewriter
file
\family default
 command on *nix systems (Linux, OS X), or by graphical file managers (Windows
 Explorer).
 Thus, if a user has a pickle file, but doesn't know that it's a pickle
 file, there's no way to tell for sure (short of trying to load it in Python).
\end_layout

\begin_layout Standard
So this file format is the opposite of self-documenting
\begin_inset Index idx
status open

\begin_layout Plain Layout
Self-documenting code (programming principle)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!principle!self-documenting code
\end_layout

\end_inset

.
 With that warning aside:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import pickle
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# saving
\end_layout

\begin_layout Plain Layout

# data: dict, name --> object
\end_layout

\begin_layout Plain Layout

with open('my_datafile.bin', 'wb') as f:
\end_layout

\begin_layout Plain Layout

    pickle.dump(data, f, protocol=pickle.HIGHEST_PROTOCOL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# loading
\end_layout

\begin_layout Plain Layout

with open('my_datafile.bin', 'rb') as f:
\end_layout

\begin_layout Plain Layout

    data = pickle.load(f)
\end_layout

\begin_layout Plain Layout

A = data["A"]   # etc.
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/13939913/how-to-test-if-a-file-has-been-created-by-pickle"

\end_inset


\begin_inset Newline newline
\end_inset


\family default
(Short answer: you can't.)
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Serialization"

\end_inset


\end_layout

\begin_layout Subsubsection
Text files
\end_layout

\begin_layout Standard
For ultimate interoperability: uncompressed, human-readable text files.
 Can only handle a single array per file.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# saving
\end_layout

\begin_layout Plain Layout

np.savetxt('A.txt', A)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# loading
\end_layout

\begin_layout Plain Layout

A = np.loadtxt('A.txt')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# loading alternative, for importing data:
\end_layout

\begin_layout Plain Layout

A = np.genfromtxt('A.txt')
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See the help pages for optional arguments; e.g.
 
\family typewriter
np.genfromtxt()
\family default
 has 
\family typewriter
delimiter
\family default
, which is useful for importing data in 
\family typewriter
.csv
\family default
 (comma-separated values) format.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Tips and tricks
\end_layout

\begin_layout Itemize
By returning a 
\family typewriter
tuple
\family default
, a function may pack an arbitrary number of outputs into the return value
\begin_inset Index idx
status open

\begin_layout Plain Layout
Return value!tuple
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Tuple as return value
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiple!return values
\end_layout

\end_inset

.
 Output arguments
\begin_inset Index idx
status open

\begin_layout Plain Layout
Output arguments
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!output
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!output
\end_layout

\end_inset

 in the sense of C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

 or Fortran
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

 are not needed.
\end_layout

\begin_layout Itemize
If you don't need a particular output, dummy it out
\begin_inset Index idx
status open

\begin_layout Plain Layout
Dummying outputs
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Discarding unnecessary part of return value
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Return value!discarding unnecessary part of
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

a,b,c = do_stuff()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

_,b,c = do_stuff()  # _ is a dummy
\end_layout

\begin_layout Plain Layout

a,_,c = do_stuff()
\end_layout

\begin_layout Plain Layout

a,*_  = do_stuff()  # tuple unpacking into _ to discard all after "a"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Standard names for the dummy variable are 
\family typewriter
_
\family default
 (single underscore) and the explicit 
\family typewriter
dummy
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
_ (underscore)!name for dummy variable
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Dummy variable, naming
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Naming a dummy variable
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The module name
\begin_inset Index idx
status open

\begin_layout Plain Layout
Module!name
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Name, of Python modules
\end_layout

\end_inset

 of a Python module is always the filename (without the .py).
 Unlike 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

Java, the module name is not declared separately.
 Module path
\begin_inset Index idx
status open

\begin_layout Plain Layout
Module!path
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Path, of Python modules
\end_layout

\end_inset

, roughly speaking, corresponds to the directory path.
\end_layout

\begin_layout Itemize
Useful especially in looping:
\begin_inset Index idx
status open

\begin_layout Plain Layout
range() (built-in function)
\end_layout

\end_inset

 
\family typewriter
range(n)
\family default
 is 
\family typewriter
[0, 1, ..., n-1]
\family default
.
 See 
\family typewriter
help(range)
\family default
 for more options.
\end_layout

\begin_layout Itemize
Chained comparisons
\begin_inset Index idx
status open

\begin_layout Plain Layout
Chained comparison
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comparison!chained
\end_layout

\end_inset

: 
\family typewriter
1 < x < 2
\family default
.
 Does exactly what a mathematician would expect, and evaluates each term
 at most once.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

(
\begin_inset Quotes eld
\end_inset

At most
\begin_inset Quotes erd
\end_inset

: The comparison will start from the left, and short-circuit if a term evaluates
 to 
\family typewriter
False
\family default
.) 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/stdtypes.html#comparisons"

\end_inset


\end_layout

\begin_layout Itemize
To continue an expression to the next line, the line continuation
\begin_inset Index idx
status open

\begin_layout Plain Layout
Line continuation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout

\backslash
 (line continuation)
\end_layout

\end_inset

 symbol in Python is backslash 
\begin_inset Quotes eld
\end_inset


\family sans

\backslash

\family default

\begin_inset Quotes erd
\end_inset

, like in
\begin_inset space ~
\end_inset

C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

.
 It is only needed if there is no parenthesis (, bracket [ or brace { currently
 open (unmatched).
 On a continued line, indentation is not semantic, so it can be used for
 maximal clarity:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

s = a 
\backslash

\end_layout

\begin_layout Plain Layout

  + b
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Exponentiation is denoted by 
\family typewriter
x**y
\family default
 (two stars).
 Works also for float exponents.
 Same as 
\family typewriter
pow(x,y)
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Exponentiation
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
** operator!exponentiation
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The division operator 
\family typewriter
/
\family default
 always produces a float (in Python
\begin_inset space ~
\end_inset

3!) — as it mathematically should, considering that integers alone do not
 form a division ring.
 To force integer division, use 
\family typewriter
//
\family default
 (two slashes).
\begin_inset Index idx
status open

\begin_layout Plain Layout
Division!true (arithmetic)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Integer division
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Division!integer
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
/ (true division)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
// (integer division)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The primitive logic operators are bare lowercase English words: 
\family typewriter
and
\family default
, 
\family typewriter
or
\family default
, 
\family typewriter
not
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Operator!logical
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Logic operators
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
and operator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
or operator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
not operator
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Exclusive OR is obtained by testing for inequality: 
\family typewriter
a != b
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
xor operator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Inequality, testing for
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comparison!inequality
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Pythonic swap
\begin_inset Index idx
status open

\begin_layout Plain Layout
Swap
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

a,b = b,a
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

No temporary.
 The general case of this is built on the unpacking
\begin_inset Index idx
status open

\begin_layout Plain Layout
Unpacking
\end_layout

\end_inset

 mechanism.
 Internal workings (advanced):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/21047622"

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Escape sequences
\emph default
 in strings
\begin_inset Index idx
status open

\begin_layout Plain Layout
Escape sequences (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!escape sequences supported in
\end_layout

\end_inset

 (for a table, scroll down by one screen or so).
 Mostly the same as in
\begin_inset space ~
\end_inset

C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Escape_sequence#Programming_languages"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Raw strings
\begin_inset Index idx
status open

\begin_layout Plain Layout
String!raw (r
\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Raw strings
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
r
\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

 (raw strings)
\end_layout

\end_inset

, i.e.
 how to disable 
\emph on
escape sequences
\emph default
.
 Prefix the string with 
\family typewriter
r
\family default
, just outside the opening quote.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

s = r"$
\backslash
theta$"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

gives LaTeX
\begin_inset Index idx
status open

\begin_layout Plain Layout
LaTeX math
\end_layout

\end_inset

 for 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\theta$
\end_inset


\begin_inset Quotes erd
\end_inset

, instead of the nonsensical string 
\begin_inset Quotes eld
\end_inset


\family typewriter
$<tab>heta
\family default
$
\begin_inset Quotes erd
\end_inset

.
 Useful for plot labels and such.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

When disabling is not an option (maybe you need newlines, 
\begin_inset Quotes erd
\end_inset


\family typewriter

\backslash
n
\family default

\begin_inset Quotes erd
\end_inset

?), the classic trick from C, of escaping each backslash, works in Python
 too.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

s = "$
\backslash

\backslash
theta$"   # <-- no r"..."
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

also gives LaTeX for 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\theta$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Matplotlib
\begin_inset Index idx
status open

\begin_layout Plain Layout
Matplotlib
\end_layout

\end_inset

 supports a subset of LaTeX in all labels, and autodetects if you pass in
 LaTeX math.
\begin_inset Index idx
status open

\begin_layout Plain Layout
LaTeX math
\end_layout

\end_inset

 No configuration needed.
 Internal layout engine, very fast, does not call LaTeX (unless explicitly
 told to).
\end_layout

\begin_deeper
\begin_layout Itemize
Particularly, 
\family typewriter

\backslash
text{}
\family default
 is not available; use 
\family typewriter

\backslash
mathrm{}
\family default
 to de-italicize locally; e.g.
 the 
\begin_inset Formula $\mathrm{d}$
\end_inset

 in 
\begin_inset Formula $\int f(x)\,\mathrm{d}x$
\end_inset

, which is usual, but also the 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Formula $H(x)=1\;\mathrm{if}\;x>0$
\end_inset

, where 
\family typewriter

\backslash
text{}
\family default
 would be semantically more appropriate.
\end_layout

\begin_layout Itemize
Forcing Matplotlib to render using external LaTeX: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://matplotlib.org/users/usetex.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
str.join()
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
str.join
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!joining with separator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Joining strings with separator
\end_layout

\end_inset

 Example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

L = [str(x) for x in range(5)]  # ["0", "1", "2", "3", "4"]
\end_layout

\begin_layout Plain Layout

s = ",".join(L)   # mnemonic: separator.join(list_of_items)
\end_layout

\begin_layout Plain Layout

print(s)  # "0,1,2,3,4"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
For file paths, always use
\begin_inset Index idx
status open

\begin_layout Plain Layout
os.path.join
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
File paths, handling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Paths to files, handling
\end_layout

\end_inset

 
\family typewriter
os.path.join()
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import os
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypath = os.path.join( 'dir', 'subdir', 'file.txt' )
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

instead of writing 
\emph on
either
\emph default
 
\family typewriter
dir
\backslash
subdir
\backslash
file.txt
\family default
 
\emph on
or
\emph default
 
\family typewriter
dir/subdir/file.txt
\family default
, because 
\emph on
both are wrong
\emph default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Windows uses 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

 as path separator, whereas *nix (Linux, OS X) uses 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

.
 The 
\family typewriter
os.path
\family default
 module detects which OS it is running on, and uses the correct path separator.
\end_layout

\begin_layout Itemize

\emph on
Regular expressions
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Regular expressions (regex)
\end_layout

\end_inset

 for string matching and substitution: see the 
\family typewriter
re
\family default
 module in the standard library, especially 
\family typewriter
re.findall()
\family default
 and 
\family typewriter
re.sub()
\family default
.
 Delving further into this topic is beyond the scope of this material.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Regular_expression"

\end_inset


\end_layout

\begin_layout Itemize
Python's 
\emph on
ternary if
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Ternary if syntax
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
If, expression form of (ternary)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Expression form of if
\end_layout

\end_inset

 syntax (equivalent to C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

's 
\begin_inset Quotes erd
\end_inset


\family typewriter
b?a:
\family default
c
\begin_inset Quotes erd
\end_inset

):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

x = a if b else c
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This is essentially an 
\emph on
expression form
\emph default
 of the 
\family typewriter
if
\family default
 
\emph on
statement
\emph default
.
 This can be used anywhere an expression is accepted.
 The 
\family typewriter
else
\family default
 part is mandatory; essentially, because an expression must always produce
 a value.
\end_layout

\begin_layout Itemize
Two kinds of equality
\begin_inset Index idx
status open

\begin_layout Plain Layout
Equality, content vs.
 object identity
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
== (equality by content)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
is (equality by object identity)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comparison!equality
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comparison!object identity
\end_layout

\end_inset

: 
\family typewriter
==
\family default
 tests 
\emph on
equality
\emph default
 (in terms of content), whereas 
\family typewriter
is
\family default
 tests 
\emph on
object identity
\emph default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# Given:
\end_layout

\begin_layout Plain Layout

a = 23
\end_layout

\begin_layout Plain Layout

b = 23
\end_layout

\begin_layout Plain Layout

c = a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# We have:
\end_layout

\begin_layout Plain Layout

a is b  # False
\end_layout

\begin_layout Plain Layout

a == b  # True
\end_layout

\begin_layout Plain Layout

a is c  # True (both names a and c point to the same object instance)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Multiplying a string by a positive integer 
\family typewriter
n
\family default
 repeats it 
\family typewriter
n
\family default
 times.
 For example, to print a horizontal line
\begin_inset Index idx
status open

\begin_layout Plain Layout
Horizontal line (printing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Line, horizontal (printing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiplication!strings
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!multiplication of
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

print(79 * "=")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Multiplication works also for lists
\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiplication!lists
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Lists, multiplication of
\end_layout

\end_inset

.
 Note that it doesn't copy elements, but only creates new references:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

a = ['item'] * 3              # ['item', 'item', 'item']
\end_layout

\begin_layout Plain Layout

a[0] is a[1] is a[2]          # True ...they're all the same item!
\end_layout

\begin_layout Plain Layout

a = [] * 3                    # [], since the list had no items to repeat
\end_layout

\begin_layout Plain Layout

a = [ [] ] * 3                # 3 references to the *same* empty list
\end_layout

\begin_layout Plain Layout

a = [ [] for j in range(3) ]  # 3 *independent* empty lists
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Practical guide to 
\emph on
string formatting
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
String!formatting!guide to
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!formatting!C printf style
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
C printf style string formatting
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
printf style string formatting
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!formatting!str.format
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
str.format (string formatting)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
String!formatting!f-strings
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
f-strings (string formatting)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Literal string interpolation (f-strings)
\end_layout

\end_inset

, i.e.
 how to e.g.
 
\family typewriter

\begin_inset Quotes eld
\end_inset

%d
\begin_inset Quotes erd
\end_inset

 % (myvariable)
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://pyformat.info/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\emph on
Disclaimer
\emph default
: in this text, we use the old 
\begin_inset Quotes eld
\end_inset

C printf style
\begin_inset Quotes erd
\end_inset

 string formatting.
 As of late 2017, the standard Python
\begin_inset space ~
\end_inset

3 way is to use the 
\family typewriter
format()
\family default
 method of 
\family typewriter
str
\family default
 instances.
 For now, pick whichever suits you best.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

In my personal opinion as a long-time programmer, 
\family typewriter
format()
\family default
 has always felt clunky to use.
 Apparently, other programmers have felt the same: in Python
\begin_inset space ~
\end_inset

3.6, a new, third style for string formatting called f-strings was introduced.
 It uses the same formatting mini-language as
\begin_inset space ~
\end_inset


\family typewriter
format()
\family default
, but it is now cleaner to feed in variables, and inline code for calculating
 values is allowed.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Once Python
\begin_inset space ~
\end_inset

3.6 becomes more common, the new style will likely become the dominant style
 for string formatting.
 For documentation, see:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

f-strings:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Both f-strings and format():
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/string.html#formatspec"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

C printf style:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting"

\end_inset


\family default

\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Literal string interpolation (f-strings) (3.6+):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0498/"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
You can freely mix and match different argument passing
\begin_inset Index idx
status open

\begin_layout Plain Layout
Argument passing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Passing arguments to functions
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!optional
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!optional
\end_layout

\end_inset

 styles in the same function.
 This is a pythonic way to implement optional arguments.
 Example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f(a, b, *args, **kwargs):
\end_layout

\begin_layout Plain Layout

    print("a = %s" % a)
\end_layout

\begin_layout Plain Layout

    print("b = %s" % b)
\end_layout

\begin_layout Plain Layout

    for x in args:
\end_layout

\begin_layout Plain Layout

        print(x)
\end_layout

\begin_layout Plain Layout

    for k,v in kwargs:
\end_layout

\begin_layout Plain Layout

        print("%s -> %s" % (k,v))
\end_layout

\begin_layout Plain Layout

    if "foo" in kwargs:
\end_layout

\begin_layout Plain Layout

        print("foo was given, its value is %s" % kwargs["foo"])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# a and b are matched to formal argument names in the definition of f().
\end_layout

\begin_layout Plain Layout

# f() does not have a named argument "c", so c goes into kwargs.
\end_layout

\begin_layout Plain Layout

f(a=2, b=3, c=5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The first two arguments go into a and b.
 Again, c goes into kwargs.
\end_layout

\begin_layout Plain Layout

f(2, 3, c=5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The first two arguments go into a and b; the third goes into args.
\end_layout

\begin_layout Plain Layout

f(2, 3, 5)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Default argument values
\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!default value, defining
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Default value!for function arguments
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!default value, defining
\end_layout

\end_inset

 can be specified in the style of C++
\begin_inset Index idx
status open

\begin_layout Plain Layout
C++
\end_layout

\end_inset

 and Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f(a=42):
\end_layout

\begin_layout Plain Layout

    pass  # do whatever
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f()  # uses default value for "a", since not given
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
But beware; defaults should almost never be mutable objects
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mutable default argument
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!default value, mutable
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!default value, mutable
\end_layout

\end_inset

.
 Do 
\emph on
not
\emph default
 use an empty list as a default! (Use an empty tuple instead.) Because if
 you do, you'll find that:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f(L=[]):  # don't do this!
\end_layout

\begin_layout Plain Layout

    L.append(1)
\end_layout

\begin_layout Plain Layout

    return L
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print(f())  # [1]
\end_layout

\begin_layout Plain Layout

print(f())  # [1, 1]
\end_layout

\begin_layout Plain Layout

print(f())  # [1, 1, 1]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

What happened? The function definition, when treating default arguments,
 
\emph on
binds to object instance
\emph default
, not to value.
 The definition of 
\family typewriter
f()
\family default
 creates an empty list — exactly once, when Python executes the line with
 the 
\family typewriter
def
\family default
 — and uses 
\emph on
this list instance
\emph default
 as the default value for 
\family typewriter
L
\family default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

There are use cases where this is actually desirable.
 (Can you think of one?)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://docs.python-guide.org/en/latest/writing/gotchas/"

\end_inset


\end_layout

\begin_layout Itemize
To specify 
\begin_inset Quotes eld
\end_inset

not given
\begin_inset Quotes erd
\end_inset

 as a default value
\begin_inset Index idx
status open

\begin_layout Plain Layout
Arguments to functions!default value, setting to N/A
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Default value!for function arguments, setting to N/A
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function arguments!default value, setting to N/A
\end_layout

\end_inset

 for an explicitly named argument (like 
\family typewriter
L
\family default
 above), it is standard to use the special value 
\family typewriter
None
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
None (special value)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This helps toward writing 
\emph on
self-documenting code
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Self-documenting code (programming principle)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!principle!self-documenting code
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
When the user asks for 
\family typewriter
help(f)
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Help system
\end_layout

\end_inset

, Python automatically shows the 
\emph on
function signature
\emph default
 (essentially, the 
\family typewriter
def
\family default
 up to the colon) above the docstring.
\begin_inset Index idx
status open

\begin_layout Plain Layout
docstring
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Thus any explicitly named arguments will show up automatically (making the
 user aware of their existence), while any arguments handled via 
\family typewriter
*args
\family default
 or 
\family typewriter
**kwargs
\family default
 will not; those must be documented manually.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
None
\family default
 is a 
\emph on
singleton
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Singleton!single-instance object
\end_layout

\end_inset

; or in plain English, there is only ever one instance of it.
 So the standard check for none-ness is to test the object identity against
 
\family typewriter
None
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
x is None
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

To check for non-none-ness:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
x is not None
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Yes, literally in English.
 (Also note the capital N in 
\family typewriter
None
\family default
; it is grammatically a proper noun, as (arguably) expected for a singleton.)
\end_layout

\begin_layout Itemize
Some Python programmers use the pattern
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
y = x or my_default
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

which sets 
\family typewriter
y
\family default
 to 
\family typewriter
x
\family default
 if 
\family typewriter
x is not None
\family default
, and otherwise to 
\family typewriter
my_default
\family default
.
 This is an abbreviation for
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
y = x if x is not None else my_default
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\emph on
Explicit is better than implicit
\emph default
, but 
\emph on
readability counts
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Readability
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Strictly speaking, the abbreviation works only if we make some generally
 reasonable assumptions about 
\family typewriter
x
\family default
.
 For the exact rules
\begin_inset Index idx
status open

\begin_layout Plain Layout
Truth value!of an object
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Testing truth value of an object
\end_layout

\end_inset

 on how objects behave in logical expressions, see:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/stdtypes.html#truth-value-testing"

\end_inset


\family default

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
In Python, 
\family typewriter
for
\family default
 loops
\begin_inset Index idx
status open

\begin_layout Plain Layout
for loop!over a collection
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
for loop!getting an explicit index from
\end_layout

\end_inset

 (roughly speaking) iterate directly over the items of a collection; also
 
\family typewriter
range()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
range() (built-in function)
\end_layout

\end_inset

 is just a collection.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

But sometimes you absolutely need the index number in a sequence of items.
 In this case, 
\family typewriter
enumerate()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
enumerate (built-in function)
\end_layout

\end_inset

 it:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

for i,x in enumerate(L):   # (0,L[0]), (1,L[1]), ...
\end_layout

\begin_layout Plain Layout

    print( "element %d of L is %s" % (i, x) )
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This is mainly useful for printing progress messages in your programs, calculati
ng the progress percentage as 
\family typewriter
100 * ((i+1) / len(L)
\family default
).
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

If you need to refer to an element of another sequence at the same index,
 for this use case there are much better design patterns: use a class
\begin_inset Index idx
status open

\begin_layout Plain Layout
class
\end_layout

\end_inset

 to group related items (if the grouping is relevant across the whole program);
 or 
\family typewriter
zip()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
zip (built-in function)
\end_layout

\end_inset

 the containers for the loop (for temporary throwaway grouping).
\end_layout

\begin_layout Itemize

\emph on
Zipping
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
zip (built-in function)
\end_layout

\end_inset

 (think of a zipper, the physical object).
 Example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# given lists a,b,...
\end_layout

\begin_layout Plain Layout

zip(a,b)     # (a[0],b[0]), (a[1],b[1]), ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

zip(a,b,c,d) # any number of inputs is fine
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

zip(*L)      # where L is a list of lists.
\end_layout

\begin_layout Plain Layout

             # We get (L[0][0], L[1][0], ...), (L[0][1], L[1][1], ...), ...
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Zipping in loops:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

for x,y in zip(a,b):  # (a[0],b[0]), (a[1],b[1]), ...
\end_layout

\begin_layout Plain Layout

    do_something(x,y)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Pairs of adjacent elements (bigrams
\begin_inset Index idx
status open

\begin_layout Plain Layout
Bigrams (pairs of adjacent elements)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pairs of adjacent elements (bigrams)
\end_layout

\end_inset

), pythonic way:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

s = "Python"  # a string is just an iterable consisting of characters
\end_layout

\begin_layout Plain Layout

for a,b in zip(s[:-1], s[1:]):
\end_layout

\begin_layout Plain Layout

    print("%s%s" % (a,b))
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This prints 
\family typewriter
Py
\family default
, 
\family typewriter
yt
\family default
, 
\family typewriter
th
\family default
, 
\family typewriter
ho
\family default
, 
\family typewriter
on
\family default
.
 We may even simplify this to
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

s = "Python"
\end_layout

\begin_layout Plain Layout

for a,b in zip(s, s[1:]):  # <-- only change: no [:-1]
\end_layout

\begin_layout Plain Layout

    print("%s%s" % (a,b))
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

because 
\family typewriter
zip()
\family default
 terminates on the shortest input; see 
\family typewriter
help(zip)
\family default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

For how to generalize this to tuples of three or more adjacent elements,
 see:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Scott Triglia: Elegant n-gram
\begin_inset Index idx
status open

\begin_layout Plain Layout
n-grams (n-tuples of adjacent elements)
\end_layout

\end_inset

 generation in Python (intermediate):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://locallyoptimal.com/blog/2013/01/20/elegant-n-gram-generation-in-python/"

\end_inset


\end_layout

\begin_layout Itemize
There is no 
\begin_inset Quotes erd
\end_inset


\family typewriter
unzip()
\family default

\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
zip (built-in function)!inverse of
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Inverse of zip
\end_layout

\end_inset

, because 
\family typewriter
zip()
\family default
 is its own inverse.
 Example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

x   = zip(a,b)  # output: (a[0],b[0]), (a[1],b[1]), ..., (a[-1],b[-1])
\end_layout

\begin_layout Plain Layout

c,d = zip(*x)   # zip(*x) = zip( (a[0],b[0]), (a[1],b[1]), ..., (a[-1],b[-1])
 )
\end_layout

\begin_layout Plain Layout

                #         = ( (a[0], a[1], ..., a[-1]), (b[0], b[1], ..., b[-1])
 )
\end_layout

\begin_layout Plain Layout

a == c  # True
\end_layout

\begin_layout Plain Layout

b == d  # True
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/13635032/what-is-the-inverse-function-of-zip-in-python"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Pretty-printer
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pretty-printing!Python
\end_layout

\end_inset

.
 From its help page: 
\emph on

\begin_inset Quotes eld
\end_inset

Very simple, but useful, especially in debugging data structures.
\begin_inset Quotes erd
\end_inset


\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

from pprint import pprint  # this imports function "pprint()" from module
 "pprint"
\end_layout

\begin_layout Plain Layout

pprint(myobj)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The symbolic math package SymPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
SymPy
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pretty-printing!SymPy
\end_layout

\end_inset

 also comes with a pretty-printer, for symbolic math expressions:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import sympy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# "sympify" = convert given string into symbolic math expression
\end_layout

\begin_layout Plain Layout

s = sympy.sympify("phi0 + 2*pi")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sympy.pprint(s)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This prints 
\begin_inset Formula $\varphi_{0}+2\cdot\pi$
\end_inset

.
\end_layout

\begin_layout Itemize
Some notes on the help system
\begin_inset Index idx
status open

\begin_layout Plain Layout
Help system
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
help(import)
\family default
 is a syntax error (since 
\family typewriter
import
\family default
 is a 
\emph on
keyword
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!import
\end_layout

\end_inset

 not an object), but 
\family typewriter
help(
\begin_inset Quotes eld
\end_inset

import
\begin_inset Quotes erd
\end_inset

)
\family default
 will show you its built-in documentation.
 Similarly for other language keywords (e.g.
 
\family typewriter
with
\family default
, 
\family typewriter
try
\family default
).
\end_layout

\begin_layout Itemize
See also 
\family typewriter
help(
\begin_inset Quotes eld
\end_inset

topics
\begin_inset Quotes erd
\end_inset

)
\family default
 for a list of general topics.
 These topics are viewed as, e.g.
 
\family typewriter
help(
\begin_inset Quotes eld
\end_inset

ASSERTION
\begin_inset Quotes erd
\end_inset

)
\family default
.
\end_layout

\begin_layout Itemize
For some things it is quicker to search the internet, but sometimes Python's
 help system (including docstrings
\begin_inset Index idx
status open

\begin_layout Plain Layout
docstring
\end_layout

\end_inset

 of library functions) may have crucial details not found elsewhere.
 (This is because Python programmers — just like MATLAB programmers — actively
 use the help system.)
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
Ellipsis
\family default
 is not very widely known
\begin_inset Index idx
status open

\begin_layout Plain Layout
...
 (Ellipsis)!the singleton object
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Ellipsis (...)!the singleton object
\end_layout

\end_inset

.
 It has been around at least since Python
\begin_inset space ~
\end_inset

2.4 (2004), but essentially it was implemented for the benefit of NumPy
\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Slicing
\end_layout

\end_inset

's slicing; after all this time, no other major libraries use it.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

In Python
\begin_inset space ~
\end_inset

3, 
\family typewriter
...

\family default
 is valid anywhere, also outside slicing syntax.
 Hence, some programmers use it to denote 
\begin_inset Quotes eld
\end_inset

add implementation here
\begin_inset Quotes erd
\end_inset

 TODOs.
 Others use the keyword 
\family typewriter
pass
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pass keyword
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!pass
\end_layout

\end_inset

, which is Python for 
\begin_inset Quotes eld
\end_inset

do nothing
\begin_inset Quotes erd
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/6189281"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/constants.html#Ellipsis"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Historical: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/2.4/lib/bltin-ellipsis-object.html"

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Shallow copy
\emph default
 vs.
 
\emph on
deep copy
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Shallow copy
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Copy!shallow
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Deep copy
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Copy!deep
\end_layout

\end_inset

 i.e.
 copy references only, or make copies of referred objects, too? This distinction
 is important in any system that uses references.
 In Python, see the 
\family typewriter
copy
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
copy (module)
\end_layout

\end_inset

 module that can do both:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/copy.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Note that NumPy arrays, as well as Python lists, dicts and sets have a 
\family typewriter
copy()
\family default
 method to make a shallow copy.
 (Can also use the copy constructor: 
\family typewriter
L2 = list(L1)
\family default
, 
\family typewriter
D2 = dict(D1)
\family default
 and 
\family typewriter
S2 = set(S1)
\family default
.)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

In general, copying is a deep issue — in programming there exist objects,
 such as handles to open files, which cannot be meaningfully copied.
 For the sake of argument: forget implementation, and consider the following
 question theoretically: if you copied an object instance that happened
 to be in the middle of writing to a file, or sending data over the network,
 what would you expect the copy to do?
\end_layout

\begin_layout Itemize
[Somewhat advanced] 
\emph on
Decorators
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Decorator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

!decorator; modifier for functions
\end_layout

\end_inset

 wrap functions to modify their behavior.
 Many Python libraries provide decorators (e.g.
 
\family typewriter
@profile
\family default
, 
\family typewriter
@numba.jit
\family default
).
 In the right hands, creating custom decorators is a very powerful technique.
 As Wikipedia points out, the established name 
\begin_inset Quotes eld
\end_inset

decorator
\begin_inset Quotes erd
\end_inset

 is a misnomer, as it easily gets confused with the design pattern of the
 same name; this Python feature would be properly called 
\emph on
advice
\emph default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://realpython.com/blog/python/primer-on-python-decorators/"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://www.thecodeship.com/patterns/guide-to-python-function-decorators/"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Advice_(programming)"

\end_inset


\end_layout

\begin_layout Itemize
For some more tips and tricks:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://python-3-for-scientists.readthedocs.io/en/latest/python3_user_features.html"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/101268/hidden-features-of-python"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

but take the second link with a grain of salt; some of the advice is firmly
 tongue-in-cheek.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
A scientist's checklist for Python 2 to Python 3 conversion
\end_layout

\begin_layout Standard
If you find yourself in the unenviable — and increasingly more rare — position
 that the software (or an online code example) you need was written years
 ago and only works in Python
\begin_inset space ~
\end_inset

2, don't worry.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Porting, Python 2 to Python 3
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!2 to 3 porting
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
If you only need to convert a short piece of code
\series default
, this list should cover most of it:
\end_layout

\begin_layout Itemize

\family typewriter
print ...

\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
print(...)
\end_layout

\begin_layout Itemize

\family typewriter
xrange(...)
\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
range(...)
\end_layout

\begin_deeper
\begin_layout Itemize
In Python 3, 
\family typewriter
range()
\family default
 creates a 
\family typewriter
range
\family default
 object, which behaves much like any generator, except that you can iterate
 over it multiple times (each time starting from the beginning).
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
range(...)
\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
tuple(range(...))
\end_layout

\begin_deeper
\begin_layout Itemize
This first creates the 
\family typewriter
range
\family default
 object, then feeds it to the 
\family typewriter
tuple
\family default
 constructor, which iterates over the 
\family typewriter
range
\family default
, extracts the output, and stores it into a new 
\family typewriter
tuple
\family default
.
\end_layout

\begin_layout Itemize
Only 
\family typewriter
tuple()
\family default
 a range if you have to.
 In most cases, this just wastes memory and makes the code slower; this
 is the practical reason the 
\family typewriter
range
\family default
 object was introduced in Python
\begin_inset space ~
\end_inset

3.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
filter( condition, L )
\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
filter (functional programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset

list comprehension: 
\family typewriter
[x for x in L if condition(x)]
\end_layout

\begin_layout Itemize

\family typewriter
map( func, L )
\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
map (functional programming)
\end_layout

\end_inset

list comprehension: 
\family typewriter
[func(x) for x in L]
\end_layout

\begin_layout Itemize

\family typewriter
reduce(...)
\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
reduce (functional programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
functools (module)
\end_layout

\end_inset

 
\family typewriter
functools.reduce(...)
\family default
 (and import functools!)
\end_layout

\begin_layout Itemize
Integer division
\begin_inset Index idx
status open

\begin_layout Plain Layout
Integer division
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Division!integer
\end_layout

\end_inset

: 
\family typewriter
k / 2
\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
k // 2
\end_layout

\begin_layout Itemize

\family typewriter
import cPickle as pickle
\family default
 
\begin_inset Formula $\rightarrow$
\end_inset

 
\family typewriter
import pickle
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pickle (module)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pickling (serialization)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Serialization (pickling)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some exceptions are now more descriptive; adjust any 
\family typewriter
except
\family default
 statements as needed.
\end_layout

\begin_deeper
\begin_layout Itemize
E.g.
 both 
\family typewriter
open()
\family default
 and 
\family typewriter
os.remove()
\family default
 now raise 
\family typewriter
FileNotFoundError
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
If you want the code to remain compatible also with Python 2.7, add this
 magic import to the start:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm
\end_layout

\end_inset


\family typewriter
from __future__ import division, print_function, absolute_import
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm
\end_layout

\end_inset

For pure Python
\begin_inset space ~
\end_inset

3 code, this is not needed.
 For cross-compatible
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cross-compatibility, Python 2 and 3
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!2 and 3 cross-compatibility
\end_layout

\end_inset

 code, you may also want to look into 
\begin_inset Formula $\rightarrow$
\end_inset

 six.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

Since cross-compatibility prevents from using features that only exist in
 Python
\begin_inset space ~
\end_inset

3, and Python
\begin_inset space ~
\end_inset

2 has already been almost phased out, my personal recommendation is to just
 go with Python
\begin_inset space ~
\end_inset

3.
\end_layout

\begin_layout Standard

\series bold
Conversion tools
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://python-future.org/automatic_conversion.html"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://python-modernize.readthedocs.io/en/latest/"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://pypi.python.org/pypi/tox"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Documentation
\end_layout

\begin_layout Itemize
Howto: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/howto/pyporting.html"

\end_inset


\end_layout

\begin_layout Itemize
Online book: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://python3porting.com/"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Python 3 source code template
\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!source code template
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It may be convenient to use a template such as the following, when creating
 a new program or module:
\end_layout

\begin_layout Standard

\family typewriter
template.py
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

"""Hello world 2.0"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    """Print a message."""
\end_layout

\begin_layout Plain Layout

    print("Hello, world!")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

    main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are several things to note here:
\end_layout

\begin_layout Itemize
The 
\emph on
hashbang
\emph default
 (
\family typewriter
#!
\family default
), a.k.a.
 
\emph on
shebang
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Hashbang (Linux, OS X)
\end_layout

\end_inset

 is optional, but if included, it must be the first thing in the source
 file.
\end_layout

\begin_deeper
\begin_layout Itemize
This tells Linux and OS X (and other *nix systems) which program to run
 this code with, if the source file itself is marked as executable.
\end_layout

\begin_layout Itemize
Change 
\family typewriter
python
\family default
 to 
\family typewriter
python3
\family default
 if necessary.
\end_layout

\begin_layout Itemize
The term 
\begin_inset Quotes eld
\end_inset

hashbang
\begin_inset Quotes erd
\end_inset

 has nothing to do with hashing or hash tables; it simply comes from the
 colloquial names of the characters 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

 (hash) and 
\begin_inset Quotes eld
\end_inset

!
\begin_inset Quotes erd
\end_inset

 (bang) used as the 
\emph on
magic
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Magic!file format identifier
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Shebang_(Unix)"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The 
\emph on
magic comment
\emph default
 (
\family typewriter
# -*- ...
 -*-
\family default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Character encoding!specifying for Python source code
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Magic!comment, character encoding
\end_layout

\end_inset

 specifies, for Python, the character encoding used in the source file.
\end_layout

\begin_deeper
\begin_layout Itemize
Optional, but if included, must be on the first or the second line.
 (Hence, second line, if a hashbang is also included.) If omitted, Python
 will treat the file as 
\family typewriter
utf-8
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Character encoding!utf-8
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
utf-8 (character encoding)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mainly useful for us Finns to write printed messages and docstrings
\begin_inset Index idx
status open

\begin_layout Plain Layout
docstring
\end_layout

\end_inset

 in Finnish, while ensuring that scandinavic characters show up correctly
 when the program runs or a user calls 
\family typewriter
help()
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Help system
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Scandinavic characters
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Characters, scandinavic
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
However, it is legal (if not often seen in practice) to use Unicode identifiers
\begin_inset Index idx
status open

\begin_layout Plain Layout
Unicode!identifier for variables (e.g.
 
\begin_inset Formula $\alpha$
\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Identifier for variables, Unicode (e.g.
 
\begin_inset Formula $\alpha$
\end_inset

)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $\alpha$
\end_inset

 as name of a variable
\end_layout

\end_inset

: 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\alpha=42$
\end_inset


\begin_inset Quotes erd
\end_inset

 is valid Python
\begin_inset space ~
\end_inset

3, creating a name called 
\begin_inset Formula $\alpha$
\end_inset

, and binding it to a new 
\family typewriter
int
\family default
 object instance having the value 42.
\end_layout

\begin_deeper
\begin_layout Itemize
This is limited to, roughly speaking, 
\begin_inset Quotes eld
\end_inset

alphabetical
\begin_inset Quotes erd
\end_inset

 characters.
 Alas, 
\begin_inset Formula $\int$
\end_inset

 is not a valid function name!
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/17043894/what-unicode-symbols-are-accepted-in-python3-variable-names"

\end_inset


\end_layout

\begin_layout Itemize
Nevertheless, with a LaTeX input method
\begin_inset Index idx
status open

\begin_layout Plain Layout
LaTeX input method
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Input method, LaTeX
\end_layout

\end_inset

 for inputting Unicode math symbols:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/clarkgrubb/latex-input"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

this 
\emph on
could
\emph default
 be used to write mathematical Python code in a rather natural way.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The keyword 
\family typewriter
def
\family default
 defines a function.
 In this example, the function takes no arguments.
\end_layout

\begin_layout Itemize
When a function returns without encountering an explicit 
\family typewriter
return
\family default
 statement
\begin_inset Index idx
status open

\begin_layout Plain Layout
return statement, default value of
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Default value!of return statement
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Return value!default
\end_layout

\end_inset

, the default return value is the special singleton
\begin_inset Index idx
status open

\begin_layout Plain Layout
Singleton!single-instance object
\end_layout

\end_inset

 object 
\family typewriter
None
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
None (special value)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Keep in mind that 
\begin_inset Quotes eld
\end_inset

the value of the last expression
\begin_inset Quotes erd
\end_inset

 is 
\emph on
not
\emph default
 automatically stored in Python; i.e., no 
\begin_inset Quotes eld
\end_inset

ans
\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Last expression, value of
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Value of last expression
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
_ (underscore)!value of last expression in IPython
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
However, in an interactive session, many frontends such as 
\emph on
IPython
\emph default
 capture and store it into a variable called 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 (a single underscore), as well as print it.
\end_layout

\begin_deeper
\begin_layout Itemize
But keep in mind that a 
\emph on
statement
\emph default
 produces no value.
\end_layout

\begin_layout Itemize
Especially, in Python assignment
\begin_inset Index idx
status open

\begin_layout Plain Layout
= (assignment)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Assignment
\end_layout

\end_inset

 is a statement, so e.g.
 
\family typewriter
a = b*c
\family default
 will only update 
\family typewriter
a
\family default
; it will not evaluate to a value (and hence, IPython will not update 
\family typewriter
_
\family default
).
 By itself, 
\family typewriter
b*c
\family default
 obviously does evaluate to a value (making IPython update 
\family typewriter
_
\family default
).
\end_layout

\end_deeper
\begin_layout Itemize
By convention, the name 
\family typewriter
_
\family default
 is also often used for dummying out unwanted components in a returned tuple,
 as a shorter alternative to the explicit standard name 
\family typewriter
dummy
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
_ (underscore)!name for dummy variable
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Dummy variable, naming
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Naming a dummy variable
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The magic part at the end is a standard 
\begin_inset Quotes eld
\end_inset

conditional main
\begin_inset Quotes erd
\end_inset

 pattern.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Conditional main (Python pattern)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pattern!conditional main (Python)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
It checks whether the name of the module being currently executed is 
\begin_inset Quotes eld
\end_inset


\family typewriter
__main__
\family default

\begin_inset Quotes erd
\end_inset

; if it is, then this file knows it is being run as the top-level main program.
\end_layout

\begin_layout Itemize
This allows 
\family typewriter
import
\family default
ing this file from another Python module, without causing the 
\family typewriter
main()
\family default
 defined here to run.
\end_layout

\begin_layout Itemize
The name of the actual function (here 
\family typewriter
main()
\family default
) is arbitrary, but 
\begin_inset Quotes erd
\end_inset


\family typewriter
main()
\family default

\begin_inset Quotes eld
\end_inset

 is perhaps the most self-documenting choice.
\begin_inset Index idx
status open

\begin_layout Plain Layout
main() function
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function, main()
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Self-documenting code (programming principle)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!principle!self-documenting code
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This pattern is often used for testing, or in the case of small libraries,
 for providing usage examples or a small demo inside the module itself.
\end_layout

\begin_layout Itemize
I.e.
 this file might not be the actual main program, but a utility module whose
 main purpose is to provide reusable functions for other modules; it just
 includes also a 
\family typewriter
main()
\family default
, so it can be run directly for unit testing or demo purposes.
\end_layout

\begin_layout Itemize
This is actually included in the language documentation for the magic module
 
\family typewriter
__main__
\family default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
__main__ (special Python module)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Module!__main__ (special)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/__main__.html"

\end_inset


\end_layout

\begin_layout Itemize
For more, see:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/419163/what-does-if-name-main-do"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If you want to add a command-line interface
\begin_inset Index idx
status open

\begin_layout Plain Layout
CLI (Command-line interface)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Command-line interface (CLI)
\end_layout

\end_inset

 to your program (so that you can call it easily from outside Python while
 passing it different argument values):
\end_layout

\begin_deeper
\begin_layout Itemize
Look into the 
\family typewriter
argparse
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
argparse (module)
\end_layout

\end_inset

 module in the standard library, and look for usage examples on the internet.
 This topic will be skipped here.
\end_layout

\begin_layout Itemize
The old 
\family typewriter
optparse
\family default
 module did the same thing, but has now been replaced by 
\family typewriter
argparse
\family default
.
\end_layout

\begin_layout Itemize
For backwards compatibility reasons, obsolete modules are usually not removed
 from the standard library, but only 
\emph on
deprecated
\emph default
; they are no longer developed further, and their documentation is updated
 to mention what has replaced them.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Deprecation (software term)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Any new code is expected to use the new module; the obsolete one exists
 solely for backwards compatibility with existing code that already uses
 it.
\end_layout

\begin_layout Itemize
Depending on the software project, deprecated features may be actually removed
 in a later version, after a transition period has elapsed.
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Deprecation"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Advanced topics
\begin_inset CommandInset label
LatexCommand label
name "sec:Advanced-topics"

\end_inset


\end_layout

\begin_layout Standard
This section contains some additional information on selected topics.
 The final section on the basics of software engineering is recommended.
 All others are optional and can be read in any order.
\end_layout

\begin_layout Subsection
Why object-oriented programming?
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
Object-oriented programming
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!object-oriented
\end_layout

\end_inset

Object-oriented programming (OOP) is hardly a new idea.
 It was invented at the turn of the 1960s, and early implementations were
 seen in LISP
\begin_inset Index idx
status open

\begin_layout Plain Layout
LISP
\end_layout

\end_inset

, ALGOL
\begin_inset Index idx
status open

\begin_layout Plain Layout
ALGOL
\end_layout

\end_inset

, and Simula
\begin_inset space ~
\end_inset

67
\begin_inset Index idx
status open

\begin_layout Plain Layout
Simula 67
\end_layout

\end_inset

.
 OOP has since spread to many programming languages, including C++
\begin_inset Index idx
status open

\begin_layout Plain Layout
C++
\end_layout

\end_inset

, Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

, and Python.
 A brief history at Wikipedia: 
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Object-oriented_programming#History"

\end_inset


\end_layout

\begin_layout Standard
At the time of this writing, OOP has been for a very long time well-established
 in the programming community, but is still underrated in scientific computing
 — except in larger software projects, where the developers come from a
 programming background.
\end_layout

\begin_layout Standard
So, as a scientist, why use OOP?
\end_layout

\begin_layout Standard
The answer is that OOP solves a practical problem: in programming, there
 are many situations in which it makes a lot of sense for data and algorithms
 to go together.
 Specifically in the context of scientific computing, global variables are
 nasty, and applying some very basic OOP is an easy way to avoid them.
\end_layout

\begin_layout Standard
Consider a solver that has a global variable 
\family typewriter
alpha
\family default
, or some internal state that must be preserved between function calls.
 What if we want to:
\end_layout

\begin_layout Itemize
Run two instances simultaneously, in the same process, with different values
 of 
\family typewriter
alpha
\family default
 (e.g.
 for a parametric study)?
\end_layout

\begin_layout Itemize
In this solver, re-use parts from another solver, that also defines a global
 variable 
\family typewriter
alpha
\family default
 for some different purpose?
\end_layout

\begin_layout Standard
Obviously, only one copy of a global variable
\begin_inset Index idx
status open

\begin_layout Plain Layout
Global variable
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Variable!global
\end_layout

\end_inset

 (of the same name) can exist at one time: 
\emph on
global variables pollute the global namespace
\emph default
.
\end_layout

\begin_layout Standard
The OOP solution is to, instead, hold the state and parameters of the computatio
n in 
\emph on
instance attributes
\emph default
 (instance members) of an object instance.
 Obviously, multiple independent instances of the same object type can exist
 at the same time.
\end_layout

\begin_layout Standard
OOP also conveniently packages the related data and functions (now methods)
 into the same place (the class), keeping them together also in the source
 code.
 This is known as 
\emph on
encapsulation
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Encapsulation (object-oriented programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Object-oriented programming!encapsulation
\end_layout

\end_inset

 (there is also another distinct meaning for the word, but that is not important
 here).
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)"

\end_inset


\end_layout

\begin_layout Standard
Of course, like any other programming paradigm, OOP is no silver bullet.
 In some situations, a procedural approach makes more sense.
 For example, linear equation system solvers are fine as procedural functions,
 to which the uses passes in the relevant data as arguments: 
\family typewriter
solve(A,b)
\family default
 looks clearer (for historical/cultural reasons) than 
\family typewriter
A.solve(b)
\family default
.
 But from the viewpoint of the developer of the library, keep in mind the
 above note about internal state...
\end_layout

\begin_layout Standard
To give a minimal taste of very basic OOP:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

class Solver:
\end_layout

\begin_layout Plain Layout

    def __init__(self, alpha):
\end_layout

\begin_layout Plain Layout

        self.alpha = alpha
\end_layout

\begin_layout Plain Layout

        self.x = None  # no solution computed yet
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def solve(self):
\end_layout

\begin_layout Plain Layout

        # do something here
\end_layout

\begin_layout Plain Layout

        self.x = 42 * self.alpha
\end_layout

\begin_layout Plain Layout

        return self.x
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    results = []
\end_layout

\begin_layout Plain Layout

    for a in [1., 10., 100.]:
\end_layout

\begin_layout Plain Layout

        s = Solver(alpha=a)
\end_layout

\begin_layout Plain Layout

        results.append(s.solve())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    print(results)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This example does not actually use multiple 
\family typewriter
Solver
\family default
 instances simultaneously, but perhaps it gets the main point across (about
 keeping the data and algorithms together).
\end_layout

\begin_layout Standard
As a final example to give a taste of slightly more advanced OOP, intermediate
 and advanced users may find useful the 
\emph on
mixin
\emph default
 
\emph on
pattern
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Mixin (pattern)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pattern!mixin
\end_layout

\end_inset

, which uses
\emph on
 multiple inheritance
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiple!inheritance
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Inheritance, multiple
\end_layout

\end_inset

 to inject functionality, while still allowing the class to inherit from
 something else (i.e.
 semantically speaking, to belong to a different part of the class hierarchy).
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Mixin"

\end_inset


\end_layout

\begin_layout Standard
Paraphrasing from one of my own projects:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# Base class.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

class Geometry:
\end_layout

\begin_layout Plain Layout

    pass  # (implementation goes here)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Gmsh file loader.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

class GmshGeometry(Geometry):  # <-- inherits from Geometry
\end_layout

\begin_layout Plain Layout

    pass  # (use the GmshTranslator library to load stuff)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Another, orthogonal class hierarchy was needed here for technical reasons,
\end_layout

\begin_layout Plain Layout

# to perform problem type specific initialization of the geometry.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# As a consequence, this branch knows nothing about loading files.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

class GenericProblemTypeSpecificGeometry(Geometry):
\end_layout

\begin_layout Plain Layout

    pass  # (implementation goes here)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# A specific problem type.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

class EulerFlowGeometry(GenericProblemTypeSpecificGeometry):
\end_layout

\begin_layout Plain Layout

    pass  # (do init specific to this problem type in this class)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Finally, now for the trick:
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

class EulerFlowGmshGeometry(GmshGeometry, EulerFlowGeometry):  # <-- multiple
 inheritance
\end_layout

\begin_layout Plain Layout

    pass  # (no implementation needed here)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

In this particular project, all the necessary functionality was already
 implemented by the ancestors in the two branches of the inheritance graph,
 i.e.
 no additional code was needed for the final class.
 This is generally not the case; usually mixins are used to bring in specific
 pieces of functionality.
\end_layout

\begin_layout Standard
And yes, the inheritance graph has a diamond shape, as both branches start
 at 
\family typewriter
Geometry
\family default
.
 For cases like this — and especially for more complex ones — you will want
 to know that for determining the 
\emph on
method resolution order
\emph default
 (MRO)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiple!inheritance!method resolution order (MRO)
\end_layout

\end_inset

, i.e.
 which ancestors are tried first when looking up methods of the derived
 class, Python applies what is known as the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
C3 linearization (multiple inheritance)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiple!inheritance!C3 linearization
\end_layout

\end_inset


\emph on
C3 linearization algorithm
\emph default
 to the inheritance graph.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/C3_linearization"

\end_inset


\end_layout

\begin_layout Standard
Unfortunately, we must stop here; how to OOP is beyond the scope of these
 lecture notes.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Parallel computing
\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
First, 
\series bold
try Numexpr
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Numexpr
\end_layout

\end_inset

, to see if it already gives the parallelism you want.
 However, if you need more control:
\end_layout

\end_inset

Writing concurrent software is difficult; correctly, even more so.
 But in scientific computing, it is often worth it.
\end_layout

\begin_layout Standard
Early concurrency was based on 
\emph on
shared memory
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Shared memory (parallel computing paradigm)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing!paradigm!shared memory
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)!shared memory (paradigm)
\end_layout

\end_inset

 and 
\emph on
locking
\emph default
 data structures so that at any given time, only one thread could write
 to any given data structure, thus ensuring consistency.
 An important term that is still in use: functions that be safely called
 simultaneously from multiple threads are called 
\emph on
reentrant
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Reentrant function (parallel computing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing!reentrant function
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)!reentrant function
\end_layout

\end_inset

 (Especially, documentation often warns if some particular function is 
\emph on
not
\emph default
 reentrant.)
\end_layout

\begin_layout Standard
The locking approach was prone to 
\emph on
deadlock
\emph default
:
\begin_inset Index idx
status open

\begin_layout Plain Layout
Deadlock (parallel computing bug)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing!deadlock (bug)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)!deadlock (bug)
\end_layout

\end_inset

 thread 
\family typewriter
A
\family default
 could start waiting to obtain access to a resource owned by thread 
\family typewriter
B
\family default
, while 
\family typewriter
B
\family default
 was already waiting to obtain access to a resource owned by 
\family typewriter
A
\family default
.
 Once any bugs in a program were sorted out, shared memory concurrency worked
 up to a few simultaneous threads.
 But as the number of threads grew, the requirement of exclusive access
 became a bottleneck: at any given time, most of the threads would be waiting
 for a lock.
 Large-scale parallelism required new solutions.
\end_layout

\begin_layout Standard
The current paradigm in concurrency, especially in scientific computing,
 is 
\emph on
message passing
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Message passing (parallel computing paradigm)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing!paradigm!message passing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)!message passing (paradigm)
\end_layout

\end_inset

 In short, independent agents communicate via messages; all memory is private.
 The programmer must coordinate the agents so that when one is sending,
 there will eventually be another listening; otherwise the software will
 typically deadlock.
 Still, this is usually simpler to get right than classical shared memory
 concurrency.
\end_layout

\begin_layout Standard
Message passing also scales well (also to supercomputers with over 
\begin_inset Formula $10^{4}$
\end_inset

 cores), until the message size becomes so large that the time taken for
 data transmission becomes a bottleneck.
 An important thing to keep in mind when working with the message passing
 paradigm is that any time spent communicating is time 
\emph on
not
\emph default
 spent on actually computing the solution.
\end_layout

\begin_layout Standard
A rising trend in concurrency is 
\emph on
transactional memory
\emph default
 (both in hardware and in software)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Transactional memory (parallel computing paradigm)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing!paradigm!transactional memory
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)!transactional memory (paradigm)
\end_layout

\end_inset

.
 This is a return to the idea of shared memory, while making deadlocks impossibl
e, and aiming toward a simpler abstraction for the programmer using the
 paradigm.
 Transactional memory must be directly supported by the programming language;
 Python (especially the standard CPython interpreter) currently does not
 have it.
\end_layout

\begin_layout Standard
See:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Lock_(computer_science)"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Race_condition"

\end_inset


\family default
 (a common type of bug in concurrent programming)
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Reentrancy_(computing)"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Message_passing"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Transactional_memory"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Software_transactional_memory"

\end_inset


\end_layout

\begin_layout Standard
On concurrency, Nick Coghlan writes:
\end_layout

\begin_layout Standard

\emph on
One of the key issues with threading models built on shared non-transactional
 memory is that they are a broken approach to general purpose concurrency.
 Armin Rigo has explained that far more eloquently than I can in the introductio
n to his Software Transactional Memory work for PyPy, but the general idea
 is that threading is to concurrency as the Python 2 Unicode model is to
 text handling — it works great a lot of the time, but if you make a mistake
 (which is inevitable in any non-trivial program) the consequences are unpredict
able (and often catastrophic from an application stability point of view),
 and the resulting situations are frequently a nightmare to debug.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://python-notes.curiousefficiency.org/en/latest/python3/multicore_python.html#multicore-python"

\end_inset


\end_layout

\begin_layout Subsubsection
Parallel computing in Python
\end_layout

\begin_layout Standard
Regardless of the paradigm used, concerning concurrency inside a single
 
\emph on
process
\emph default
 (in the operating system sense of the word), the standard Python implementation
, CPython, has an important limitation: the Global Interpreter Lock (GIL)
\begin_inset Index idx
status open

\begin_layout Plain Layout
GIL (global interpreter lock)
\end_layout

\end_inset

.
 Only one Python thread can be actively executing at a time.
 This is a design choice that simplifies the implementation of the interpreter.
\end_layout

\begin_layout Standard
The GIL is automatically released while waiting for I/O (including user
 input).
 A large portion of time spent waiting is typical for server workloads,
 for which Python has been traditionally used.
 However, this does not help in scientific computing, where a 100% CPU load
 is typical.
\begin_inset Note Note
status open

\begin_layout Plain Layout
From 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://python-notes.curiousefficiency.org/en/latest/python3/multicore_python.html#multicore-python"

\end_inset


\family default
:
\end_layout

\begin_layout Plain Layout

\emph on
The main downside of [the message passing] approach is that the overhead
 of message serialisation and interprocess communication can significantly
 increase the response latency and reduce the overall throughput of an applicati
on (see this 
\family sans
http://pyvideo.org/pycon-us-2015/python-concurrency-from-the-ground-up-live.html
\family default
 PyCon 2015 presentation from David Beazley for some example figures).
 Whether or not this overhead is considered acceptable in any given application
 will depend on the relative proportion of time that application ends up
 spending on interprocess communication overhead versus doing useful work.
\end_layout

\begin_layout Plain Layout

\emph on
The major alternative approach promoted by the community is best represented
 by Cython.
 Cython is a Python superset designed to be compiled down to CPython C extension
 modules.
 One of the features Cython offers (as is possible from any binary extension
 module) is the ability to explicitly release the GIL around a section of
 code.
 By releasing the GIL in this fashion, Cython code can fully exploit all
 cores on a machine for computationally intensive sections of the code,
 while retaining all the benefits of Python for other parts of the application.
\end_layout

\begin_layout Plain Layout

\emph on
Numba is another tool in a similar vein - it uses LLVM to convert Python
 code to machine code that can run with the GIL released (as well as exploiting
 vector operations provided by the CPU when appopriate).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So, how to work around the GIL?
\end_layout

\begin_layout Standard

\series bold
General tips
\series default
 in case of NumPy and SciPy: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://scipy.github.io/old-wiki/pages/ParallelProgramming"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Solution 1: process-based parallelism
\end_layout

\begin_layout Itemize
Nowadays often based on the 
\emph on
message passing
\emph default
 paradigm.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Recommended
\series default
.
 Relatively easy to learn, also scalable to clusters and supercomputers.
\end_layout

\begin_layout Itemize
See:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/7140544/message-passing-vs-locking"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://www.cs.cornell.edu/courses/cs312/2008sp/lectures/lec26.html"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?MessagePassingConcurrency"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
MPI 
\begin_inset Formula $\rightarrow$
\end_inset

 
\begin_inset Index idx
status open

\begin_layout Plain Layout
mpi4py
\end_layout

\end_inset

mpi4py
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
MPI (Message Passing Interface)
\end_layout

\end_inset

Message Passing Interface (MPI) is the de facto standard message-passing
 framework in scientific computing; clusters and supercomputers usually
 have it.
 Can also be run locally on a single machine.
 Implementations of the MPI specification include Open
\begin_inset space ~
\end_inset

MPI
\begin_inset Index idx
status open

\begin_layout Plain Layout
Open MPI
\end_layout

\end_inset

 and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
MPICH
\end_layout

\end_inset

MPICH.
\end_layout

\begin_layout Itemize
Each process (
\begin_inset Index idx
status open

\begin_layout Plain Layout
MPI (Message Passing Interface)!rank, task number
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Rank!MPI, task number
\end_layout

\end_inset

MPI rank) basically runs the same code independently, until told otherwise:
\end_layout

\begin_deeper
\begin_layout Itemize
Explicit conditional execution; can switch on MPI rank.
\end_layout

\end_deeper
\begin_layout Itemize
Explicit send/receive of messages between processes.
\end_layout

\begin_deeper
\begin_layout Itemize
Unicast (point-to-point), broadcast, scatter (divide data between processes),
 gather (results into root process), allgather (results to all), barrier
 (wait until all processes reach this point in the code)
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://pythonhosted.org/mpi4py/"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Can send both almost arbitrary Python objects, and NumPy arrays.
 NumPy arrays are transmitted at native speed using buffers.
\end_layout

\begin_layout Itemize
Almost arbitrary: the object must be pickleable (
\emph on
serializable
\emph default
).
 See 
\family typewriter
pickle
\family default
 in the standard library.
\begin_inset Index idx
status open

\begin_layout Plain Layout
pickle (module)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pickling (serialization)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Serialization (pickling)
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
ZeroMQ
\end_layout

\end_inset

ZeroMQ
\end_layout

\begin_deeper
\begin_layout Itemize
Message passing with both fine-grained control and advanced abstractions,
 meant for an arbitrary set of communicating, otherwise fully independent
 processes.
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://zeromq.org/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
multiprocessing
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
multiprocessing (module)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
[In the standard library,] multiprocessing is a package that supports spawning
 processes using an API similar to the threading module.
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
API (application programming interface)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/multiprocessing.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
concurrent.futures.ProcessPoolExecutor
\family default
 (introduced in Python
\begin_inset space ~
\end_inset

3.2)
\begin_inset Index idx
status open

\begin_layout Plain Layout
concurrent.futures.ProcessPoolExecutor
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
ProcessPoolExecutor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Easy-to-use high-level abstraction that builds on 
\family typewriter
multiprocessing
\family default
.
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/concurrent.futures.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\series bold
Solution 2: native extension module
\begin_inset Index idx
status open

\begin_layout Plain Layout
Native extension module
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Extension module, native
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Native
\emph default
: compiled, machine-language.
\end_layout

\begin_layout Itemize

\emph on
Extension module
\emph default
: an external library that has a Python interface, so that Python modules
 can 
\family typewriter
import
\family default
 it.
\end_layout

\begin_layout Itemize
Program your low-level parts in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cython
\end_layout

\end_inset

Cython, and inside native code, release the GIL
\begin_inset Index idx
status open

\begin_layout Plain Layout
GIL (global interpreter lock)
\end_layout

\end_inset

 when a long-running computation starts.
\end_layout

\begin_deeper
\begin_layout Itemize
Many libraries, such as NumPy, do exactly this internally.
\end_layout

\begin_layout Itemize
Getting this right in your own Cython code may require some wizardry.
 For example, 
\begin_inset Quotes eld
\end_inset


\family typewriter
with nogil:
\family default

\begin_inset Quotes eld
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
nogil (Cython keyword)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!nogil (Cython)
\end_layout

\end_inset

 blocks must not be nested.
 (Design carefully.)
\end_layout

\end_deeper
\begin_layout Itemize
Not scalable beyond a single machine; but in that environment, definitely
 helps.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Amdahl's law
\end_layout

\begin_layout Standard
Regardless of your method of parallelization, keep in mind 
\series bold
Amdahl's law
\series default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Amdahl's law (parallel computing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing!Amdahl's law
\end_layout

\end_inset

, which is an upper bound for scalability
\family sans
:
\family default

\begin_inset Formula 
\[
S(s)=\frac{1}{(1-p)+p/s}\;.
\]

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Amdahl%27s_law"

\end_inset


\end_layout

\begin_layout Standard
Roughly speaking, 
\begin_inset Formula $S$
\end_inset

 is the theoretical speedup factor of the whole program (as more processors
 are thrown at it), 
\begin_inset Formula $p$
\end_inset

 is the proportion of time spent in parallelized parts of the program, and
 
\begin_inset Formula $s$
\end_inset

 is the speedup factor of the parallelized part.
 In the unrealistic, theoretical ideal case with perfect scalability, 
\begin_inset Formula $s$
\end_inset

 is the number of processors.
 We have
\begin_inset Formula 
\[
\underset{s\rightarrow\infty}{\lim}S(s)=\frac{1}{1-p}\;,
\]

\end_inset

which illustrates that the most important factor is 
\begin_inset Formula $1-p$
\end_inset

, i.e.
 the portion of serial code in the whole program.
 Wikipedia provides this helpful graph (courtesy of user Daniels220, CC-BY-SA-3.0
):
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename AmdahlsLaw.svg
	width 68text%

\end_inset


\end_layout

\begin_layout Standard
Especially note that for a serial portion of only 5%, the maximum speedup
 that can be obtained for the execution of the whole program 
\emph on
even with an infinite number of processors
\emph default
 is just 
\begin_inset Formula $20\times$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 1cm
\end_layout

\end_inset


\series bold
Further reading
\series default
 (beginner to advanced):
\end_layout

\begin_layout Standard
Nick Coghlan: Efficiently Exploiting Multiple Cores with Python
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://python-notes.curiousefficiency.org/en/latest/python3/multicore_python.html"

\end_inset


\end_layout

\begin_layout Standard
David Beazley (USENIX 2009): An Introduction to Python Concurrency
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.slideshare.net/dabeaz/an-introduction-to-python-concurrency"

\end_inset


\end_layout

\begin_layout Standard
Bartosz Milewski: Beyond Locks and Messages: The Future of Concurrent Programmin
g:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://bartoszmilewski.com/2010/08/02/beyond-locks-and-messages-the-future-of-concurrent-programming/"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Numexpr
\begin_inset Index idx
status open

\begin_layout Plain Layout
Numexpr
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Numexpr is an easy-to-use, fast evaluator for elementwise expressions operating
 on NumPy arrays.
 It essentially works by reducing the number of temporary copies, when compared
 to evaluating the same expression in NumPy.
 Hence, expressions evaluated using Numexpr may need less memory.
 An orthogonal advantage is that Numexpr supports multithreading right out
 of the box, speeding up evaluation.
 Typical speed-ups are 
\begin_inset Formula $2$
\end_inset

–
\begin_inset Formula $4\times$
\end_inset

.
\end_layout

\begin_layout Standard
It is important to keep in mind that in computers, memory latency is high,
 and memory bandwidth is much more (
\begin_inset Formula $\approx10$
\end_inset

–
\begin_inset Formula $15\times$
\end_inset

) expensive than math, so this is especially important for large arrays.
 (That is, the processor may have time to complete 
\begin_inset Formula $10$
\end_inset

 to 
\begin_inset Formula $15$
\end_inset

 math instructions in the time it takes to perform one memory access.)
\end_layout

\begin_layout Standard
It is possible to avoid temporaries in pure NumPy by using the 
\family typewriter
out=...

\family default
 argument, but this typically makes the code much less readable.
 On the other hand, Numexpr code must be wrapped into strings.
 This may also decrease readability, as editors do not syntax highlight
 code inside strings.
\end_layout

\begin_layout Standard
As of late 2017, in recent versions of NumPy, there have been some improvements
 to automatic identification of temporaries, but Numexpr retains its advantage
 of multithreading.
\end_layout

\begin_layout Standard
Hence, using Numexpr is an easy way to reduce memory use and increase speed.
\end_layout

\begin_layout Standard
Simple example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

import numexpr
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

b = np.random.random(5)
\end_layout

\begin_layout Plain Layout

c = np.random.random(5)
\end_layout

\begin_layout Plain Layout

d = np.random.random(5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Names are captured automatically from the enclosing scope.
\end_layout

\begin_layout Plain Layout

# This is also automatically multithreaded.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

numexpr.evaluate("a = b + c*d")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See:
\end_layout

\begin_layout Itemize
Official site:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/pydata/numexpr"

\end_inset


\end_layout

\begin_layout Itemize
User manual:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numexpr.readthedocs.io/en/latest/"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Note especially:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

The initial number of threads will be set to the number of cores detected
 in the system or 8,
\begin_inset Newline newline
\end_inset

whichever is 
\emph on
lower
\emph default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numexpr.readthedocs.io/en/latest/user_guide.html#general-routines"

\end_inset


\end_layout

\begin_layout Itemize
To adjust, 
\family typewriter
numexpr.set_num_threads(nthreads)
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize
A slightly more detailed description of how Numexpr works:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numexpr.readthedocs.io/en/latest/intro.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Numba
\begin_inset Index idx
status open

\begin_layout Plain Layout
Numba
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Numba is essentially a JIT
\begin_inset Index idx
status open

\begin_layout Plain Layout
JIT (just-in-time compiler)
\end_layout

\end_inset

 (just-in-time) compiler for a subset of Python, with some limited support
 also for traditional ahead-of-time (AOT) compilation.
 Numba uses LLVM
\begin_inset Index idx
status open

\begin_layout Plain Layout
LLVM
\end_layout

\end_inset

 to compile Python code to machine code, as well as exploits vector operations
 provided by the CPU when appopriate.
\end_layout

\begin_layout Standard
As compile targets, Numba supports single-core CPU, parallel CPU, and NVIDIA
 GPU (CUDA).
 A CUDA simulator is available for debugging CUDA code.
\end_layout

\begin_layout Standard
"Subset of Python" means, in practice, that Numba supports almost all of
 Python, but is missing some of the high-level features such as list/dict/set
 comprehensions
\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Set comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!set
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Dict comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!dict
\end_layout

\end_inset

, lambdas
\begin_inset Index idx
status open

\begin_layout Plain Layout
Anonymous function (lambda)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Lambda (anonymous function)
\end_layout

\end_inset

, and nested function definitions.
 Generators
\begin_inset Index idx
status open

\begin_layout Plain Layout
Generator
\end_layout

\end_inset

 are only partially supported.
 But it can still do a lot.
\end_layout

\begin_layout Standard
The idea of Numba is to compile each function when it is called for the
 first time.
 This introduces a very high overhead for the first call, but subsequent
 calls will be very fast, as they use the compiled code.
 Note that the function is re-compiled, if the data types of the arguments
 change.
\end_layout

\begin_layout Standard
Numba is ideal for JITing small performance-critical snippets in its 
\emph on
nopython
\emph default
 mode.
 It can also lift low-level loops in its 
\emph on
object
\emph default
 mode.
\end_layout

\begin_layout Standard
In any case, it has automatic type inference, so there is no need to annotate
 the data types used (int64, float64, etc.).
 It is however possible to do so for the function arguments and the return
 value, if precise control over input and output data types is desired.
\end_layout

\begin_layout Standard

\series bold
Basic usage is very easy
\series default
.
 Silly example:
\begin_inset Index idx
status open

\begin_layout Plain Layout
Decorator!
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

numba.jit
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numba   # <--- add this
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@numba.jit     # <--- and this
\end_layout

\begin_layout Plain Layout

def f(x,y):
\end_layout

\begin_layout Plain Layout

    return x+y
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Now you can use 
\family typewriter
f()
\family default
 just as usual.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

f(5, 3)            # int64
\end_layout

\begin_layout Plain Layout

f(1.414, 3.14159)  # float64
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that's it.
\end_layout

\begin_layout Itemize
Documentation:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numba.pydata.org/numba-doc/0.30.1/index.html"

\end_inset


\end_layout

\begin_layout Itemize
Especially, lists of supported features:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numba.pydata.org/numba-doc/0.30.1/reference/pysupported.html"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numba.pydata.org/numba-doc/0.30.1/reference/numpysupported.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Check your code against these if you get a nonsensical-looking error message
 from Numba's JIT.
\end_layout

\begin_layout Itemize
The only practical concerns are:
\end_layout

\begin_deeper
\begin_layout Itemize
Installation; at least at some point in history, Numba has been rather particula
r about the versions of LLVM it supports.
\end_layout

\begin_layout Itemize
Distribution of projects using Numba to end users, since compilation occurs
 at runtime (and hence Numba and LLVM are needed as runtime dependencies).
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
NumPy ufuncs and gufuncs in Numba
\end_layout

\begin_layout Standard
Numba allows implementing custom NumPy 
\emph on
ufuncs
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
ufunc (NumPy universal function)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!universal function (ufunc)
\end_layout

\end_inset

 (universal functions) and 
\emph on
gufuncs
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
gufunc (NumPy generalized universal function)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!generalized universal function (gufunc)
\end_layout

\end_inset

 (generalized universal functions) in Python, without manually writing a
 C extension (which is the usual way to extend NumPy itself, in the rare
 case where that is needed).
\end_layout

\begin_layout Standard
As the user manual points out:
\end_layout

\begin_layout Standard

\emph on
You might ask yourself, “why would I go through this instead of compiling
 a simple iteration loop using the @jit decorator?”.
 The answer is that NumPy ufuncs automatically get other features such as
 reduction, accumulation or broadcasting.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://numba.pydata.org/numba-doc/0.30.1/user/vectorize.html"

\end_inset


\end_layout

\begin_layout Itemize

\emph on
ufunc
\emph default
: scalar in, scalar out, applied automatically elementwise.
\end_layout

\begin_layout Itemize

\emph on
gufunc
\emph default
: arrays in, arrays out, has a specific function signature (NumPy term)
 / input and output layout (Numba term).
\end_layout

\begin_deeper
\begin_layout Itemize
In NumPy, a 
\emph on
function signature
\emph default
 is what Numba calls the 
\emph on
layout string
\emph default
.
 This is the number of elements on each axis of an array, e.g.
 for a matrix product, we have
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

(m,n),(n,p)->(m,p)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

This is pretty much Einstein notation (compare 
\family typewriter
np.einsum
\family default
).
\end_layout

\begin_layout Itemize
In Numba on the other hand, a 
\emph on
function signature
\emph default
 indicates data types, including the number of array dimensions.
 For example,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family typewriter
void(float64[:,:], float64[:,:], float64[:,:])
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

is a signature: the function takes in three 2D float64 arrays, and returns
 
\family typewriter
void
\family default
 i.e.
 nothing (realistic if it operates on the data in-place).
\end_layout

\end_deeper
\begin_layout Itemize
See:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numba.pydata.org/numba-doc/0.30.1/reference/jit-compilation.html?#numba.vectorize"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://numba.pydata.org/numba-doc/0.30.1/reference/jit-compilation.html?#numba.guvectorize"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html#details-of-signature"

\end_inset


\end_layout

\begin_layout Itemize
Importantly: ufuncs and gufuncs 
\emph on
can operate on NumPy arrays
\end_layout

\begin_layout Itemize
This also leads to appropriate separation of concerns / modularity
\end_layout

\begin_deeper
\begin_layout Itemize
The calling code becomes simple, short, and to the point.
 The loop is an implementation detail.
\end_layout

\begin_layout Itemize
The function becomes generic, helping its reusability in future projects.
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Separation_of_concerns"

\end_inset


\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Separation of concerns (programming principle)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!principle!separation of concerns
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Cf.
 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Single_responsibility_principle"

\end_inset


\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Single responsibility principle (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!principle!single responsibility
\end_layout

\end_inset

 (for modules, classes)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cython
\end_layout

\end_inset

Cython
\end_layout

\begin_layout Standard
To properly cover Cython would require a separate course, so we will give
 only an overview, and some practical pointers.
\end_layout

\begin_layout Standard
Cython is a compiled language
\begin_inset Index idx
status open

\begin_layout Plain Layout
Compiled language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Language!compiled
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!language!compiled
\end_layout

\end_inset

 that produces Python modules — it is, essentially, a Python compiler.
 It is a classical ahead-of-time (AOT)
\begin_inset Index idx
status open

\begin_layout Plain Layout
AOT (ahead-of-time compiler)
\end_layout

\end_inset

 compiler, like compilers for 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

Fortran and C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

.
 However, the real point of Cython is that it facilitates manual optimization
 of implementation details (especially compute-heavy inherently serial algorithm
s), and allows connecting to existing C libraries; not that it also happens
 to be a static compiler for Python.
\end_layout

\begin_layout Standard
Stefan Behnel: A static Python compiler? What's the point?
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://blog.behnel.de/posts/indexp241.html"

\end_inset


\end_layout

\begin_layout Standard
Thus, in a scientific computing context, we may say that the main use case
 of Cython is that it is the Python equivalent of MATLAB's MEX
\begin_inset Index idx
status open

\begin_layout Plain Layout
MEX (MATLAB)
\end_layout

\end_inset

.
 For an example of using Cython in numerics to connect to existing C libraries,
 see 
\begin_inset Index idx
status open

\begin_layout Plain Layout
scikit-sparse
\end_layout

\end_inset

scikit-sparse, which provides Python bindings to CHOLMOD
\begin_inset Index idx
status open

\begin_layout Plain Layout
CHOLMOD
\end_layout

\end_inset

 via Cython.
\end_layout

\begin_layout Standard
From a language point of view, Cython is essentially 
\emph on
Python with C datatypes
\emph default
.
 It introduces static type checking, and type annotations.
 Cython also supports C++
\begin_inset Index idx
status open

\begin_layout Plain Layout
C++
\end_layout

\end_inset

 to some extent, but that is beyond the scope here.
\end_layout

\begin_layout Standard
Importantly, the static types are optional; any valid Python code is also
 valid Cython code.
 The way this works is that, when generating the C code, Cython translates
 any dynamically typed Python code into the equivalent calls to Python's
 C API (application programming interface)
\begin_inset Index idx
status open

\begin_layout Plain Layout
API (application programming interface)
\end_layout

\end_inset

.
 This typically leads to a speedup of approximately 30%, as the Python interpret
er is bypassed.
\end_layout

\begin_layout Standard
But much larger speedups, in the order of 
\begin_inset Formula $10^{2}\times$
\end_inset

, can be obtained in serial algorithms that only crunch numbers without
 accessing Python objects.
 Any Cython code that has the static types, and does not access Python objects
 (accessing data in NumPy arrays is allowed), is translated directly into
 C code — including any 
\family typewriter
for
\family default
 loops.
 Single-core performance of this is similar to Numba.
\end_layout

\begin_layout Subsubsection
Good to know
\end_layout

\begin_layout Standard
Cython is being actively developed, and new versions are released regularly.
 At the time of this writing (September 2017), the current version is Cython
\begin_inset space ~
\end_inset

0.27.
\end_layout

\begin_layout Standard
The Python installer 
\family typewriter
pip
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pip package manager
\end_layout

\end_inset

 knows how to install Cython, as a special case — that 
\emph on
is
\emph default
 special enough to break the rules — although Cython is not (only) a Python
 package.
 This is probably because many libraries, especially in the scientific Python
 software stack, depend on Cython to provide high performance.
 Practicality beats purity, again.
\end_layout

\begin_layout Standard
Incidentally, 
\family typewriter
pip install cython --upgrade --user
\family default
 is the best practical way to stay up to date.
\end_layout

\begin_layout Standard
Cython source files have the file extension .pyx, after 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pyrex (predecessor of Cython)
\end_layout

\end_inset

Pyrex, an earlier project Cython is based on.
\end_layout

\begin_layout Standard
Cython provides parallel for loops via OpenMP, in code that does not access
 Python objects; just like the "parallel" target of Numba.
\end_layout

\begin_layout Standard
Cython code is first compiled to C (using Cython itself), which is then
 compiled to machine code (typically using GCC, the GNU C Compiler) and
 placed into a dynamically linked library (.dll, .so).
 This library can then be imported into Python just like any Python module.
\end_layout

\begin_layout Standard
In projects based on Cython, binaries can be easily distributed.
 Once the code is compiled, the produced binaries are independent of Cython.
\end_layout

\begin_layout Standard
Also the generated C source code does not strictly require Cython.
 However, for purposes of archiving the project source code, it is better
 to treat the C file strictly as a generated file (does not need to be stored
 in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Version control
\end_layout

\end_inset

version control!), as it is not even meant to be human-editable.
\end_layout

\begin_layout Standard
The fact that Cython's 
\emph on
intermediate representation
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Intermediate representation (compilers)
\end_layout

\end_inset

 happens to be text, and in a programming language also humans use, is just
 an implementation detail.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Intermediate_representation"

\end_inset


\family default

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Tuning the C compilation step
\end_layout

\begin_layout Standard
Binaries are compiled for a generic architecture such as 
\family typewriter
x86_64
\family default
.
 It is possible to use processor family specific options such as 
\family typewriter
-msse2
\family default
 in the C compilation step.
 For example, I have used the following GCC options for my modules involving
 math functions:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

-march=native -O2 -msse -msse2 -mfma -mfpmath=sse
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

In scientific computing, 
\series bold
do not use
\series default
 
\family typewriter
-ffast-math
\family default
, unless you know exactly what you are doing; because if you do, the compiler
 is then allowed to make approximations that, in many non-scientific contexts,
 do not usually affect the result significantly.
\end_layout

\begin_layout Standard
Here 
\family typewriter
-mfma
\family default
 is relatively new; it allows the compiler to use the processor's 
\emph on
fused-multiply-add
\emph default
 (FMA)
\begin_inset Index idx
status open

\begin_layout Plain Layout
FMA (fused multiply add)
\end_layout

\end_inset

 instruction, if it has one.
 This is an efficient daxpy
\begin_inset Index idx
status open

\begin_layout Plain Layout
daxpy
\end_layout

\end_inset

 (double precision 
\begin_inset Formula $ax+y$
\end_inset

) which rounds only once, so it is usually good for both speed and accuracy.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation"

\end_inset


\end_layout

\begin_layout Subsubsection
Viewing the generated C source
\end_layout

\begin_layout Standard
Although the generated C source is not meant to be human-
\emph on
editable
\emph default
, it is certainly human-
\emph on
readable
\emph default
.
 For debugging and performance-tuning purposes, it is sometimes useful to
 examine the generated code, as it allows you to see exactly what Cython
 has done.
 To make the most use of it, search 
\series bold
the generated C source file
\series default
 for (parts of) lines of your actual Cython program — it 
\series bold
includes your original Cython code in the comments
\series default
.
\end_layout

\begin_layout Standard
You may be interested also in the command
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

cython -a myfile.pyx
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

The 
\family typewriter
-a
\family default
 stands for 
\begin_inset Quotes eld
\end_inset

annotate
\begin_inset Quotes erd
\end_inset

.
 This takes in your Cython source 
\family typewriter
myfile.pyx
\family default
, and produces 
\family typewriter
myfile.html
\family default
, which can be opened in a web browser, and similarly contains both the
 Cython source and the generated C source, but in an interactive form.
\end_layout

\begin_layout Standard
In the .html file, Cython source lines can be clicked to show the corresponding
 generated code, and the shading of each line of Cython shows how much code
 it generated.
 This allows a quick visual inspection of things such as whether a loop
 has become an efficient C loop as intended — and if not, what has gone
 wrong.
\end_layout

\begin_layout Standard
For example, the generated C code shows which arrays are still accessed
 using the memoryview API, instead of C-style pointer arithmetic.
 This, in turn, tells you that those arrays are likely missing a static
 type declaration, or have been assumed (maybe implicitly!) to have a memory
 layout that does not allow calculating memory offsets of elements directly
 (e.g.
 
\family typewriter
cython.view.general
\family default
).
 Or maybe a loop counter, or some other integer, is missing a static type
 declaration, and is being treated as a Python object.
\end_layout

\begin_layout Subsubsection
cimport vs.
 import
\end_layout

\begin_layout Standard
Beside .pyx source files, there are also .pxd files, which are Cython's 
\emph on
header files
\emph default
, somewhat analogous to .h files in the C language.
 However, .pxd files are only needed for declaring the C-level public API;
 they are only used to export functions (and constants) to other Cython
 modules.
\end_layout

\begin_layout Standard
To import functions from a .pxd, Cython uses the keyword 
\begin_inset Index idx
status open

\begin_layout Plain Layout
cimport (Cython keyword)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!cimport (Cython)
\end_layout

\end_inset


\family typewriter
cimport
\family default
, to distinguish this from loading Python modules with the standard keyword
 
\family typewriter
import
\family default
.
\end_layout

\begin_layout Standard
Or in other words: 
\family typewriter
cimport
\family default
 brings in compile-time information, essentially for things visible at the
 Cython level — i.e.
 things that are not visible to regular Python modules.
 It essentially works like the 
\family typewriter
#include
\family default
 directive of C.
 The regular 
\family typewriter
import
\family default
 brings in Python modules, as usual.
\end_layout

\begin_layout Standard
The same module may be both 
\family typewriter
import
\family default
ed and 
\family typewriter
cimport
\family default
ed, either 
\family typewriter
as
\family default
 the same name or 
\family typewriter
as
\family default
 different names; just keep in mind that these do different things.
 To reiterate:
\end_layout

\begin_layout Itemize

\family typewriter
cimport
\family default
 loads the .pxd file (Cython header file)
\end_layout

\begin_layout Itemize

\family typewriter
import
\family default
 loads a Python module
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

As an example, consider the following two ways to create a parallel 
\family typewriter
for
\family default
 loop in Cython
\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Concurrency (parallel computing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
nogil (Cython keyword)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Keyword!nogil (Cython)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel loop (Cython)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
for loop!parallel (Cython)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
GIL (global interpreter lock)
\end_layout

\end_inset

.
 This is equivalent to 
\begin_inset Index idx
status open

\begin_layout Plain Layout
parfor (MATLAB)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset

MATLAB's 
\family typewriter
parfor
\family default
.
 First, using 
\family typewriter
cimport
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

cimport cython.parallel
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def f():
\end_layout

\begin_layout Plain Layout

    cdef int j
\end_layout

\begin_layout Plain Layout

    with nogil:  # <-- GIL is now released, and re-acquired when this block
 exits.
\end_layout

\begin_layout Plain Layout

       # (no Python objects allowed in this block)
\end_layout

\begin_layout Plain Layout

       # OpenMP parallel loop
\end_layout

\begin_layout Plain Layout

       for j in cython.parallel.prange(20):
\end_layout

\begin_layout Plain Layout

            do_stuff(j)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, we may use a Python-level 
\family typewriter
import
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import cython.parallel
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def f():
\end_layout

\begin_layout Plain Layout

    cdef int j
\end_layout

\begin_layout Plain Layout

    # prange(..., nogil=True) instructs Cython to "with nogil" the loop internally.
\end_layout

\begin_layout Plain Layout

    for j in cython.parallel.prange(20, nogil=True):
\end_layout

\begin_layout Plain Layout

        # (no Python objects allowed in this loop)
\end_layout

\begin_layout Plain Layout

        do_stuff(j)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On parallel computing with OpenMP in Cython, see:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://cython.readthedocs.io/en/latest/src/userguide/parallelism.html"

\end_inset


\end_layout

\begin_layout Subsubsection
Cython-level compiler directives
\end_layout

\begin_layout Standard
For optimizing the perfomance of Cython code, it may be useful to turn off
 support for negative indices (wraparound) and memory access safety (bounds
 checking) — once you are sure that your code is bug-free — because then,
 any invalid indexing will lead to silent data corruption, or in the best
 case, a crash.
\end_layout

\begin_layout Standard
Also to improve performance of Cython code, it is useful to change the division
 operator 
\family typewriter
/
\family default
 to use C semantics.
 This leads to integer division if both inputs are 
\family typewriter
int
\family default
, and also disables Python's division-by-zero checking.
\end_layout

\begin_layout Standard
Per function, by decorator
\begin_inset Index idx
status open

\begin_layout Plain Layout
Decorator!
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

cython.* (compiler directives)
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

cimport cython
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@cython.wraparound(False)
\end_layout

\begin_layout Plain Layout

@cython.boundscheck(False)
\end_layout

\begin_layout Plain Layout

@cython.cdivision(True)
\end_layout

\begin_layout Plain Layout

def f():
\end_layout

\begin_layout Plain Layout

    pass  # do whatever here
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per file, as magic comments
\begin_inset Index idx
status open

\begin_layout Plain Layout
Magic!comment, Cython compiler options
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# Set Cython compiler directives.
 This section must appear before any code!
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# cython: wraparound  = False
\end_layout

\begin_layout Plain Layout

# cython: boundscheck = False
\end_layout

\begin_layout Plain Layout

# cython: cdivision   = True 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

For a full list of available directives, and their explanations, see:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://docs.cython.org/en/latest/src/reference/compilation.html"

\end_inset


\end_layout

\begin_layout Subsubsection
Interacting with NumPy arrays in Cython
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cython!NumPy arrays in
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
NumPy!array!in Cython
\end_layout

\end_inset


\end_layout

\begin_layout Standard
NumPy arrays are a special case in that accessing data in them does not
 require Python object manipulation.
 The data is accessed through 
\emph on
typed memoryviews
\emph default
.
 User manual (very comprehensive):
\begin_inset Index idx
status open

\begin_layout Plain Layout
Typed memoryview
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Memoryview, typed
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html"

\end_inset


\end_layout

\begin_layout Standard
For the curious, on the Python side:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/stdtypes.html#memoryview"

\end_inset


\end_layout

\begin_layout Standard
Previously, there was a buffer interface specific to NumPy arrays, which
 has now been replaced by the newer, and more general, typed memoryviews.
 The old interface is 
\emph on
deprecated
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Deprecation (software term)
\end_layout

\end_inset

 i.e.
 is now obsolete, and may be removed in the future.
\end_layout

\begin_layout Standard
As of late 2017, any documentation that instructs you to 
\family typewriter
cimport numpy
\family default
 and use 
\series bold
syntax like
\end_layout

\begin_layout Standard

\family typewriter
np.ndarray[np.float64_t, ndim=2]
\end_layout

\begin_layout Standard

\series bold
is outdated
\series default
, and refers to the deprecated API.
\end_layout

\begin_layout Standard
The cimport is no longer needed, and the 
\series bold
current syntax
\series default
 looks like a hybrid between 
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

C, and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fortran
\end_layout

\end_inset

Fortran for allocatable arrays:
\end_layout

\begin_layout Standard

\family typewriter
double[:,:]
\end_layout

\begin_layout Standard
(There is still a lot of documentation and code examples using the old API.)
\end_layout

\begin_layout Standard
If you want to use some advanced features of memoryviews, you may need to:
\end_layout

\begin_layout Standard

\family typewriter
from cython cimport view
\end_layout

\begin_layout Standard
Especially 
\family typewriter
view.generic
\family default
 is useful to specify that you want your function to accept an arbitrary
 sliced axis.
 See the Cython manual section on memoryviews, linked above.
\end_layout

\begin_layout Standard
The new API has brought with it one further important technical detail.
 If you return a memoryview object from a Cython function, Python will see
 it as a memoryview object, not as a NumPy array — even if it actually points
 to an underlying NumPy array.
 This is due to the static type declaration: the type of the variable is
 memoryview.
\end_layout

\begin_layout Standard
To make your Python code see the NumPy array, 
\family typewriter
return np.asanyarray(v)
\family default
 instead (where 
\family typewriter
v
\family default
 is your memoryview object).
 A silly example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# The "step of 1" is special Cython syntax to specify the memory layout.
\end_layout

\begin_layout Plain Layout

# See the Cython manual section on memoryviews.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

# Here the array A is C-contiguous.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

def matrix_vector_product(double[:,::1] A, double[::1] b):
\end_layout

\begin_layout Plain Layout

    # LHS: Cython memoryview syntax; RHS: pure Python
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Note that memoryviews have "shape" and "ndim".
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # shape can be subscripted: shape[0], shape[1], ..., shape[ndim-1].
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Note also that as long as we do not need to allocate memory
\end_layout

\begin_layout Plain Layout

    # inside a "with nogil" block, we can essentially use NumPy
\end_layout

\begin_layout Plain Layout

    # as an allocator for dynamically sized arrays.
 Hence, usually
\end_layout

\begin_layout Plain Layout

    # there is no need to bother with the traditional malloc()/free().
\end_layout

\begin_layout Plain Layout

    # As a bonus, NumPy arrays use Python's automatic memory management.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    cdef double[:] x = np.zeros(b.shape, dtype=np.float64)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Everything here has a static type, so this will be automatically
\end_layout

\begin_layout Plain Layout

    # compiled into an efficient C loop.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Our A is C-contiguous, so we make the inner loop run over columns.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    cdef int n = A.shape[0]
\end_layout

\begin_layout Plain Layout

    cdef int m = A.shape[1]
\end_layout

\begin_layout Plain Layout

    cdef int i, j
\end_layout

\begin_layout Plain Layout

    for i in range(n):
\end_layout

\begin_layout Plain Layout

        for j in range(m):
\end_layout

\begin_layout Plain Layout

            x[i] += A[i,j] * b[j]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # x is a memoryview; return a NumPy array.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # This will create a new np.array object, but without copying the data;
\end_layout

\begin_layout Plain Layout

    # the new np.array will point to the same memory as the original one.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    return np.asanyarray(x)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Compiling Cython programs
\end_layout

\begin_layout Standard
In practice, the easiest way to do compile Cython programs is to control
 Cython via a 
\family typewriter
setuptools
\begin_inset Index idx
status open

\begin_layout Plain Layout
setuptools
\end_layout

\end_inset


\family default
-based 
\family typewriter
setup.py
\family default
.
\end_layout

\begin_layout Standard
We will skip the details here, and just note that on GitHub, there are 
\family typewriter
setuptools
\family default
-based 
\family typewriter
setup.py
\family default
 templates for Cython projects:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/thearn/simple-cython-example"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Technologicat/setup-template-cython/"

\end_inset


\end_layout

\begin_layout Standard
which can be quickly customized for your own project.
\end_layout

\begin_layout Standard
Maybe also useful:
\end_layout

\begin_layout Itemize
The Cython manual includes material on using the older 
\family typewriter
distutils
\family default
 (which 
\family typewriter
setuptools
\family default
 is based on and extends):
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://docs.cython.org/en/latest/src/reference/compilation.html"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://docs.cython.org/en/latest/src/userguide/source_files_and_compilation.html#distributing-cython-modules"

\end_inset


\end_layout

\begin_layout Itemize
Search path for include files (.pxd):
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://cython.readthedocs.io/en/latest/src/userguide/sharing_declarations.html"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://stackoverflow.com/questions/4505747/how-should-i-structure-a-python-package-that-contains-cython-code"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/cython/cython/wiki/PackageHierarchy"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Slightly outdated, should use 
\family typewriter
include_path
\family default
 option of 
\family typewriter
cythonize()
\family default
 instead.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Virtual environments
\begin_inset Index idx
status open

\begin_layout Plain Layout
Virtual!environment (software installation)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will not go into details; this is just something to be aware of.
 
\emph on
Virtual environments
\emph default
 are an approach to software installation that allows to:
\end_layout

\begin_layout Itemize
Isolate the Python environment from the OS.
\end_layout

\begin_deeper
\begin_layout Itemize
Hence, install anything to it while avoiding conflicts with system-level
 Python on *nix (Linux, OS X).
\end_layout

\end_deeper
\begin_layout Itemize
Install a Python-based app and libraries, 
\emph on
and leave it be
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Installing upgrades to libraries could, in theory, break the app.
 This may be a problem if you need those upgraded libraries for another
 app, or for your own programming work.
\end_layout

\end_deeper
\begin_layout Itemize
Run several different versions of Python.
\end_layout

\begin_deeper
\begin_layout Itemize
This is useful for library and application developers, as it helps testing
 against different configurations.
\end_layout

\end_deeper
\begin_layout Itemize
virtualenv is a popular tool for this:
\family sans
 
\begin_inset CommandInset href
LatexCommand href
target "https://pypi.python.org/pypi/virtualenv"

\end_inset


\end_layout

\begin_layout Itemize
Python
\begin_inset space ~
\end_inset

3.3 and later have the 
\family typewriter
venv
\family default
 module: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/venv.html#module-venv"

\end_inset


\end_layout

\begin_layout Itemize
virtualenv, pyenv, virtualenvwrapper, pipenv, ...
 For a list and descriptions, see:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/41573588"

\end_inset


\end_layout

\begin_layout Subsection
Hash table: note on Python dictionaries and sets
\begin_inset Index idx
status open

\begin_layout Plain Layout
Hash!table
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Python dictionaries can, effectively, use (almost) arbitrary objects for
 indexing.
 How is this possible?
\end_layout

\begin_layout Standard
Short answer: 
\emph on
hash table
\emph default
.
\end_layout

\begin_layout Standard
Long answer:
\end_layout

\begin_layout Standard
In information technology, a 
\emph on
hash
\emph default
 is a kind of checksum (like CRC32, MD5, SHA-1).
 Essentially, it is a 
\emph on
one-way function
\emph default
 that maps arbitrary-length data into a number, usually of much shorter
 length (in terms of required data storage) than the data.
\end_layout

\begin_layout Standard
Dictionary keys — and items in 
\family typewriter
set
\family default
s in Python — must be 
\emph on
hashable
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Hashable
\end_layout

\end_inset

 In programming languages, and in Python in particular, 
\emph on
hashable
\emph default
 means that the object has the ability to create a hash value (integer)
 from the data contained in it.
 Essentially, it implements a 
\family typewriter
__hash__()
\family default
 method.
 Java
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java
\end_layout

\end_inset

 programmers are likely familiar with this.
\end_layout

\begin_layout Standard
Object instances that compare equal (
\family typewriter
==
\family default
) must have the same hash value.
\end_layout

\begin_layout Standard
Only immutable objects can be hashable, because Python assumes that the
 hash value for any given object instance remains constant.
\end_layout

\begin_layout Standard
A 
\emph on
hash table
\emph default
, then, is a data structure that stores key-value pairs for fast (
\begin_inset Formula $O(1)$
\end_inset

 time) lookup.
\end_layout

\begin_layout Standard
By the 
\emph on
pigeonhole principle
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Pigeonhole principle (hashing)
\end_layout

\end_inset

 — or in plain English, because the space of hashes is (much) smaller than
 the space of data — there will be 
\emph on
hash collisions
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Hash!collision
\end_layout

\end_inset

, i.e.
 several different data will inevitably hash to the same value.
\end_layout

\begin_layout Standard
However, a well-designed hash function 
\emph on
distributes
\emph default
 well, so that collisions for sensible real-world data are rare.
 Nevertheless, to make hash tables robust, they must in practice include
 a mechanism to be able to handle hash collisions.
\end_layout

\begin_layout Standard
Incidentally, Linux uses hashing for storing user passwords — i.e.
 the actual passwords are never written anywhere.
 The user is authenticated by comparing the hash of the user-entered password
 to the stored one.
 This is very secure as long as the password is not easy to guess, as (given
 a good hash function) entering an incorrect password gives practically
 no information about the correct one.
\end_layout

\begin_layout Standard
For more, see:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/reference/datamodel.html#object.__hash__"

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/2909106/whats-a-correct-and-good-way-to-implement-hash"

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Hash_table"

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://wiki.python.org/moin/TimeComplexity"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Loop counters, lambdas
\begin_inset Index idx
status open

\begin_layout Plain Layout
Anonymous function (lambda)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Lambda (anonymous function)
\end_layout

\end_inset

, and functional programming
\begin_inset Index idx
status open

\begin_layout Plain Layout
Functional programming
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!functional
\end_layout

\end_inset

 in Python
\end_layout

\begin_layout Standard
Consider this code:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

funcs = [ lambda x: i*x for i in range(5) ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

What happens when we apply the created functions and print the result?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

y = [ f(2) for f in funcs ]  # apply each func to x=2
\end_layout

\begin_layout Plain Layout

print(y)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

In this example, we get 
\family typewriter
[8, 8, 8, 8, 8]
\family default
.
 Why?
\end_layout

\begin_layout Standard
This is because the 
\family typewriter
i
\family default
 appears inside the body of the 
\family typewriter
lambda
\family default
 (which is a function definition).
 Technically speaking, what here gets saved to the list 
\family typewriter
funcs
\family default
 is not a bare function, but a 
\emph on
closure
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Closure (programming)
\end_layout

\end_inset

.
 In plain English, it contains information about the scope it had when it
 was created (including information about names that were visible at that
 time).
 
\end_layout

\begin_layout Standard
Python then captures the 
\emph on
name
\emph default
 
\family typewriter
i
\family default
 instead of its value.
 Or, in other words:
\end_layout

\begin_layout Standard

\emph on
Python’s closures are 
\emph default
late binding.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Binding, late (closures)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Late binding (closures)
\end_layout

\end_inset

 
\emph on
This means that the values of variables used in closures are looked up at
 the time the inner function is called.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://docs.python-guide.org/en/latest/writing/gotchas/"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Closure_(computer_programming)"

\end_inset


\end_layout

\begin_layout Standard
Thus all the closures that were saved to the list captured the same 
\family typewriter
i
\family default
.
\end_layout

\begin_layout Standard
How to get around this? There are at least three ways to persuade Python
 to bind early, i.e.
 to pass in the value instead of the name.
\end_layout

\begin_layout Standard
The first solution is to exploit the fact that, as we already saw above,
 default arguments grab the value at function definition time:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

funcs = [ lambda x,i=i: i*x for i in range(5) ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

With this modification, we get 
\family typewriter
[0, 2, 4, 6, 8]
\family default
, as expected.
\end_layout

\begin_layout Standard
In the lambda, the 
\family typewriter
i
\family default
 on the LHS of the assignment (and in the body) is the formal argument name,
 while the one on the RHS of the assignment is the loop counter.
 Or in other words, we could as well write:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

funcs = [ lambda x,j=i: j*x for i in range(5) ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

For clarity, we will below use 
\family typewriter
j
\family default
 to indicate where it is independent of 
\family typewriter
i
\family default
.
\end_layout

\begin_layout Standard
If that solution feels unnecessarily hacky (it's a matter of aesthetics,
 but I think it does: what if someone passes in another value for 
\family typewriter
j
\family default
?), another way is to use the 
\emph on
factory pattern
\emph default
.
\end_layout

\begin_layout Standard
A 
\emph on
function factory
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Factory pattern (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Function factory (pattern)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Pattern!function factory
\end_layout

\end_inset

 — as the name suggests — is a function that creates functions.
 Roughly speaking, you call it with a value for 
\family typewriter
j
\family default
, and it returns a function (of 
\family typewriter
x
\family default
) that uses this value.
 Applying the idea to the present example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def make_f(j):
\end_layout

\begin_layout Plain Layout

    return lambda x: j*x
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

funcs = [ make_f(i) for i in range(5) ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This works, because the loop calls the function factory, 
\emph on
passing in the current value
\emph default
 of 
\family typewriter
i
\family default
.
 Also, now there is no room for a bug, because the created functions have
 only one argument, namely 
\family typewriter
x
\family default
.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
The code can be slightly shortened by using the lambda notation for the
 function factory.
 Now the outer 
\family typewriter
lambda
\family default
, when called, returns the inner 
\family typewriter
lambda
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

make_f = lambda j: lambda x: j*x   # same as lambda j: (lambda x: j*x)
\end_layout

\begin_layout Plain Layout

funcs  = [ make_f(i) for i in range(5) ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This can be further compacted onto one line:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

funcs = [ (lambda j: lambda x: j*x)(i) for i in range(5) ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which you may sometimes see in the wild.
 This one-liner creates an 
\emph on
anonymous
\emph default
 function factory, calls it, and — because it then falls out of scope having
 no name associated with it — discards it when the loop is done.
\end_layout

\begin_layout Standard
The third solution is to bind explicitly using 
\family typewriter
functools.partial
\family default
 (partial application
\begin_inset Index idx
status open

\begin_layout Plain Layout
functools (module)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Partial application (of function arguments)
\end_layout

\end_inset

 of function arguments).
 For example:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

from functools import partial
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def f(i,x):
\end_layout

\begin_layout Plain Layout

    return i*x
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

funcs = [partial(f, i) for i in range(5)]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this particular (rather silly) example, we may even use the fact that
 our 
\family typewriter
f()
\family default
 is nothing but a multiplication
\begin_inset Index idx
status open

\begin_layout Plain Layout
Multiplication!operator, as a function
\end_layout

\end_inset

, which is already in the standard library
\begin_inset Index idx
status open

\begin_layout Plain Layout
operator (module in standard library)
\end_layout

\end_inset

, which saves us the trouble of defining 
\family typewriter
f()
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

from functools import partial
\end_layout

\begin_layout Plain Layout

from operator import mul  # mul(a,b) is the same as a*b
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

funcs = [partial(mul, i) for i in range(5)]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
See:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/functools.html#functools.partial"

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/operator.html#mapping-operators-to-functions"

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Partial_application"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Order-preserving uniqification (discarding duplicates) of a list of items
\begin_inset Index idx
status open

\begin_layout Plain Layout
Uniqification (discarding duplicates)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Discarding duplicates (uniqification)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is possible to use 
\family typewriter
set
\family default
 to uniqify (hashable) items stored in an iterable.
 Let 
\family typewriter
L
\family default
 be a list.
\end_layout

\begin_layout Standard
If the ordering of the items does not matter, this is trivial:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

L = list(set(L))
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

But what to do if we want to preserve the ordering?
\end_layout

\begin_layout Standard
The obvious idea is to use a 
\family typewriter
set
\family default
 to keep track of which values we have seen so far, and then just append
 each unique item into another 
\family typewriter
list
\family default
 in a loop, like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

tagged = set()
\end_layout

\begin_layout Plain Layout

tmp = []
\end_layout

\begin_layout Plain Layout

for x in L:
\end_layout

\begin_layout Plain Layout

    if x not in tagged:
\end_layout

\begin_layout Plain Layout

        tmp.append(x)
\end_layout

\begin_layout Plain Layout

        tagged.add(x)
\end_layout

\begin_layout Plain Layout

L = tmp
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But that's a bit long.
 Using a list comprehension
\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset

, this can be compacted to:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

tagged = set()
\end_layout

\begin_layout Plain Layout

def tag(x):  # set.add() returns None, so make an expression version of add.
\end_layout

\begin_layout Plain Layout

    tagged.add(x)
\end_layout

\begin_layout Plain Layout

    return x
\end_layout

\begin_layout Plain Layout

L = [ tag(x) for x in L if x not in tagged ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which should also run faster, since using a list comprehension instead of
 an explicit loop gives shorter bytecode (as we will see).
 But there is now the overhead of a function call to 
\family typewriter
tag()
\family default
, whereas the previous version performed the operations directly in the
 loop.
\end_layout

\begin_layout Standard
Playing code golf
\begin_inset Index idx
status open

\begin_layout Plain Layout
Code golf
\end_layout

\end_inset

 (and maybe pushing the limits of readability), we may also express the
 same idea as:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

tagged = set()
\end_layout

\begin_layout Plain Layout

L = [ tagged.add(x) or x for x in L if x not in tagged ]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which gets rid of the extra function call (and gets us a birdie).
\end_layout

\begin_layout Standard
How does this version work? The item part of the list comprehension must
 tag the value of 
\family typewriter
x
\family default
 as seen as a side effect
\begin_inset Index idx
status open

\begin_layout Plain Layout
Side effect (programming)
\end_layout

\end_inset

, but it must also evaluate to 
\family typewriter
x
\family default
 as an expression
\begin_inset Index idx
status open

\begin_layout Plain Layout
Expression (programming)
\end_layout

\end_inset

, because the result of this expression is what gets appended to the list
 being built.
 However, 
\family typewriter
help(set)
\family default
 tells us that 
\family typewriter
set.add()
\family default
 returns 
\family typewriter
None
\family default
.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
or x
\family default

\begin_inset Quotes erd
\end_inset

 fixes this problem.
 The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Truth value!of None
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
None (special value)!truth value of
\end_layout

\end_inset

truth value of 
\family typewriter
None
\family default
 is 
\family typewriter
False
\family default
; so the 
\family typewriter
or
\family default
 must evaluate also its second argument, which will be left standing as
 the value of the expression.
\end_layout

\begin_layout Standard
Following Python's strong typing, the mere presence of 
\family typewriter
or
\family default
 does not convert the result to 
\family typewriter
bool
\family default
; instead, Python tests the truthiness of the object.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Strongly typed language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
or operator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Operator!logical
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Logic operators
\end_layout

\end_inset

 As was already noted in the section on tips and tricks, for the exact rules
\begin_inset Index idx
status open

\begin_layout Plain Layout
Truth value!of an object
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Testing truth value of an object
\end_layout

\end_inset

 on how objects behave in logical expressions in Python, see:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/stdtypes.html#truth-value-testing"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Graphical user interfaces
\begin_inset Index idx
status open

\begin_layout Plain Layout
Graphical user interface (GUI)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
GUI (graphical user interface)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The history of graphical user interfaces (GUIs) can be traced back to the
 CAD program Sketchpad in 1963.
 The mouse was introduced in the late
\begin_inset space ~
\end_inset

1960s.
 Some readers may have heard of the early GUI research at Xerox PARC in
 the 1960s and 1970s.
\end_layout

\begin_layout Standard
The main mode of mainstream human–computer interaction, for well over 20
 years, have been graphical user interfaces in one form or another.
 Hence, just for general education, we will very briefly explain the two
 main technical ideas behind GUIs.
\end_layout

\begin_layout Standard
The first thing to know is that 
\series bold
GUIs are event-driven
\series default
.
 When an application starts, its 
\family typewriter
main()
\family default
 function typically first initializes the GUI layout, either by a series
 of function calls that instantiate the GUI elements, or by loading the
 layout from a file.
\end_layout

\begin_layout Standard
It then calls the 
\emph on
event loop
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
GUI (graphical user interface)!event loop
\end_layout

\end_inset

 provided by the GUI toolkit.
 At this point the control flow of the main thread becomes non-linear (event-dri
ven), dependent on the user's actions.
 For example, when the user clicks a button, the event loop calls the 
\emph on
event handler
\emph default
 (a function in the application code) that in that particular GUI is attached
 to that button.
\end_layout

\begin_layout Standard
Another typical kind of GUI event is a timer, which triggers after a set
 period of time has elapsed.
 Timers are used for both single-shot and periodic cases.
 Timer events may occur late, if the main thread was doing something else
 at the exact time the timer should have triggered.
\end_layout

\begin_layout Standard
Animated GUIs, perhaps due to popular influence of OS X, are becoming more
 common.
 This improves the user experience especially for onlookers, because they
 lack the added context of the "driver's seat".
 Typically, GUI animations work by instantiating an animation object, and
 asking the GUI toolkit to schedule it to run.
 This is somewhat automated in some GUI toolkits.
\end_layout

\begin_layout Standard
Important properties to note are that:
\end_layout

\begin_layout Itemize
While the app is running, control of the main thread returns to application
 code 
\emph on
only during event handlers
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
When the user quits the application, the event loop returns (terminates).
 The rest of 
\family typewriter
main()
\family default
 performs any app-specific shutdown operations (unless an event handler
 for the quit event already did that).
\end_layout

\end_deeper
\begin_layout Itemize
The GUI blocks the main thread from doing anything else.
 Conversely, if the main thread computes something (in an event handler),
 this blocks the GUI, making the application appear unresponsive to the
 OS until the computation finishes.
\end_layout

\begin_deeper
\begin_layout Itemize
Therefore, any lengthy computation in a GUI application should be performed
 in a separate thread.
 When finished, the thread should
\emph on
 send an event
\emph default
 indicating that the computation is done.
 The main thread can then trigger on this event to display the results in
 the user interface.
\end_layout

\end_deeper
\begin_layout Itemize
Operations interacting with GUI elements are typically safe to invoke only
 from the main thread.
\end_layout

\begin_layout Standard
The other thing to know is the 
\series bold
model–view–controller (MVC) pattern
\series default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pattern!MVC (model, view, controller)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
MVC pattern (model, view, controller)
\end_layout

\end_inset

 This is a modular design that prevents the application code from becoming
 spaghetti.
\end_layout

\begin_layout Itemize
The 
\series bold
model
\series default
 is 
\emph on
data and operations on the data
\emph default
.
 Essentially, your solver code goes here.
\end_layout

\begin_layout Itemize
The 
\series bold
view
\series default
 contains the 
\emph on
GUI representation
\emph default
 that displays the data, and the user interface that allows the user to
 interact with it.
 Several views to the same data may exist simultaneously.
\end_layout

\begin_deeper
\begin_layout Itemize
This is convenient to e.g.
 provide an overall view and a zoomed-in view at the same time, while making
 sure that both views correctly reflect any changes to the data.
\end_layout

\end_deeper
\begin_layout Itemize
The 
\series bold
controller
\series default
 
\emph on
coordinates operations between the model and the view
\emph default
.
 The controller responds to the user's actions on the view, sending commands
 to the model.
 Also conversely, the controller responds to changes in the model, sending
 commands to the view.
\end_layout

\begin_layout Standard
The MVC is an early design pattern.
 Nowadays more sophisticated variants are available; but perhaps this is
 enough for general education.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Graphical_user_interface"

\end_inset


\end_layout

\begin_layout Subsubsection
GUI libraries
\begin_inset Index idx
status open

\begin_layout Plain Layout
GUI (graphical user interface)!Python libraries for
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you want to play around with writing simple GUI apps, you can use at
 least one of:
\end_layout

\begin_layout Itemize
PyQt
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyQt
\end_layout

\end_inset

 [Windows, Linux, OS X, Android, iOS]
\end_layout

\begin_deeper
\begin_layout Itemize
Qt: classical, widely used for the desktop.
 Started in 1995.
\end_layout

\begin_layout Itemize
As an example, the Spyder IDE
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset

 is based on PyQt.
\end_layout

\begin_layout Itemize
For plotting in a Qt GUI, possible to use PyQtGraph
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyQtGraph
\end_layout

\end_inset

.
 (Runs on PyQt5.)
\end_layout

\begin_layout Itemize
Be sure to use the current PyQt5.
 The old PyQt4 is legacy; Qt4 is no longer supported.
\end_layout

\begin_layout Itemize
PySide
\begin_inset Index idx
status open

\begin_layout Plain Layout
PySide
\end_layout

\end_inset

 also used to provide Qt for Python, but PyQt seems more actively maintained.
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://riverbankcomputing.com/software/pyqt/intro"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://github.com/pyqtgraph/pyqtgraph"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://wiki.qt.io/PySide"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Qt_(software)"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
PyGTK
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyGTK
\end_layout

\end_inset

 [Windows, Linux, OS X]
\end_layout

\begin_deeper
\begin_layout Itemize
GTK+: classical, widely used for the desktop.
 Started in 1998.
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://www.pygtk.org/"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/GTK%2B"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Kivy
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kivy
\end_layout

\end_inset

 [Windows, Linux, OS X, Android, iOS]
\end_layout

\begin_deeper
\begin_layout Itemize
Main target smartphones, but applications can run unmodified also on PCs.
 Started in 2011.
\end_layout

\begin_layout Itemize
Multitouch support out of the box, great for mobile apps.
\end_layout

\begin_deeper
\begin_layout Itemize
Matplotlib integration available, but only on PC.
 VisPy for mobile.
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://kivy.org/"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Kivy_(framework)"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Intimidating full list of Python GUI toolkits (unfortunately, partly out
 of date):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://wiki.python.org/moin/GuiProgramming"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Kivy
\end_layout

\begin_layout Standard
In principle, being able to run the same code on PC and smartphones sounds
 promising.
 Let's quickly try Kivy.
\end_layout

\begin_layout Standard
On the project website 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://kivy.org/"

\end_inset


\family default
 , there is this hello-world example:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

from kivy.app import App
\end_layout

\begin_layout Plain Layout

from kivy.uix.button import Button
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class TestApp(App):
\end_layout

\begin_layout Plain Layout

    def build(self):
\end_layout

\begin_layout Plain Layout

        return Button(text='Hello World')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

TestApp().run()
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
TestApp
\family default
 is the class that represents the application.
 Its ancestor 
\family typewriter
App
\family default
 defines a method 
\family typewriter
run()
\family default
, which will call 
\family typewriter
build()
\family default
 and then enter the event loop.
\end_layout

\begin_layout Itemize
The method 
\family typewriter
build()
\family default
 is implemented in the application code, and it defines the GUI layout.
 In this extremely simple example, we get just one button that covers the
 whole window, and does nothing (no event handler).
\end_layout

\begin_layout Itemize
Add-on for Matplotlib integration:
\end_layout

\begin_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy-garden/garden.matplotlib"

\end_inset


\end_layout

\begin_layout Itemize
The documentation is embedded in 
\family typewriter
backend_kivy.py
\family default
.
\end_layout

\begin_layout Itemize
To install, basically
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

pip install kivy-garden --user
\end_layout

\begin_layout Plain Layout

garden install matplotlib
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Usage examples provided in 
\family typewriter
examples/
\family default
 subfolder at the GitHub page.
\end_layout

\begin_layout Itemize
As of late 2017, minor issues:
\end_layout

\begin_deeper
\begin_layout Itemize
The figure settings window is not implemented, but the toolbar button itself
 comes from Matplotlib and cannot be (easily) hidden.
\end_layout

\begin_layout Itemize
The toolbar icons are dark and not very well visible in dark GUI themes
 (which are common, especially on mobile).
\end_layout

\begin_layout Itemize
Maybe not a problem if the intention is to just show a non-interactive plot,
 without the toolbar.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
What if we wanted to get this onto an Android smartphone?
\end_layout

\begin_deeper
\begin_layout Itemize
Kivy has a packaging tool called 
\family typewriter
buildozer
\family default
, which integrates your application code, a Python interpreter and any necessary
 libraries into an Android application package (.apk).
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Android_application_package"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
"Hello world" becomes 30
\begin_inset space ~
\end_inset

MB...
 but at least you can code it in Python!
\end_layout

\end_deeper
\begin_layout Itemize
How to install 
\family typewriter
buildozer
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://buildozer.readthedocs.io/en/latest/installation.html"

\end_inset


\end_layout

\begin_layout Itemize
How to write specifications for your app metadata:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://buildozer.readthedocs.io/en/latest/specifications.html"

\end_inset


\end_layout

\begin_layout Itemize
Binary extension modules require special care; 
\family typewriter
buildozer
\family default
 needs to know details on how to handle each specific module.
\end_layout

\begin_layout Itemize
Cython extension modules are possible, but require writing custom 
\emph on
recipes
\emph default
 (packaging specifications).
 Existing recipes:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy/python-for-android/tree/master/pythonforandroid/recipes"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
Instructions on adding new recipes:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://buildozer.readthedocs.io/en/latest/contribute.html"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
The documentation is mainly targeted at adding support for open-source libraries
 not yet supported, but is also applicable for your own custom extension
 modules.
\end_layout

\end_deeper
\begin_layout Itemize
Numerical library status on Android, as of late 2017:
\end_layout

\begin_deeper
\begin_layout Itemize
NumPy is supported, but an old version (1.9.2; current is 1.12.1), and only
 on Python
\begin_inset space ~
\end_inset

2.
 There was an initial attempt in 2016 to make it work on Python
\begin_inset space ~
\end_inset

3 with the Crystax
\begin_inset space ~
\end_inset

NDK, but it didn't work immediately, and it seems there is no currently
 active effort to fix this.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy/python-for-android/issues/882"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy/python-for-android/issues/1074"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.crystax.net/android/ndk"

\end_inset


\end_layout

\begin_layout Itemize
SciPy is not supported, and might be difficult to add due to many Fortran
 dependencies.
 Some versions of gfortran exist for Android, but nothing has been integrated
 into 
\family typewriter
buildozer
\family default
 yet.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy/python-for-android/issues/874"

\end_inset


\end_layout

\begin_layout Itemize
VisPy is supported, but only on Python
\begin_inset space ~
\end_inset

2.
 It just might work simply by patching 
\family typewriter
__init__.py
\family default
 to allow also 
\family typewriter
python3crystax
\family default
 (see the above issue 882 on NumPy) — or it might not.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy/python-for-android/tree/master/pythonforandroid/recipes/vispy"

\end_inset


\end_layout

\begin_layout Itemize
Matplotlib is not supported.
 On the other hand, maybe not needed in a mobile app; VisPy is for realtime
 visualization, whereas Matplotlib is for publication-quality printable
 graphics.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy/python-for-android/issues/520"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/30295886/matplotlib-compilation-recipe-for-python-for-android"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/kivy/python-for-android/issues/1090"

\end_inset


\end_layout

\begin_layout Itemize
It's pretty safe to assume this won't ever play well with Numba, since LLVM
 is unlikely to be easily packageable for a smartphone.
 (Smartphone processors are more than capable; this is more a matter of
 practical software logistics.)
\end_layout

\end_deeper
\begin_layout Standard
In conclusion, as of late 2017, as for making Python-based scientific computing
 apps for smartphones:
\end_layout

\begin_layout Standard
The edges are still a bit rough, and not everything is supported.
 This is maybe a good target for advanced developers, if the parts that
 exist already cover 99% of what you need.
 But for now, Python on Android is not a production-ready environment for
 arbitrary codes.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Bytecode disassembly
\begin_inset Index idx
status open

\begin_layout Plain Layout
Disassembly (bytecode)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Bytecode!disassembly
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f():
\end_layout

\begin_layout Plain Layout

    return (x for x in range(10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import numba
\end_layout

\begin_layout Plain Layout

g = numba.jit(f)  # <--- crash!
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\family typewriter
AttributeError: 'DataFlowAnalysis' object has no attribute 'op_MAKE_FUNCTION'
\end_layout

\begin_layout Standard
Excuse me, 
\emph on
the what
\emph default
 does not have 
\emph on
what
\emph default
? Considering it sounds like a VM opcode, let's have a look at 
\family typewriter
f()
\family default
, like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import dis  # <-- Python bytecode disassembler
\end_layout

\begin_layout Plain Layout

dis.dis(f)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  2           0 LOAD_CONST               1 (<code object <genexpr> [...] )
\end_layout

\begin_layout Plain Layout

              3 MAKE_FUNCTION            0
\end_layout

\begin_layout Plain Layout

              6 LOAD_GLOBAL              0 (range)
\end_layout

\begin_layout Plain Layout

              9 LOAD_CONST               2 (10)
\end_layout

\begin_layout Plain Layout

             12 CALL_FUNCTION            1    # <--- this calls range(10)
\end_layout

\begin_layout Plain Layout

             15 GET_ITER                      # <--- and grabs the iterator
 to the range
\end_layout

\begin_layout Plain Layout

             16 CALL_FUNCTION            1    # <--- this calls the generator,
\end_layout

\begin_layout Plain Layout

                                              #      which will return an
 iterator
\end_layout

\begin_layout Plain Layout

             19 RETURN_VALUE                  # <--- which is returned to
 the caller here
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
Legend
\emph default
: source code line number (in this example just one, namely 
\begin_inset Quotes eld
\end_inset

2
\begin_inset Quotes erd
\end_inset

), bytecode offset, OPCODE NAME,
\begin_inset Newline newline
\end_inset

raw 
\family typewriter
arg
\family default
 number, human-readable representation of arg.
\end_layout

\begin_layout Standard
Usually 
\family typewriter
arg
\family default
 is 2 bytes, unless 
\family typewriter
op
\family default
=
\family typewriter
EXTENDED_ARG
\family default
.
 See the source code for dis.disassemble(); it's Python.
\begin_inset Newline newline
\end_inset

(To display the source code in IPython, 
\family typewriter
dis.disassemble??
\family default
, with two question marks.)
\end_layout

\begin_layout Standard
The Python VM is a stack machine; 
\family typewriter
RETURN_VALUE
\family default
 pops the topmost value off the stack.
\end_layout

\begin_layout Standard
What the error message tried to tell us is that the Python virtual machine
 opcode 
\family typewriter
MAKE_FUNCTION
\family default
, which this example needs, is not implemented by Numba.
 (Indeed, Numba documentation confirms that generator expressions are not
 supported.)
\end_layout

\begin_layout Standard
Let's examine what happens if we change 
\family typewriter
f()
\family default
 to use a list comprehension
\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset

 instead.
 Updated example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f():
\end_layout

\begin_layout Plain Layout

    return [x for x in range(10)]  # <--- changed just ( ) to [ ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import numba
\end_layout

\begin_layout Plain Layout

g = numba.jit(f)  # <--- still crash!
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\family typewriter
AttributeError: 'DataFlowAnalysis' object has no attribute 'op_LIST_APPEND'
\end_layout

\begin_layout Standard
Ok, still no go.
 Now the disassembly reads
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  2           0 BUILD_LIST               0
\end_layout

\begin_layout Plain Layout

              3 LOAD_GLOBAL              0 (range)
\end_layout

\begin_layout Plain Layout

              6 LOAD_CONST               1 (10)
\end_layout

\begin_layout Plain Layout

              9 CALL_FUNCTION            1
\end_layout

\begin_layout Plain Layout

             12 GET_ITER            
\end_layout

\begin_layout Plain Layout

        >>   13 FOR_ITER                12 (to 28)
\end_layout

\begin_layout Plain Layout

             16 STORE_FAST               0 (x)
\end_layout

\begin_layout Plain Layout

             19 LOAD_FAST                0 (x)
\end_layout

\begin_layout Plain Layout

             22 LIST_APPEND              2
\end_layout

\begin_layout Plain Layout

             25 JUMP_ABSOLUTE           13
\end_layout

\begin_layout Plain Layout

        >>   28 RETURN_VALUE
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
arg
\family default
 for loop opcodes is usually the offset from the current position after
 the 
\family typewriter
arg
\family default
; e.g.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family typewriter
13 FOR_ITER 12 (to 28)
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

means 
\emph on
at offset 13, op FOR_ITER, target offset 12 bytes
\emph default
.
 
\emph on
This is to (13 start) + (1 op + 2 arg) + (12 offset) = 28
\emph default
.
\end_layout

\begin_layout Standard
The >> markers, generated by the disassembler, also show visually the beginning
 and the end of the loop.
\end_layout

\begin_layout Standard
So, the opcode 
\family typewriter
LIST_APPEND
\family default
 is not implemented by Numba.
 But wait, isn't that a rather critical feature to have? 
\end_layout

\begin_layout Standard
Let's see what happens if we spell out the example explicitly.
 Surely, this is what the previous example must do internally?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f():
\end_layout

\begin_layout Plain Layout

    L = []
\end_layout

\begin_layout Plain Layout

    for x in range(10):
\end_layout

\begin_layout Plain Layout

        L.append(x)
\end_layout

\begin_layout Plain Layout

    return L
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import numba
\end_layout

\begin_layout Plain Layout

g = numba.jit(f)  # <--- ok!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g()  # --> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], as expected
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Now it works, so something must have changed! Disassembling, we have
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  2           0 BUILD_LIST               0
\end_layout

\begin_layout Plain Layout

              3 STORE_FAST               0 (L)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  3           6 SETUP_LOOP              33 (to 42)
\end_layout

\begin_layout Plain Layout

              9 LOAD_GLOBAL              0 (range)
\end_layout

\begin_layout Plain Layout

             12 LOAD_CONST               1 (10)
\end_layout

\begin_layout Plain Layout

             15 CALL_FUNCTION            1
\end_layout

\begin_layout Plain Layout

             18 GET_ITER            
\end_layout

\begin_layout Plain Layout

        >>   19 FOR_ITER                19 (to 41)
\end_layout

\begin_layout Plain Layout

             22 STORE_FAST               1 (x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  4          25 LOAD_FAST                0 (L)
\end_layout

\begin_layout Plain Layout

             28 LOAD_ATTR                1 (append)
\end_layout

\begin_layout Plain Layout

             31 LOAD_FAST                1 (x)
\end_layout

\begin_layout Plain Layout

             34 CALL_FUNCTION            1
\end_layout

\begin_layout Plain Layout

             37 POP_TOP             
\end_layout

\begin_layout Plain Layout

             38 JUMP_ABSOLUTE           19
\end_layout

\begin_layout Plain Layout

        >>   41 POP_BLOCK           
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  5     >>   42 LOAD_FAST                0 (L)
\end_layout

\begin_layout Plain Layout

             45 RETURN_VALUE 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which contains no opcode that is not supported by Numba.
\end_layout

\begin_layout Standard
The empty list is created using 
\family typewriter
BUILD_LIST
\family default
, and 
\family typewriter
list.append()
\family default
 is invoked using 
\family typewriter
CALL_FUNCTION
\family default
!
\end_layout

\begin_layout Standard
Quoting Eli Bendersky:
\end_layout

\begin_layout Standard

\emph on
As a reminder, 
\family typewriter
LOAD_FAST
\family default
 and 
\family typewriter
STORE_FAST
\family default
 are the opcodes Python uses to access names that are only used within a
 function.
 Since the Python compiler knows statically (at compile-time) how many such
 names exist in each function, they can be accessed with static array offsets
 as opposed to a hash table, which makes access significanly faster (hence
 the 
\family typewriter
_FAST
\family default
 suffix
\family sans
).
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://eli.thegreenplace.net/2015/the-scope-of-index-variables-in-pythons-for-loops/"

\end_inset


\end_layout

\begin_layout Standard
(The 
\family typewriter
arg
\family default
s to 
\family typewriter
LOAD_FAST
\family default
 and 
\family typewriter
STORE_FAST
\family default
 are, apparently, these static array offsets.)
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
As a concluding note, this analysis also tells us that the list comprehension
\begin_inset Index idx
status open

\begin_layout Plain Layout
List comprehension
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Comprehension!list
\end_layout

\end_inset

 or generator
\begin_inset Index idx
status open

\begin_layout Plain Layout
Generator
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Generator expression
\end_layout

\end_inset

 expression versions 
\emph on
will likely run faster
\emph default
, since they result in shorter bytecode.
\begin_inset Index idx
status open

\begin_layout Plain Layout
for loop!vs.
 list comprehension, relative performance of
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Performance!for loop vs.
 list comprehension
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's test this.
 IPython:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def f1():
\end_layout

\begin_layout Plain Layout

    return [x for x in range(10)]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def f2():
\end_layout

\begin_layout Plain Layout

    L = []
\end_layout

\begin_layout Plain Layout

    for x in range(10):
\end_layout

\begin_layout Plain Layout

        L.append(x)
\end_layout

\begin_layout Plain Layout

    return L
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%timeit f1()
\end_layout

\begin_layout Plain Layout

1000000 loops, best of 3: 522 ns per loop
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%timeit f2()
\end_layout

\begin_layout Plain Layout

The slowest run took 5.86 times longer than the fastest.
 This could mean that an intermediate
\end_layout

\begin_layout Plain Layout

result is being cached.
\end_layout

\begin_layout Plain Layout

1000000 loops, best of 3: 854 ns per loop
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Comparing the measured average run time and program bytecode length ratios,
\begin_inset Formula 
\[
\frac{t(f_{1})}{t(f_{2})}=\frac{522}{854}\approx0.611\;,\quad\frac{\ell(f_{1})}{\ell(f_{2})}=\frac{12}{19}\approx0.632\;,
\]

\end_inset

we observe that they are within 4% of each other.
 So indeed, list comprehensions are faster than explicit loops, and rather
 close to the number expected by just examining the disassembled bytecode.
\end_layout

\begin_layout Standard
This is of course an academic example, because the body of the loop does
 almost no work.
 The proportion of overhead from the looping mechanism, out of the total
 bytecode length (in both variants of the code), will be smaller in real-world
 use cases, where more work is done per item.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, intuition tells us that Numba, or indeed any compiler, cannot do
 much here, as the loop operates on Python objects.
 Trying it out:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numba
\end_layout

\begin_layout Plain Layout

g = numba.jit(f2)  # prepare f2() for JIT compilation, store the result into
 "g"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%timeit g()  # compile at first call
\end_layout

\begin_layout Plain Layout

The slowest run took 78260.53 times longer than the fastest.
 This could mean that an
\end_layout

\begin_layout Plain Layout

intermediate result is being cached.
\end_layout

\begin_layout Plain Layout

1000000 loops, best of 3: 511 ns per loop
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

(What the large spread in runtimes actually means is that the JIT compiler
 was invoked on the first run.)
\end_layout

\begin_layout Standard
We now get 
\begin_inset Formula $511\,\mathrm{ns}$
\end_inset

 vs.
 the earlier 
\begin_inset Formula $522\,\mathrm{ns}$
\end_inset

; in practice nothing happened.
\end_layout

\begin_layout Standard
But as a bonus, this tells us that the JIT compilation step took
\begin_inset Formula 
\[
t_{\mathrm{JIT}}\approx78620.53\cdot511\,\mathrm{ns}\approx0.0402\,\mathrm{s}\;.
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Publishing and distribution
\begin_inset Index idx
status open

\begin_layout Plain Layout
Publishing Python packages
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!packages, publishing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes, you may want to publish your Python-based project.
 There are de facto standard ways of doing this, which we will very briefly
 look into here.
\end_layout

\begin_layout Subsubsection
Online code repositories
\end_layout

\begin_layout Standard
The first step in publishing a Python-based project is to publish the codes
 on the internet.
 GitHub
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub
\end_layout

\end_inset

 and BitBucket
\begin_inset Index idx
status open

\begin_layout Plain Layout
BitBucket
\end_layout

\end_inset

 are popular social media for source code version control and publishing.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Social version control
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Version control!social
\end_layout

\end_inset

 If you would like others to find your project, it is recommended to at
 least upload the code to one of these services.
\end_layout

\begin_layout Standard
Due to the simple reason that I'm personally more familiar with GitHub,
 most of the tips below will focus on it.
\end_layout

\begin_layout Itemize
Both GitHub and BitBucket work by hosting version control repositories.
 Roughly, a repository
\begin_inset Index idx
status open

\begin_layout Plain Layout
Repository (version control)
\end_layout

\end_inset

 is a place to store codes from one project.
 A user can have multiple repositories (e.g.
 one for each project).
\end_layout

\begin_layout Itemize
GitHub was originally based on 
\family typewriter
git
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
git (version control software)
\end_layout

\end_inset

, whereas BitBucket was based on Mercurial
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mercurial (version control software)
\end_layout

\end_inset

 (
\family typewriter
hg
\family default
).
 Nowadays they both support multiple different backends.
\end_layout

\begin_layout Itemize
Specifically on GitHub, for public (open-source) projects, a free account
 is fine.
\end_layout

\begin_layout Itemize
10-minute tutorial to getting started with GitHub:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://guides.github.com/activities/hello-world/"

\end_inset


\end_layout

\begin_layout Itemize
It is considered polite to supply at least a minimal README, to tell readers
 what the project is all about, how to install it, and basic usage.
 See existing projects for examples.
\end_layout

\begin_deeper
\begin_layout Itemize
On GitHub, READMEs are usually written in Markdown
\begin_inset Index idx
status open

\begin_layout Plain Layout
Markdown (document markup language)
\end_layout

\end_inset

, which is a minimal markup language (think: like HTML, but much less verbose).
 To learn it in 5 minutes:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet"

\end_inset


\end_layout

\begin_layout Itemize
GRIP (Github Readme Instant Preview)
\begin_inset Index idx
status open

\begin_layout Plain Layout
GRIP (Github Readme Instant Preview)
\end_layout

\end_inset

:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/joeyespo/grip"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Tagging your repository with keywords is also recommended, as this makes
 it easier to find by topic.
\end_layout

\begin_deeper
\begin_layout Itemize
GitHub has auto-completion of keywords.
 E.g.
 if you start typing 
\begin_inset Quotes eld
\end_inset

lin
\begin_inset Quotes erd
\end_inset

, it will suggest (among other possibilities) 
\begin_inset Quotes eld
\end_inset

linear
\begin_inset Quotes erd
\end_inset

, and if you then continue to type 
\begin_inset Quotes eld
\end_inset

linear-eq
\begin_inset Quotes erd
\end_inset

, it will suggest 
\begin_inset Quotes eld
\end_inset

linear-equations
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
This is meant to unify the spelling of keywords entered by different users
 for the same topic, thus improving searchability.
\end_layout

\begin_layout Itemize
Hence, try first if any of the existing keywords suits your purposes, and
 only if nothing matches, then add your own (just type it).
\end_layout

\end_deeper
\begin_layout Itemize
Once your code is in what you think is a reasonable state, 
\emph on
tag
\emph default
 it, i.e.
 assign a unique version number to that state — and then, create a 
\emph on
release
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
This ensures that users (and you yourself) can, at an arbitrary later time,
 return to that known state of the code, if needed.
\end_layout

\begin_deeper
\begin_layout Itemize
E.g.
 in scientific use, it may be useful to assign a version number to the version
 of the code that produced the figures for a published article.
\end_layout

\begin_layout Itemize
Then, if the figures underwent corrections in the referee process, the final
 version of the code should have a new version number.
\end_layout

\end_deeper
\begin_layout Itemize
How to number versions?
\end_layout

\begin_deeper
\begin_layout Itemize
Different software projects use different versioning schemes.
\end_layout

\begin_layout Itemize

\emph on
Semantic versioning
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Semantic versioning
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Versioning, semantic
\end_layout

\end_inset

 is a scheme that standardizes the meaning of each component of the version
 number:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://semver.org/"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
GitHub has many hidden (but documented) keyboard shortcuts, which accelerate
 the workflow for advanced users.
 See:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://help.github.com/articles/using-keyboard-shortcuts/"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Packaging: distribution to other Python programmers
\begin_inset Index idx
status open

\begin_layout Plain Layout
Packaging (distribution to programmers)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Distribution!to programmers (packaging)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you want to go a step further — especially, if your project is somehow
 generic or reusable — consider 
\emph on
packaging
\emph default
 the project to allow other Python programmers to install it conveniently.
\end_layout

\begin_layout Standard
It must be said that packaging can be rather technical, and there are several
 ways to do it wrong, so this is perhaps a world you'll want to dive into
 only after obtaining a certain degree of familiarity and experience with
 Python.
\end_layout

\begin_layout Standard
With that warning aside, the main points:
\end_layout

\begin_layout Itemize
Packaging guide (
\series bold
recommended
\series default
):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://packaging.python.org/"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The Hitchhiker's Guide to Python also has a section on packaging, but with
 a different focus (e.g.
 tips on setting up a private server to publish proprietary applications):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.05cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://docs.python-guide.org/en/latest/shipping/packaging/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The Python packaging process is still evolving, so detailed packaging advice
 may outdate quickly.
 The following is valid as of late 2017.
\end_layout

\begin_layout Itemize
The recommended packaging software is 
\family typewriter
setuptools
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
setuptools
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
setuptools
\family default
 comes with Python.
\end_layout

\begin_layout Itemize
Instead of a plain configuration file, 
\family typewriter
setuptools
\family default
 uses a Python script to control the software (standard name 
\family typewriter
setup.py
\family default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
setup.py
\end_layout

\end_inset

.
 This script typically makes some definitions specific to the project, and
 then invokes 
\family typewriter
setuptools
\family default
 to do the actual work.
\end_layout

\begin_layout Itemize
PyPA (Python Packaging Authority)
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyPA (Python Packaging Authority)
\end_layout

\end_inset

 maintains an example project on how to use
\family typewriter
 setuptools
\family default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/pypa/sampleproject/"

\end_inset


\end_layout

\begin_layout Itemize
You will mainly want to create an 
\family typewriter
sdist
\family default
, i.e.
 a source distribution
\begin_inset Index idx
status open

\begin_layout Plain Layout
sdist (source distribution)
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
For most scientific projects, an 
\family typewriter
sdist
\family default
 is enough; even if you use Cython, scientific users are not scared by an
 automatic compile step, and will likely have the tools for that already
 installed anyway.
\end_layout

\end_deeper
\begin_layout Itemize
The recommended binary format is 
\begin_inset Quotes eld
\end_inset

wheel
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
wheel (binary distribution format)
\end_layout

\end_inset

.
 Pure Python projects can be built into 
\emph on
universal wheels
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Universal wheel
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
wheel (binary distribution format)!universal
\end_layout

\end_inset

 which are independent of the OS they are running on.
\end_layout

\begin_deeper
\begin_layout Itemize
If you use Cython, it is possible, but possibly also much more involved,
 to create binary distributions.
 These are 
\emph on
platform wheels
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Platform wheel
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
wheel (binary distribution format)!platform
\end_layout

\end_inset

 i.e.
 OS-specific binaries.
\end_layout

\end_deeper
\begin_layout Itemize
Including data files into the package — correctly, so that the resulting
 package works in any environment — can be rather technical.
 The main distinction is between what goes into the source distribution,
 and what gets installed.
 See here (for Cython, but the same notes apply to pure Python projects):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/Technologicat/setup-template-cython/#packaging-your-data-files"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Upload your package to PyPI
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyPI (PYthon Package Index)
\end_layout

\end_inset

 to make it available for 
\family typewriter
pip install
\family default
.
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
pip package manager
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This helps also you, if you have more than one computer.
\end_layout

\begin_layout Itemize
When you publish your first project on PyPI, you will need to create a user
 account, which then remains valid indefinitely for all of your current
 and future projects.
\end_layout

\begin_layout Itemize
The packaging guide covers publishing on PyPI, too:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.05cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://packaging.python.org/tutorials/distributing-packages/#uploading-your-project-to-pypi"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
About other tools:
\end_layout

\begin_deeper
\begin_layout Itemize
An overview of different (also historical, obsolete) tools:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://stackoverflow.com/questions/6344076/differences-between-distribute-distutils-setuptools-and-distutils2"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A brief history of Python packaging, up to 2015:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.pypa.io/en/latest/history/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Tools operating at the next higher abstraction level, to provide a simplified
 interface to Python packaging, already exist; but no single dominant software
 has emerged yet.
 There are at least Flit
\begin_inset Index idx
status open

\begin_layout Plain Layout
Flit (high-level packaging tool)
\end_layout

\end_inset

 and pbr
\begin_inset Index idx
status open

\begin_layout Plain Layout
pbr (high-level packaging tool)
\end_layout

\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/takluyver/flit"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.openstack.org/pbr/latest/"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Freezing: distribution to end users
\begin_inset Index idx
status open

\begin_layout Plain Layout
Freezing (distribution to end-users)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Distribution!to end-users (freezing)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the other hand, if you have developed an application for end-users, they
 do not likely care that it is written in Python; they just want something
 that runs.
 This is the territory of 
\emph on
freezing
\emph default
 (contrast 
\emph on
packaging
\emph default
 for other programmers).
\end_layout

\begin_layout Standard
Technically speaking, freezing an app packages both your own code and a
 Python interpreter into a single install package, which has everything
 that is needed to run your app.
 Python's license allows doing this regardless of whether your app is open-sourc
e or proprietary.
\end_layout

\begin_layout Itemize
The Hitchhiker's Guide to Python has a section on freezing:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://docs.python-guide.org/en/latest/shipping/freezing/"

\end_inset


\end_layout

\begin_layout Itemize
Tools:
\end_layout

\begin_deeper
\begin_layout Itemize
PyInstaller
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyInstaller (app freezing tool)
\end_layout

\end_inset

 [Windows, Linux, OS X]
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.pyinstaller.org/"

\end_inset


\end_layout

\begin_layout Itemize
py2app
\begin_inset Index idx
status open

\begin_layout Plain Layout
py2app (app freezing tool)
\end_layout

\end_inset

 [OS X]
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://py2app.readthedocs.io/en/latest/"

\end_inset


\end_layout

\begin_layout Itemize
py2exe
\begin_inset Index idx
status open

\begin_layout Plain Layout
py2exe (app freezing tool)
\end_layout

\end_inset

 [Windows]
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://pypi.python.org/pypi/py2exe/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
An alternative on Linux is to make .deb packages, but this is not recommended,
 because they would depend on the system Python.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://docs.python-guide.org/en/latest/shipping/packaging/#packaging-for-linux-distributions-ref"

\end_inset


\end_layout

\begin_layout Itemize
For the curious: Python's LICENSE:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/license.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Crash course in software engineering
\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This section very briefly, and selectively, covers some of the very basics
 of software engineering.
 This is to raise awareness for these ideas and tools in the scientific
 community, and also to give some basic practical pointers to improve productivi
ty.
 For an overview, see Wikipedia:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Software_development"

\end_inset


\end_layout

\begin_layout Standard
As for design, 
\emph on
agile software development
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Agile software development
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software development!agile
\end_layout

\end_inset

 may be of interest.
 It emphasizes an iterative approach to software design, instead of trying
 to nail down all requirements at the beginning (contrast the classical
\emph on
 waterfall model
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Waterfall model (software development)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software development!waterfall model
\end_layout

\end_inset

.
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Agile_software_development"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Waterfall_model"

\end_inset


\end_layout

\begin_layout Subsubsection
Version control
\begin_inset Index idx
status open

\begin_layout Plain Layout
Version control
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering!version control
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perhaps one of the most important tools in all of software engineering is
 
\emph on
version control
\emph default
.
 A version control software that has already remained popular for quite
 many years now is 
\family typewriter
git
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
git (version control software)
\end_layout

\end_inset

, so that is what we will focus on here.
\end_layout

\begin_layout Standard
Version control means that previous revisions of the code will be automatically
 saved for future reference.
 As the user, at any given time, you still see only one version (the current
 
\emph on
working tree
\emph default
) of your code — practically eliminating the mistake of accidentally making
 changes to the wrong version.
 Or in other words: no more numbered zip files; and with some very minimal
 effort toward writing commit messages, no more guessing which version of
 the code did what: version control gives you a searchable log.
\end_layout

\begin_layout Standard
Version control allows:
\end_layout

\begin_layout Itemize
Logging a human-readable summary description of each set of changes.
\end_layout

\begin_deeper
\begin_layout Itemize
This requires a minimal amount of additional effort for writing the description,
 but is very convenient when returning to the code (months or years!) later.
\end_layout

\begin_layout Itemize
An ideal log message is short, human-readable, descriptive.
\end_layout

\begin_layout Itemize
Logs can be viewed per-file, for a set of files, or for the whole project.
\end_layout

\begin_layout Itemize
Logs can be text-searched, which is useful for browsing or searching the
 project history later.
\end_layout

\end_deeper
\begin_layout Itemize
Fully automatically, seeing what 
\emph on
exactly
\emph default
 has changed between any two versions of the code, down to the last changed
 line.
\end_layout

\begin_deeper
\begin_layout Itemize
This requires no additional effort from the user.
\end_layout

\begin_layout Itemize

\emph on
Any version
\emph default
 includes the version currently being worked on (i.e.
 also before 
\emph on
committing
\emph default
 changes to version control).
\end_layout

\begin_deeper
\begin_layout Itemize
This is very useful for checking that no unintended changes have creeped
 in.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Going back to any earlier version, and returning to the latest version.
\end_layout

\begin_deeper
\begin_layout Itemize
Hence, no need to keep around commented-out blocks of code (that were possibly
 difficult to implement but not needed right now), since old stuff can be
 retrieved from version control.
\end_layout

\end_deeper
\begin_layout Itemize
Tagging important versions.
\end_layout

\begin_deeper
\begin_layout Itemize
Usually software releases.
\end_layout

\begin_layout Itemize
In scientific computing, useful for later identifying e.g.
 the version that was used to produce figures for a published article.
\end_layout

\end_deeper
\begin_layout Itemize
In larger projects, branching to test out new ideas.
\end_layout

\begin_deeper
\begin_layout Itemize
From branches, change sets can be selectively 
\emph on
backported
\emph default
, i.e.
 included into the master version under development.
\end_layout

\begin_layout Itemize
Change sets can also be 
\emph on
rebased
\emph default
, i.e.
 to be made to apply to a different version of the code.
 This is automatic, if the relevant parts of the 
\begin_inset Quotes eld
\end_inset

base
\begin_inset Quotes erd
\end_inset

 code have not changed too much.
\end_layout

\begin_layout Itemize
For readers familiar with gaming, branches can be used as "savepoints" before
 committing changes that may break something:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://think-like-a-git.net/sections/experimenting-with-git/branches-as-savepoints.html"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Tracking down programming mistakes (bugs) introduced at some point of the
 recorded development history.
\end_layout

\begin_deeper
\begin_layout Itemize
The first commit containing a given bug can be identified by 
\emph on
binary search
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Binary search (bisection search)
\end_layout

\end_inset

 i.e., by bisecting a given interval of commits.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Binary_search_algorithm"

\end_inset


\end_layout

\begin_layout Itemize
The user must know one version (commit) that has the bug, and one version
 that does not.
 These are used to set the search interval endpoints.
\end_layout

\begin_layout Itemize
The user must be able to test a given version and say whether it has the
 bug or not.
\end_layout

\begin_layout Itemize

\family typewriter
git bisect
\family default
 automates the rest.
\end_layout

\begin_layout Itemize
A binary search completes in 
\begin_inset Formula $O(\log n)$
\end_inset

 steps, so even if the interval to be tested contains lots of commits, the
 faulty commit will be found in just a few iterations.
\end_layout

\end_deeper
\begin_layout Itemize
Keeping track of changes (obviously).
\end_layout

\begin_deeper
\begin_layout Itemize
No need to tag changes in the source code itself (as comments), because
 you can 
\family typewriter
git diff
\family default
 to see what has changed.
\end_layout

\end_deeper
\begin_layout Standard
Some further things:
\end_layout

\begin_layout Itemize

\family typewriter
git
\family default
 is a 
\emph on
distributed version control system
\emph default
 (DVCS)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Version control!distributed (DVCS)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Distributed version control
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
DVCS is the third generation of version control systems, see e.g.:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Eric Sink: A History of Version Control:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://ericsink.com/vcbe/html/history_of_version_control.html"

\end_inset


\end_layout

\begin_layout Itemize
This means that unlike early version control systems such as PVCS, CVS or
 Subversion (SVN), 
\family typewriter
git
\family default
 does not need a centralized server to host the 
\emph on
repository
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Repository (version control)
\end_layout

\end_inset

 that contains the version history.
\end_layout

\begin_deeper
\begin_layout Itemize
In other words, a copy of the 
\emph on
whole version history
\emph default
 of the project is always present 
\emph on
right there on your computer
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
You can sync your local repository with that on a server by 
\family typewriter
pull
\family default
ing changes made by others (or by you on other computers), and by 
\family typewriter
push
\family default
ing your own changes to the server.
\end_layout

\begin_deeper
\begin_layout Itemize
A 
\family typewriter
pull
\family default
 is a combined 
\family typewriter
fetch
\family default
 and 
\family typewriter
merge
\family default
.
 Here 
\family typewriter
fetch
\family default
 just updates the local 
\emph on
repository
\emph default
; 
\family typewriter
merge
\family default
 incorporates the fetched changes into the current 
\emph on
working tree
\emph default
.
\end_layout

\begin_layout Itemize
Most of the time, your project will have only one remote repository (standard
 name 
\family typewriter
origin
\family default
), but it is possible to have several.
\end_layout

\begin_deeper
\begin_layout Itemize
This is convenient especially when you collaborate on someone else's project
 on GitHub
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub
\end_layout

\end_inset

.
 Another remote, 
\family typewriter
upstream
\family default
, may point to the original source (so that you can 
\family typewriter
pull
\family default
 it easily), while 
\family typewriter
origin
\family default
 points to your own copy on your own GitHub account (so that you can 
\family typewriter
push
\family default
 your own changes, and then make a 
\emph on
pull request (PR)
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Pull request (GitHub)
\end_layout

\end_inset

 on GitHub to the author, asking to incorporate your changes).
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize

\family typewriter
git
\family default
 communicates with remotes using an encrypted SSH
\begin_inset Index idx
status open

\begin_layout Plain Layout
SSH (Secure SHell)
\end_layout

\end_inset

 connection.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

The user is typically authenticated with 
\emph on
key-based authentication
\emph default
,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Key-based authentication
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Authentication, key-based
\end_layout

\end_inset

 which does not require typing a password, and is also more secure.
 On this topic, see e.g.:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://help.ubuntu.com/community/SSH/OpenSSH/Keys"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Secure_Shell"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Read-only access, i.e.
 
\family typewriter
git pull
\family default
 and 
\family typewriter
git clone
\family default
, also work over HTTPS (encrypted, but no user authentication).
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Proper use of version control requires some self-discipline.
\end_layout

\begin_deeper
\begin_layout Itemize
Each commit should be related to one thing only.
\end_layout

\begin_deeper
\begin_layout Itemize
Even a simple whitespace cleanup should go into a separate commit.
\end_layout

\end_deeper
\begin_layout Itemize
And we really mean it! Even though, in practice, not everyone does it all
 the time.
\end_layout

\begin_deeper
\begin_layout Itemize
If you already modified several unrelated things in the same file, don't
 worry: 
\family typewriter
git add --patch
\family default
 lets you tell 
\family typewriter
git
\family default
 which changes belong and which don't.
\end_layout

\begin_layout Itemize
And if you commit, but immediately notice something was broken, just undo
 it (as long as the broken commit only exists on your own computer):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/2845731/how-to-uncommit-my-last-commit-in-git"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Version control has evolved out of the programming community, and consists
 mostly of command-line tools.
\end_layout

\begin_deeper
\begin_layout Itemize
Basic everyday tasks, after a short initial learning curve, are much faster
 from the command line.
\end_layout

\begin_layout Itemize
For more rarely encountered tasks, a graphical frontend may be useful.
\end_layout

\begin_deeper
\begin_layout Itemize
GitEye [Windows, Linux, OS X]
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitEye (GUI for git)
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.collab.net/products/giteye"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Free, based on Eclipse
\begin_inset Index idx
status open

\begin_layout Plain Layout
Eclipse (IDE)
\end_layout

\end_inset

 (JGit + EGit), prepackaged for ease of use for this particular task.
\end_layout

\begin_layout Itemize
Instructions for the version control component: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://wiki.eclipse.org/EGit/User_Guide"

\end_inset


\end_layout

\begin_layout Itemize
Also contains ALM (application lifecycle management), based on Mylyn.
 (We will skip this.)
\end_layout

\begin_layout Itemize
Downsides: doesn't support GPG signed tagging (we will skip this); big download
 (100 MB).
\end_layout

\end_deeper
\begin_layout Itemize
TortoiseGit [Windows]
\begin_inset Index idx
status open

\begin_layout Plain Layout
TortoiseGit (GUI for git)
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://tortoisegit.org/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Specifically for visualizing the commit log
\begin_inset Index idx
status open

\begin_layout Plain Layout
git log, visualizing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Visualizing, git log
\end_layout

\end_inset

, especially in projects that have branches:
\end_layout

\begin_deeper
\begin_layout Itemize
gitg [Linux]
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://wiki.gnome.org/Apps/Gitg/"

\end_inset


\end_layout

\begin_layout Itemize
GitX [OS X]
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://gitx.frim.nl/"

\end_inset


\end_layout

\begin_layout Itemize
You may also want to make a shell alias (e.g.
 
\family typewriter
gg
\family default
) for this command:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git log --oneline --abbrev-commit --all --graph --decorate --color
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

which prints a (rather visual) summary to the terminal (command prompt).
 See
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://think-like-a-git.net/sections/graphs-and-git/visualizing-your-git-repository.html "

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Some useful material:
\end_layout

\begin_layout Itemize
Sam Livingston–Gray: Think Like (a) Git:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://think-like-a-git.net/sections/about-this-site.html"

\end_inset


\end_layout

\begin_layout Itemize
Ryan Tomayko: The Thing about Git [is never having to say, “you should have”]:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://2ndscale.com/rtomayko/2008/the-thing-about-git"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
This is a good explanation of 
\family typewriter
git add --patch
\family default
, or in other words, what is and how to solve 
\emph on
the tangled working copy problem
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Tangled working copy (version control)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Working copy, tangled (version control)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
git
\family default
 vs.
 Mercurial (
\family typewriter
hg
\family default
):
\begin_inset Index idx
status open

\begin_layout Plain Layout
git (version control software)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Mercurial (version control software)
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://stackoverflow.com/questions/35837/what-is-the-difference-between-mercurial-and-git"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Getting started with git
\begin_inset Index idx
status open

\begin_layout Plain Layout
git, how to use
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
git (version control software)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's try out the 
\family typewriter
git
\family default
 version control system.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\series bold
Part 1/3: Starting a new project
\end_layout

\begin_layout Itemize
Create an empty directory called e.g.
 
\family typewriter
git-tutorial
\family default
.
\end_layout

\begin_layout Itemize
In this directory, create a text file called 
\family typewriter
README.txt
\family default
.
 Write something (anything) in it.
\end_layout

\begin_layout Itemize
In a terminal (command prompt), go into the directory you created.
 Give the commands:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git init .
\end_layout

\begin_layout Plain Layout

git add .
\end_layout

\begin_layout Plain Layout

git commit -m "my initial commit"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

The first command creates an empty 
\family typewriter
git
\family default
 repository.
 You need to do this only once per new project.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

The second command adds all files and subdirectories from the current directory
 into the next 
\emph on
commit
\emph default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

The third command 
\emph on
commits
\emph default
 all pending changes into the repository.
 The 
\family typewriter
-m
\family default
 adds a one-line human-readable message, which will be saved in the commit
 log (for future reference and searching).
\end_layout

\begin_layout Itemize
In a real project, you will want to be more selective, to avoid committing
 
\emph on
noise
\emph default
 such as temporary files into version control (noise makes it harder to
 read logs).
 For example, for Python projects, you could shellglob
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git add *.py
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

to add all Python source files that have changed.
 Also, if your code needs some data files (or computes some data files,
 taking a long time), it may be good to store those in version control.
 You can store binaries, too; only text-specific tools such as 
\family typewriter
git diff
\family default
 are not available for them (as they will tell you if you try).
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

You can do several 
\family typewriter
git add
\family default
s if needed.
 The command writes the changes into the 
\emph on
staging area
\emph default
, which roughly means 
\emph on
the next upcoming commit
\emph default
.
\end_layout

\begin_layout Itemize
If this is your first time using 
\family typewriter
git
\family default
 (on this computer), now 
\family typewriter
git
\family default
 may ask you to tell it who you are.
 This makes it possible for 
\family typewriter
git
\family default
 to automatically mark your commits as yours, in case you later collaborate
 with someone on the same (usually remote) repository.
 To configure, invoke the commands
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git config --global user.name "John Doe"
\end_layout

\begin_layout Plain Layout

git config --global user.email "john.doe@example.com"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

obviously using your own name and email.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

This needs to be done only once (per computer); all future commits, for
 any repository, will use this information.
\end_layout

\begin_layout Itemize
If you want to fix the author details in the one commit that was already
 made, run the command
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git commit --amend --reset-author
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Note that in everyday usage, this is not needed.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

If, at this point, 
\family typewriter
git
\family default
 has decided to be mean and expose you to 
\family typewriter
vim
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
vim (text editor)
\end_layout

\end_inset

 just because you needed to write a short log message, you may want to know
 that 
\family typewriter
i
\family default
 enters 
\emph on
insert mode
\emph default
 (the mode where you actually write), 
\family typewriter
Esc
\family default
 returns to 
\emph on
command mode
\emph default
, and the sequence of commands 
\family typewriter
:wq
\family default
 (and 
\family typewriter
Enter
\family default
) saves changes and exits.
 To exit discarding changes, 
\family typewriter
:q!
\family default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

To avoid pain in the future, 
\family typewriter
git
\family default
 can be configured to invoke a different text editor; see part 3 below.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Your first commit has been saved to version control! Try the command
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git log
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

to see your commit log so far.
 Just like for Python's help system, the reader is GNU 
\family typewriter
less
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
GNU less (software)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
less (software)
\end_layout

\end_inset

; pressing 
\family typewriter
q
\family default
 exits.
 Again, cheat sheet for keyboard commands:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Less_(Unix)#Frequently_used_commands"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Try also
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git status
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which should report that right now, nothing is staged for the next commit,
 and that the working directory is 
\emph on
clean
\emph default
.
 Clean means here that the directory contains no files that are not in version
 control, and no changes have been made to files that are in version control.
\end_layout

\begin_layout Itemize
Terminology: unlike many other (especially earlier) version control systems,
 if you start collaborating on someone else's project (copying the code
 from their existing repository), this is not a 
\emph on
checkout
\emph default
, but a 
\emph on
clone
\emph default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git clone https://github.com/someuser/someproject
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

In 
\family typewriter
git
\family default
, the term 
\family typewriter
checkout
\family default
 has a different meaning; we will return to that in part 3 below.
\end_layout

\begin_layout Standard

\emph on
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\series bold
\emph default
Part 2/3: Working on an existing project
\end_layout

\begin_layout Standard
Continuing the previous example:
\end_layout

\begin_layout Itemize
Create another file in the same directory with your readme, for example
 
\family typewriter
test.txt
\family default
.
 Write something into it and save.
\end_layout

\begin_layout Itemize
Open your 
\family typewriter
README.txt
\family default
, write something there too, and save.
 (The point is to modify our existing, already version-controlled file.)
\end_layout

\begin_layout Itemize
Now that we have made some changes to the working tree, let's:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git status
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

You will see something like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

On branch master
\end_layout

\begin_layout Plain Layout

Changes not staged for commit:
\end_layout

\begin_layout Plain Layout

  (use "git add <file>..." to update what will be committed)
\end_layout

\begin_layout Plain Layout

  (use "git checkout -- <file>..." to discard changes in working directory)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        modified:   README.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Untracked files:
\end_layout

\begin_layout Plain Layout

  (use "git add <file>..." to include in what will be committed)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        test.txt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

no changes added to commit (use "git add" and/or "git commit -a")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

In a real project, this gives you an overview of which files you have changed
 or added.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
Let's see what exactly has changed:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git diff
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

 You will see output similar to
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

diff --git a/README.txt b/README.txt
\end_layout

\begin_layout Plain Layout

index 9290ee6..52cdf61 100644
\end_layout

\begin_layout Plain Layout

--- a/README.txt
\end_layout

\begin_layout Plain Layout

+++ b/README.txt
\end_layout

\begin_layout Plain Layout

@@ -1 +1,3 @@
\end_layout

\begin_layout Plain Layout

 Testing how to create a git repo.
\end_layout

\begin_layout Plain Layout

+
\end_layout

\begin_layout Plain Layout

+Testing some more.
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This tells us that in 
\family typewriter
README.txt
\family default
, we have added (+) a blank line, and the line saying 
\begin_inset Quotes eld
\end_inset

Testing some more.
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
If you have made a lot of changes, a file level overview may be useful.
 For this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git diff --stat
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

We get:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

 README.txt | 2 ++
\end_layout

\begin_layout Plain Layout

 1 file changed, 2 insertions(+)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Note that 
\family typewriter
git diff
\family default
 only accounts for files which are already in version control! The file
 
\family typewriter
test.txt
\family default
 does not show up, because it is 
\emph on
untracked
\emph default
 (not in version control).
\end_layout

\begin_layout Itemize
Let's add 
\family typewriter
test.txt
\family default
 to version control, in our next commit:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git add test.txt
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Let's also add all already tracked files 
\emph on
that we have changed in the working tree
\emph default
:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git add -u
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

The 
\family typewriter
-u
\family default
 stands for 
\emph on
update
\emph default
.
 This variant of 
\family typewriter
git add
\family default
 is very useful in daily work, because you don't have to list (or shellglob)
 the filenames, and no noise files will be accidentally added.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

But when you use this, keep in mind that when you need to add a new file
 to version control, that must be done separately (as above).
\end_layout

\begin_layout Itemize
Now that we're done with this change set, our next task is to write a commit
 message.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

But what if a lunch break occurred in between, and we have forgotten what
 we changed? If we try
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git diff
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

we get no output, because the changes are already in the staging area.
 However, 
\family typewriter
git diff
\family default
 has a flag for exactly this use case:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git diff --cached
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This gives a report of the changes:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

diff --git a/README.txt b/README.txt
\end_layout

\begin_layout Plain Layout

index 9290ee6..52cdf61 100644
\end_layout

\begin_layout Plain Layout

--- a/README.txt
\end_layout

\begin_layout Plain Layout

+++ b/README.txt
\end_layout

\begin_layout Plain Layout

@@ -1 +1,3 @@
\end_layout

\begin_layout Plain Layout

 Testing how to create a git repo.
\end_layout

\begin_layout Plain Layout

+
\end_layout

\begin_layout Plain Layout

+Testing some more.
\end_layout

\begin_layout Plain Layout

diff --git a/test.txt b/test.txt
\end_layout

\begin_layout Plain Layout

new file mode 100644
\end_layout

\begin_layout Plain Layout

index 0000000..a579d6c
\end_layout

\begin_layout Plain Layout

--- /dev/null
\end_layout

\begin_layout Plain Layout

+++ b/test.txt
\end_layout

\begin_layout Plain Layout

@@ -0,0 +1 @@
\end_layout

\begin_layout Plain Layout

+Here is another test file.
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Now our new file 
\family typewriter
test.txt
\family default
 is also shown, because it has been added to the upcoming commit (so if
 committed, it will be tracked), and there is no corresponding file yet
 in version control.
 In the output, the previous revision of 
\family typewriter
test.txt
\family default
 has the special path 
\family typewriter
/dev/null
\family default
 to indicate this.
\end_layout

\begin_layout Itemize
Naturally, a summary is available also for the 
\family typewriter
--cached
\family default
 diff:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git diff --cached --stat
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which produces
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

 README.txt | 2++
\end_layout

\begin_layout Plain Layout

 test.txt  | 1+
\end_layout

\begin_layout Plain Layout

 2 files changed, 3 insertions(+)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Finally, we commit our changes to version control:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git commit -m "made some test edits"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Your second commit is done! From here on, just follow the same pattern.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\series bold
Part 3/3: Advanced
\end_layout

\begin_layout Itemize
If your local repository tracks a remote repository (if there is just one,
 usually called 
\family typewriter
origin
\family default
), you can upload your changes by
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git push
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

GitHub has a useful help page on 
\family typewriter
git push
\family default
: 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://help.github.com/articles/pushing-to-a-remote/"

\end_inset


\end_layout

\begin_layout Itemize
To download changes from the remote (uploaded by your collaborators, or
 by you from a different computer), and merge those changes into your working
 tree:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git pull
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Roughly speaking, this will, essentially,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git fetch origin
\end_layout

\begin_layout Plain Layout

git merge origin/master
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Note that 
\family typewriter
git merge
\family default
 always merges 
\emph on
into
\emph default
 whatever branch is active in your working tree at the moment; you just
 tell it where to merge 
\emph on
from
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
Changing the text editor
\emph default
.
 Here:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git config --global gui.editor gedit
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Replace 
\family typewriter
gedit
\family default
 with whatever command you want 
\family typewriter
git
\family default
 to invoke as the text editor.
\end_layout

\begin_layout Itemize

\emph on
Tagging
\emph default
.
 If, for reasons discussed above, you would like to tag the current state
 of your working tree with a unique version number, this is done as follows:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git tag -a "my_version_name"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This tells 
\family typewriter
git
\family default
 to add an 
\emph on
annotated
\emph default
 (
\family typewriter
-a
\family default
) tag with the name 
\family typewriter
my_version_name
\family default
.
 The tag applies to the version currently in the working tree.
 Typically the name is a version number, such as 
\family typewriter
v1.0.0
\family default
, but it can be anything you want.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

When you do this, 
\family typewriter
git
\family default
 will open a text editor (possibly again 
\family typewriter
vim
\family default
 unless you have configured it), where you can type in a short message describin
g this version.
 If you have written release notes, you can paste those into the message.
\end_layout

\begin_layout Itemize
To see the messages of existing tags:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git tag -l -n3
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

where the number specifies up to how many lines of each tag message to show.
 To view a particular tag:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git tag -l my_version_name -n50
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
To 
\emph on
check out
\emph default
 an earlier version, i.e.
 to replace the content of your current working tree with that earlier version:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git checkout my_version_name
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

where 
\family typewriter
my_version_name
\family default
 is the tag you gave earlier.
 (It is best to commit any changes or discard them before doing this.)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

The same command, 
\family typewriter
git checkout
\family default
, also allows you to return to any untagged version.
 Look at the commit log (
\family typewriter
git log
\family default
), and instead of a tag name, give the 
\emph on
commit ID
\emph default
 (or a long enough part to be unique, from its beginning) from the log.
 Obviously, this allows you to add tags to old versions later, as long as
 you can identify the correct commit from the log.
\end_layout

\begin_layout Itemize
To return to the most recent version (replacing the content of the working
 tree with it):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git checkout HEAD
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

If you have an older version checked out for some reason, be sure to do
 this before continuing your development work.
 Otherwise you many have to create a branch, and then backport its changes
 onto the master branch.
 (To avoid mistakes, it is best to return to the most recent version as
 soon as possible.)
\end_layout

\begin_layout Itemize
The 
\family typewriter
checkout
\family default
 command has also another use — to discard changes to a particular file:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git checkout my_erroneously_changed_file.py
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
To see the current values of 
\family typewriter
git
\family default
's settings — especially useful, if you once long ago changed something,
 but can no longer remember what it was — invoke this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git config -l
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

For clarity, that is a lowercase ell (standing for 
\emph on
list
\emph default
).
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Useful settings include 
\family typewriter
gui.editor
\family default
, 
\family typewriter
gui.historybrowser
\family default
, 
\family typewriter
merge.tool
\family default
 and 
\family typewriter
diff.tool
\family default
.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
.gitignore
\family default
 file.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

This is very useful to prevent noise files from getting into your repository
 by accident, even if you 
\begin_inset Quotes erd
\end_inset


\family typewriter
git add .
\family default

\begin_inset Quotes erd
\end_inset

.
 This also has the further advantage that 
\family typewriter
git status
\family default
 will not complain about ignored files being untracked.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Create a file called 
\family typewriter
.gitignore
\family default
 (note the leading dot) inside your repository's top-level directory, and
 write into it shellglobs (one per line) identifying which filetypes do
 not belong in version control.
 Typically, these include text editor backups (
\family typewriter
*.*~
\family default
, 
\family typewriter
*.bak
\family default
) and compiled binaries (
\family typewriter
*.obj
\family default
, 
\family typewriter
*.so
\family default
, 
\family typewriter
*.exe
\family default
).
 Paths can also be used; the root 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset

 points to the top-level directory of the repository.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

For both Python and Cython projects, the following is a useful default 
\family typewriter
.gitignore
\family default
:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

/.project
\end_layout

\begin_layout Plain Layout

/build
\end_layout

\begin_layout Plain Layout

/dist
\end_layout

\begin_layout Plain Layout

*.*~
\end_layout

\begin_layout Plain Layout

*.bak
\end_layout

\begin_layout Plain Layout

*.pyc
\end_layout

\begin_layout Plain Layout

*.c
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset

This tells 
\family typewriter
git
\family default
 to ignore Spyder's GUI settings (which change every time if you e.g.
 simply just change which files are open in the editor), anything under
 
\family typewriter
build/
\family default
 and 
\family typewriter
dist/
\family default
 (for Cython and packaging), any text editor backup files, compiled Python
 bytecode, and (for Cython) any C-language source code.
\end_layout

\begin_layout Itemize
If you accidentally add the wrong file to the upcoming commit, but have
 not yet committed it yet, undo:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git reset HEAD README.txt
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\emph on
This does not modify your file
\emph default
; it only undoes the act of placing it into the staging area.
\end_layout

\begin_layout Itemize
Undoing a commit (as long as you have not pushed it to a remote):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/2845731/how-to-uncommit-my-last-commit-in-git"

\end_inset


\end_layout

\begin_layout Itemize
Dealing with a tangled working copy (i.e.
 how to 
\family typewriter
git add --patch
\family default
):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://2ndscale.com/rtomayko/2008/the-thing-about-git"

\end_inset


\end_layout

\begin_layout Itemize
For advanced work, you will want to read about 
\family typewriter
git
\family default
's 
\emph on
branch
\emph default
 features.
 In 
\family typewriter
git
\family default
, branches are very, very cheap, compared to early version control systems;
 
\family typewriter
git
\family default
 doesn't have to do much but create a reference.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

To create a new branch, from whatever revision is currently checked out
 in the working tree:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git checkout -b my_awesome_branch
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

The 
\family typewriter
-b
\family default
 stands for 
\emph on
make a new 
\series bold
b
\series default
ranch
\emph default
.
 To switch branches later:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

git checkout master             # switch to master
\end_layout

\begin_layout Plain Layout

git checkout my_awesome_branch  # switch back to the other branch
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

You can also upload branches to remotes, and download branches from remotes.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/6232535"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/9537923"

\end_inset


\end_layout

\begin_layout Itemize
If your project is open-source, you may want to publish your code on the
 social version control service GitHub; this makes collaboration easier.
 See the section on publishing and distribution, above.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Comments (with a slice of very basic computer science)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Comments (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering!comments
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is an old programming adage:
\end_layout

\begin_layout Standard

\emph on
Writing code is easy, reading code is very hard.
\end_layout

\begin_layout Standard
The worst part is that this applies also to your own code: in six months,
 you won't remember the details.
 Hence, it is a good idea to document the 
\emph on
why
\emph default
 right when you write the code, or that information will be lost, often
 forever (barring an exercise in reverse-engineering your own code, and
 re-discovering the pitfalls that led to your particular design choices).
\end_layout

\begin_layout Standard
User manuals and beginner explanations of programming languages sometimes
 do new programmers a disservice, by introducing comments as 
\emph on
something that is ignored
\emph default
.
 Comments may very well be ignored by the computer when it executes the
 program, but for humans, they are extremely important!
\end_layout

\begin_layout Standard
Some useful material:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikibooks.org/wiki/Python_Programming/Source_Documentation_and_Comments"

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Comment_(computer_programming)"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset

It is often said that in comments, one should 
\emph on
document the why, not the how
\emph default
.
 For example, see the online essay by software developer Jeff Atwood:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Jeff Atwood: Code Tells You How, Comments Tell You Why:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://blog.codinghorror.com/code-tells-you-how-comments-tell-you-why/"

\end_inset


\end_layout

\begin_layout Standard
(His recommendations of the classic book 
\emph on
Structure and Interpretation of Computer Programs
\emph default
 (often abbreviated to 
\emph on
SICP
\emph default
) and Donald Knuth's 1984 essay on 
\emph on
Literate Programming
\emph default
 are worth noting also here.)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset

But what does 
\begin_inset Quotes eld
\end_inset

why, not how
\begin_inset Quotes erd
\end_inset

 mean in practice? It is perhaps most readily explained by example.
 Consider the following silly program:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# recursively sum f(k-1) and f(k-2)
\end_layout

\begin_layout Plain Layout

def f(k):
\end_layout

\begin_layout Plain Layout

    k = int(k)
\end_layout

\begin_layout Plain Layout

    if k < 0:
\end_layout

\begin_layout Plain Layout

        raise ValueError("out of domain")
\end_layout

\begin_layout Plain Layout

    if k < 2:
\end_layout

\begin_layout Plain Layout

        return k
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        return f(k-1) + f(k-2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    numbers = [ f(j) for j in range(30) ]
\end_layout

\begin_layout Plain Layout

    print(numbers)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

    main()
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What does the program do? The comment above 
\family typewriter
f()
\family default
 is completely useless, as it focuses on the 
\emph on
how
\emph default
, which the code itself already describes perfectly clearly — not to mention
 more exactly: corner cases, termination condition...
\end_layout

\begin_layout Standard
To an audience with a background in mathematics, it is probably immediately
 clear what this program does — it calculates Fibonacci numbers
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fibonacci numbers
\end_layout

\end_inset

.
 But what about the (arguably rare) programmer who hasn't yet heard of them?
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

We can improve the situation easily, by instead writing down 
\emph on
why
\emph default
 
\family typewriter
f()
\family default
 does what it does:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# compute Fibonacci numbers
\end_layout

\begin_layout Plain Layout

def f(k):
\end_layout

\begin_layout Plain Layout

    k = int(k)
\end_layout

\begin_layout Plain Layout

    if k < 0:
\end_layout

\begin_layout Plain Layout

        raise ValueError("out of domain")
\end_layout

\begin_layout Plain Layout

    if k < 2:
\end_layout

\begin_layout Plain Layout

        return k
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        return f(k-1) + f(k-2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    numbers = [ f(j) for j in range(30) ]
\end_layout

\begin_layout Plain Layout

    print(numbers)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

    main()
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Changing just one comment, we have given the uninformed reader of this code
 a 
\emph on
search keyword
\emph default
 that can be immediately used to learn about the topic.
\end_layout

\begin_layout Standard
Proper commenting becomes even more important when the program grows more
 complex.
 Consider the same example, version 2.0:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#!/usr/bin/env python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

__version__ = "2.0"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# compute Fibonacci numbers (accelerated using memoization)
\end_layout

\begin_layout Plain Layout

class Fibo:
\end_layout

\begin_layout Plain Layout

    memo = {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def __init__(self):
\end_layout

\begin_layout Plain Layout

        pass
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def __call__(self, k):
\end_layout

\begin_layout Plain Layout

        if k in self.memo:
\end_layout

\begin_layout Plain Layout

            return self.memo[k]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if k < 0:
\end_layout

\begin_layout Plain Layout

            raise ValueError("k must be >= 0, got %g" % (k))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        k = int(k)
\end_layout

\begin_layout Plain Layout

        out = None
\end_layout

\begin_layout Plain Layout

        if k < 2:
\end_layout

\begin_layout Plain Layout

            out = k
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            out = self(k-1) + self(k-2)
\end_layout

\begin_layout Plain Layout

        self.memo[k] = out
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        return out
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    f = Fibo()
\end_layout

\begin_layout Plain Layout

    numbers = [ f(j) for j in range(1000) ]
\end_layout

\begin_layout Plain Layout

    print(numbers)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

    main()
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Improvements:
\end_layout

\begin_layout Itemize
The error message is now much more descriptive, informing the user about
 both the valid domain and what the routine got as input (making any bugs
 in calling code easier to find).
\end_layout

\begin_layout Itemize
Another search keyword (
\emph on
memoization
\emph default
):
\begin_inset Index idx
status open

\begin_layout Plain Layout
Memoization
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Memoization"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Memoization is a highly useful general programming technique to speed up
 function evaluation at the cost of memory use.
 This is called a 
\emph on
space–time tradeoff
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Space-time tradeoff
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Memoization depends on the property that given any fixed values of function
 arguments, the output of the function is always the same.
\end_layout

\begin_layout Itemize
This is a manual application of memoization, but compilers for functional
 programming languages use memoization automatically.
\end_layout

\end_deeper
\begin_layout Itemize
We could also use this bit of magic, which would let us memoize by simply
 adding a decorator
\begin_inset Index idx
status open

\begin_layout Plain Layout
Decorator!
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

memoize
\end_layout

\end_inset

:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

Daniel Miller (2010): A memoize decorator for instance methods [Python recipe]:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/ActiveState/code/tree/master/recipes/Python/577452_memoize_decorator_instance"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family default
[Advanced!] If you want to 
\emph on
understand
\emph default
 the magic, especially 
\family typewriter
__get__()
\family default
, see:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://www.blog.pythonlibrary.org/2016/06/10/python-201-what-are-descriptors/"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://www.ianbicking.org/blog/2008/10/decorators-and-descriptors.html"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://krzysztofzuraw.com/blog/2016/python-class-decorators.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This allowed us to compute the sequence much further (1000 vs.
 earlier 30) in reasonable 
\emph on
wall time
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Wall time (elapsed real time)
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Elapsed_real_time"

\end_inset


\end_layout

\begin_layout Itemize
For this algorithm, memoization decreased the asymptotic runtime to 
\begin_inset Formula $O(n)$
\end_inset

, while — at least at first glance — increasing asymptotic memory use from
 
\begin_inset Formula $O(1)$
\end_inset

 to 
\begin_inset Formula $O(n)$
\end_inset

.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Asymptotic_computational_complexity"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
But that is not the whole story.
 The function makes two calls to itself per invocation.
 Since in the naïve version, none of the results are re-used, each of these
 calls will spawn two further calls, until the recursion bottoms out separately
 in each branch of the 
\begin_inset Quotes eld
\end_inset

call tree
\begin_inset Quotes erd
\end_inset

 thus generated.
\end_layout

\begin_layout Itemize
Since the code is single-threaded, this 
\begin_inset Quotes eld
\end_inset

call tree
\begin_inset Quotes erd
\end_inset

 will be explored 
\emph on
depth-first
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Depth-first search
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Search, depth-first
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Depth-first_search"

\end_inset


\end_layout

\begin_layout Itemize
The deepest branch 
\begin_inset Formula $f(n-1),f(n-2),...,f(1),f(0)$
\end_inset

 makes 
\begin_inset Formula $n+1$
\end_inset

 calls.
 Hence, 
\begin_inset Formula $O(n)$
\end_inset

 storage will be needed on the 
\emph on
call stack
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Call stack
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Call stack
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Stack!call
\end_layout

\end_inset

: roughly speaking: in each thread that is running, each currently active
 function call requires some (implicit, automatically handled) storage,
 so that the program knows where to resume execution when the called function
 returns.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Call_stack"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
What was the asymptotic runtime of the original version? By writing out
 the first few cases manually, the previous consideration is easily seen
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
0 -> STOP
\begin_inset Newline newline
\end_inset

1 -> STOP
\begin_inset Newline newline
\end_inset

2 -> 1 0
\begin_inset Newline newline
\end_inset

3 -> 2 1 -> (1 0) 1
\begin_inset Newline newline
\end_inset

4 -> 3 2 -> (2 1) (1 0) -> ((1 0) 1) (1 0)
\begin_inset Newline newline
\end_inset

5 -> 4 3 -> ...
 -> ( ((1 0) 1) (1 0) ) ( (1 0) 1 )
\begin_inset Newline newline
\end_inset

6 -> 5 4 -> ( ( ((1 0) 1) (1 0) ) ( (1 0) 1 ) ) ( ((1 0) 1) (1 0) )
\begin_inset Newline newline
\end_inset

7 -> 6 5 -> ( ( ( ((1 0) 1) (1 0) ) ( (1 0) 1 ) ) ( ((1 0) 1) (1 0) ) )
 ( ( ((1 0) 1) (1 0) ) ( (1 0) 1 ) )
\end_layout

\begin_layout Plain Layout
...
\end_layout

\begin_layout Plain Layout
N(additional calls):
\end_layout

\begin_layout Plain Layout
0 -> 0
\begin_inset Newline newline
\end_inset

1 -> 0
\begin_inset Newline newline
\end_inset

2 -> 2
\begin_inset Newline newline
\end_inset

3 -> 3
\begin_inset Newline newline
\end_inset

4 -> 5
\begin_inset Newline newline
\end_inset

5 -> 8
\begin_inset Newline newline
\end_inset

6 -> 13
\begin_inset Newline newline
\end_inset

7 -> 21
\begin_inset Newline newline
\end_inset

...
\begin_inset Newline newline
\end_inset

n -> fib(n+1) for any n >= 2
\end_layout

\end_inset

 to lead to, in total, 
\begin_inset Formula $\mathrm{fib}(n+1)$
\end_inset

 internal calls to 
\begin_inset Formula $f()$
\end_inset

 for any 
\begin_inset Formula $n\ge2$
\end_inset

 (where — like in our program — 
\begin_inset Formula $\mathrm{fib}(0)=0$
\end_inset

, 
\begin_inset Formula $\mathrm{fib}(1)=1$
\end_inset

).
 The original runtime was thus 
\begin_inset Formula $O(\mathrm{fib}(n))$
\end_inset

.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Itemize
The Fibonacci sequence grows quickly as 
\begin_inset Formula $n$
\end_inset

 increases.
 As a few lines of NumPy — when added to the above improved program — will
 tell you, 
\begin_inset Formula $\log_{10}(\mathrm{fib}(n+1))-\log_{10}(\mathrm{fib}(n))\approx0.209$
\end_inset

 for any 
\begin_inset Formula $n\gtrsim20$
\end_inset

.
\end_layout

\begin_layout Itemize
Contrast this with polynomial runtime.
 Since 
\begin_inset Formula $\log_{10}(n^{k})=k\log_{10}(n)$
\end_inset

, we have:
\begin_inset Formula 
\[
\log_{10}((n+1)^{k})-\log_{10}(n^{k})=k\left[\log_{10}(n+1)-\log_{10}(n)\right]=k\log_{10}(1+1/n)\;,
\]

\end_inset

which tends to zero as 
\begin_inset Formula $n\rightarrow\infty$
\end_inset

.
 Hence the Fibonacci sequence, for large enough
\begin_inset space ~
\end_inset


\begin_inset Formula $n$
\end_inset

, grows faster than any polynomial.
 (In the exact mathematical sense that for any fixed 
\begin_inset Formula $k>0$
\end_inset

, there exists 
\begin_inset Formula $n_{0}=n_{0}(k)$
\end_inset

 such that...)
\end_layout

\begin_deeper
\begin_layout Itemize
Although 
\begin_inset Formula $n^{k}$
\end_inset

 is, mathematically speaking, a monomial, the standard technical term is
 polynomial runtime, because the 
\begin_inset Formula $O(\dots)$
\end_inset

 discards any asymptotically non-dominant terms.
\end_layout

\end_deeper
\begin_layout Standard
Some tricks can also be gleaned from the improved program:
\end_layout

\begin_layout Itemize

\family typewriter
memo
\family default
 is a static member
\begin_inset Index idx
status open

\begin_layout Plain Layout
Static!member
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Member!static
\end_layout

\end_inset

, shared across all instances of Fibo.
 Thus all current and future instances (during the same run of the program)
 benefit when one instance saves a result to 
\family typewriter
memo
\family default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Even the internal call for 
\begin_inset Formula $f(n-2)$
\end_inset

 will benefit from the call to 
\begin_inset Formula $f(n-1)$
\end_inset

.
\end_layout

\begin_layout Itemize
Even in a multithreaded scenario, the GIL
\begin_inset Index idx
status open

\begin_layout Plain Layout
GIL (global interpreter lock)
\end_layout

\end_inset

 prevents 
\emph on
race conditions
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Race condition (parallel computing bug)
\end_layout

\end_inset

, i.e.
 roughly speaking, inappropriate simultaneous reads and writes that can
 have unpredictable results.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Race_condition"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In Python, defining the magic method 
\family typewriter
__call__()
\family default
 makes the object 
\emph on
callable
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Callable object instance
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Object instance, callable
\end_layout

\end_inset

 The instances of the class can then be called as if they were functions
 (as 
\family typewriter
main()
\family default
 does above).
\end_layout

\begin_deeper
\begin_layout Itemize
Like 
\begin_inset Quotes erd
\end_inset


\family typewriter
operator()
\family default

\begin_inset Quotes eld
\end_inset

 in C++
\begin_inset Index idx
status open

\begin_layout Plain Layout
C++
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
This is of course just syntactic sugar
\begin_inset Index idx
status open

\begin_layout Plain Layout
Syntactic sugar
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Sugar, syntactic
\end_layout

\end_inset

 — we could have as well defined a method called 
\family typewriter
f()
\family default
 and used that — but some programmers find using the callable object syntax
 more aesthetic.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Syntactic_sugar"

\end_inset


\end_layout

\begin_layout Itemize
In this example, 
\family typewriter
__call__()
\family default
 itself calls itself: 
\family typewriter
self(k-1)
\family default
 actually means 
\family typewriter
self.__call__(k-1)
\family default
.
 We used this to implement the recursion
\begin_inset Index idx
status open

\begin_layout Plain Layout
Recursion
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Recursion_(computer_science)"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Python modules often define a module-level constant called 
\family typewriter
__version__
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Version number, of Python modules
\end_layout

\end_inset

 This is the standard way to inform the user (and other Python programs)
 about the module version.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

Let us end this topic with two final examples from real projects I've worked
 on.
\end_layout

\begin_layout Standard
The flip side of 
\emph on
document the why, not the how
\emph default
 is that 
\emph on
sometimes it is useful to document the how
\emph default
 — if you stick to a general enough overview, which is sometimes easily
 lost in the details in the actual code.
 The description of low-level technical details should be left to the code
 itself.
 If it is not readable, it should be rewritten more clearly.
\end_layout

\begin_layout Standard
But this is sometimes impossible.
 The code may already be as clear as it can be; some things are inherently
 complex.
 In those cases, especially with particularly cryptic-looking vectorized
 algorithms in numerics, it may be very helpful to give a functional equivalent
 of the code — albeit one that would run very slowly, if actually used —
 in the comments.
 It doesn't matter if the 
\emph on
explanation
\emph default
 uses nested for loops, as long as it gets the idea across.
\end_layout

\begin_layout Standard
An example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

    I,J,IJ = util.index.genidx( (nx, ny)  )  # see genidx() below
\end_layout

\begin_layout Plain Layout

    K,L,KL = util.index.genidx( (nxb,nyb) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # loop only over rows of the equation system
\end_layout

\begin_layout Plain Layout

    for i,j,ij in zip(I,J,IJ):
\end_layout

\begin_layout Plain Layout

        A[nf*ij,  KL] = Du[i,K] * Av[j,L]
\end_layout

\begin_layout Plain Layout

        A[nf*ij+1,KL] = Au[i,K] * Dv[j,L]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    b[nf*IJ]   = dpsi_dx[I,J]  # RHS for B_x
\end_layout

\begin_layout Plain Layout

    b[nf*IJ+1] = dpsi_dy[I,J]  # RHS for lambda_xx
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#    # the above is equivalent to this much slower version:
\end_layout

\begin_layout Plain Layout

#    #
\end_layout

\begin_layout Plain Layout

#    # equation system row
\end_layout

\begin_layout Plain Layout

#    for j in range(ny):
\end_layout

\begin_layout Plain Layout

#        for i in range(nx):
\end_layout

\begin_layout Plain Layout

#            ij = np.ravel_multi_index( (i,j), (nx,ny) )
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#            # equation system column
\end_layout

\begin_layout Plain Layout

#            for l in range(nyb):
\end_layout

\begin_layout Plain Layout

#                for k in range(nxb):
\end_layout

\begin_layout Plain Layout

#                    kl = np.ravel_multi_index( (k,l), (nxb,nyb) )
\end_layout

\begin_layout Plain Layout

#                    A[nf*ij,  kl] = Du[i,k] * Av[j,l]
\end_layout

\begin_layout Plain Layout

#                    A[nf*ij+1,kl] = Au[i,k] * Dv[j,l]
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#            b[nf*ij]   = dpsi_dx[i,j]  # RHS for B_x
\end_layout

\begin_layout Plain Layout

#            b[nf*ij+1] = dpsi_dy[i,j]  # RHS for lambda_xx
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

The module containing 
\family typewriter
genidx()
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Meshgrid indexing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Indexing!meshgrids
\end_layout

\end_inset

 is a study in informative commenting and docstringing (although maybe its
 module docstring is not):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

"""Utilities for converting indices.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Created on Fri Mar 24 13:21:07 2017
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@author: Juha Jeronen, juha.jeronen@tut.fi
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# These generalize to the nD case given below.
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#def genidx2D( nx,ny ):
\end_layout

\begin_layout Plain Layout

#    """Generate index vectors to a 2D meshgrid and the corresponding raveled
 array."""
\end_layout

\begin_layout Plain Layout

#    i = range(nx)
\end_layout

\begin_layout Plain Layout

#    j = range(ny)
\end_layout

\begin_layout Plain Layout

#    I,J = np.meshgrid( i,j, indexing='ij' )
\end_layout

\begin_layout Plain Layout

#    Ilin = np.reshape(I,-1)
\end_layout

\begin_layout Plain Layout

#    Jlin = np.reshape(J,-1)
\end_layout

\begin_layout Plain Layout

#    IJ = np.ravel_multi_index( (Ilin,Jlin), (nx,ny) )
\end_layout

\begin_layout Plain Layout

#    return (Ilin,Jlin,IJ)
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#def genidx3D( nx,ny,nz ):
\end_layout

\begin_layout Plain Layout

#    """Generate index vectors to a 3D meshgrid and the corresponding raveled
 array."""
\end_layout

\begin_layout Plain Layout

#    i = range(nx)
\end_layout

\begin_layout Plain Layout

#    j = range(ny)
\end_layout

\begin_layout Plain Layout

#    k = range(nz)
\end_layout

\begin_layout Plain Layout

#    I,J,K = np.meshgrid( i,j,k, indexing='ij' )
\end_layout

\begin_layout Plain Layout

#    Ilin = np.reshape(I,-1)
\end_layout

\begin_layout Plain Layout

#    Jlin = np.reshape(J,-1)
\end_layout

\begin_layout Plain Layout

#    Klin = np.reshape(K,-1)
\end_layout

\begin_layout Plain Layout

#    IJK = np.ravel_multi_index( (Ilin,Jlin,Klin), (nx,ny,nz) )
\end_layout

\begin_layout Plain Layout

#    return (Ilin,Jlin,Klin,IJK)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def genidx( shp ):
\end_layout

\begin_layout Plain Layout

    """Generate index vectors to an nD meshgrid and the corresponding raveled
 array.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Parameters:
\end_layout

\begin_layout Plain Layout

    shp: tuple of int
\end_layout

\begin_layout Plain Layout

        Shape of the meshgrid (nx, ny, nz, ...).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Returns:
\end_layout

\begin_layout Plain Layout

    tuple (I_0, I_1, ..., I_{n-1}, R), where:
\end_layout

\begin_layout Plain Layout

        I_0, I_1, ..., I_{n-1}: rank-1 arrays
\end_layout

\begin_layout Plain Layout

             These index each dimension of the meshgrid as M[I_0, I_1, ...,
 I_{n-1}].
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        R: rank-1 array
\end_layout

\begin_layout Plain Layout

             Corresponding indices to the corresponding raveled array.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

so that M[I_0[j], I_1[j], ..., I_{n-1}[j]] and raveled[R[j]] denote the same
 grid point.
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

    if np.array(shp).ndim > 1:
\end_layout

\begin_layout Plain Layout

        raise ValueError("shp must be a list or a rank-1 array")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Create index vectors for each dimension of the grid.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Note that
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    #    shp = (n_0, n_1, ..., n_{d-1})
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # The kth vector has length shp[k].
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    i = [ range(nk) for nk in shp ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Create the meshgrid:
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    #     I = (I_0, I_1, ..., I_{d-1})
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # where each I_k is a rank-d array of shape shp (accepting a multi-index
 of d dimensions),
\end_layout

\begin_layout Plain Layout

    # where the value is the grid point index on the kth axis.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # This is used just to generate all prod(shp) combinations of the per-axis
 indices.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    I = np.meshgrid( *i, indexing='ij' )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Flatten the meshgrid to remove grid structure, so that the tuple
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    #     pj = ( Ilin[0][j], Ilin[1][j], ..., Ilin[-1][j] )
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # gives the indices, on each axis, of the jth grid point.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Each Ilin[k]:
\end_layout

\begin_layout Plain Layout

    # - is a rank-1 array of length prod(shp).
\end_layout

\begin_layout Plain Layout

    # - takes on values in the range 0, 1, ..., shp[k]-1.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Ilin is now the multi-index.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    Ilin = [ Ik.reshape(-1) for Ik in I ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Generate the raveled index that corresponds to the multi-index.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # This numbers the grid points sequentially.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    R = np.ravel_multi_index( Ilin, shp )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    out = list(Ilin)  # just for semantic tidiness; we don't actually need
 a copy
\end_layout

\begin_layout Plain Layout

                      # as the original Ilin is no longer needed
\end_layout

\begin_layout Plain Layout

    out.append( R )
\end_layout

\begin_layout Plain Layout

    return out
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Here is a final example, incidentally also about index conversion, and here
 too more explanation than actual code.
 This obtains efficient access for updating data in a CSR (compressed sparse
 row) sparse matrix
\begin_inset Index idx
status open

\begin_layout Plain Layout
Sparse matrices
\end_layout

\end_inset

 without rebuilding the sparsity pattern.
 A more detailed use case is given in the docstring of 
\family typewriter
CSR_location_of_nonzeros_as_IjIk()
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def IjIk_to_CSR_index(A, Ij, Ik):
\end_layout

\begin_layout Plain Layout

    """Convert vectors of (row,column) index pairs to raw CSR matrix data
 vector indices.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Parameters:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    A: scipy.sparse.csr_matrix
\end_layout

\begin_layout Plain Layout

        The sparse matrix in CSR format.
\end_layout

\begin_layout Plain Layout

    Ij: rank-1 np.array
\end_layout

\begin_layout Plain Layout

        Row indices.
\end_layout

\begin_layout Plain Layout

    Ik: rank-1 np.array
\end_layout

\begin_layout Plain Layout

        Column indices.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Returns:
\end_layout

\begin_layout Plain Layout

        rank-1 np.array of indices to A.data, with result[k]
\end_layout

\begin_layout Plain Layout

        corresponding to (Ij[k],Ik[k]).
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    Requirements (NOT checked):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Ij and Ik must be of the same length.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Each referred matrix element (Ij[k],Ik[k]) must already exist within
\end_layout

\begin_layout Plain Layout

    the sparsity pattern of A.
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

    result = np.zeros( (np.size(Ij),), dtype=int )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # indptr contains an extra element pointing one-past-end, so diff(indptr)
\end_layout

\begin_layout Plain Layout

    # returns the number of data elements on each row.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # It is the same as the number of entries in A.indices on that row,
\end_layout

\begin_layout Plain Layout

    # containing the column numbers of the corresponding data elements.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    dlen = np.diff( A.indptr )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Keep only entries for rows which we refer to:
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    dlen = dlen[Ij]
\end_layout

\begin_layout Plain Layout

    imax = np.max( dlen )  # largest number of nonzeroes on one row
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # Do the actual index finding in a vectorized manner, so that we
\end_layout

\begin_layout Plain Layout

    # never need to Python-loop more than imax times.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Ij and Ik may have any number of elements; the only requirement is
\end_layout

\begin_layout Plain Layout

    # that each entry (Ij[k],Ik[k]) exists in the sparsity pattern of A.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # The last few rows may need separate handling, because in a FEM matrix
\end_layout

\begin_layout Plain Layout

    # especially the last row is likely to have fewer nonzero elements than
\end_layout

\begin_layout Plain Layout

    # the maximum number encountered.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Hence, if we tried to walk it up to this maximum (which we can do
 on all other
\end_layout

\begin_layout Plain Layout

    # rows to keep things vectorized), we would try to read past the end
 of data,
\end_layout

\begin_layout Plain Layout

    # triggering an IndexError from NumPy.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # To prevent this, we copy the index data into a slightly larger array,
\end_layout

\begin_layout Plain Layout

    # allowing us to read a few elements past the end of the data.
 Any results
\end_layout

\begin_layout Plain Layout

    # past the end of a row will not be used, but computing them must be
 possible
\end_layout

\begin_layout Plain Layout

    # in order to keep the computation fully vectorized.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # Allocating uninitialized memory is fine, since the remainder is not
 used
\end_layout

\begin_layout Plain Layout

    # for anything sensible.
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    aimax = np.size( A.indices )
\end_layout

\begin_layout Plain Layout

    temp_indices = np.empty( (aimax+imax,), dtype=int )
\end_layout

\begin_layout Plain Layout

    temp_indices[0:aimax] = A.indices
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for i in range(imax):
\end_layout

\begin_layout Plain Layout

        # Explanation of black magic:
\end_layout

\begin_layout Plain Layout

        #   - (i < dlen) matches only for those elements where we have
\end_layout

\begin_layout Plain Layout

        #     not exceeded the length of the data of the current row.
\end_layout

\begin_layout Plain Layout

        #     Hence, at each row, we effectively stop looking once the
\end_layout

\begin_layout Plain Layout

        #     length of data is exceeded.
\end_layout

\begin_layout Plain Layout

        #
\end_layout

\begin_layout Plain Layout

        #   - A.indices[ A.indptr[Ij] ] are the column indices of the first
 entry on rows Ij.
\end_layout

\begin_layout Plain Layout

        #     Using temp_indices[] instead of A.indices[] allows (nonsensical)
 reads past the
\end_layout

\begin_layout Plain Layout

        #     end of the array, so that we won't need special handling for
 the last few rows.
\end_layout

\begin_layout Plain Layout

        #
\end_layout

\begin_layout Plain Layout

        #   - Then A.indices[] at this location +1, +2, ...
 +(dlen-1) are the column indices
\end_layout

\begin_layout Plain Layout

        #     of the other entries at these rows, hence at ith iteration
 of the loop we look
\end_layout

\begin_layout Plain Layout

        #     at this +i.
\end_layout

\begin_layout Plain Layout

        #
\end_layout

\begin_layout Plain Layout

        #   - The check for equality with Ik returns True (1) only if the
 column index
\end_layout

\begin_layout Plain Layout

        #     is the one we are searching for.
 Hence, at each element of the result,
\end_layout

\begin_layout Plain Layout

        #     we sum something nonzero only once (as there are no duplicates;
 in the CSR
\end_layout

\begin_layout Plain Layout

        #     format, each entry of A has a unique (row,column) index pair).
\end_layout

\begin_layout Plain Layout

        #
\end_layout

\begin_layout Plain Layout

        #   - The first two factors in the product are boolean, serving
 only to
\end_layout

\begin_layout Plain Layout

        #     switch the last factor on (1*...) or off (0*...).
\end_layout

\begin_layout Plain Layout

        #
\end_layout

\begin_layout Plain Layout

        #   - The final multiplication by (A.indptr[Ij] + i) gets us the
 data we want,
\end_layout

\begin_layout Plain Layout

        #     when the loop finds the match.
\end_layout

\begin_layout Plain Layout

        #
\end_layout

\begin_layout Plain Layout

        idx = A.indptr[Ij] + i
\end_layout

\begin_layout Plain Layout

        result += (i < dlen) * (temp_indices[ idx ] == Ik) * idx
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def CSR_location_of_nonzeros_as_IjIk(A):
\end_layout

\begin_layout Plain Layout

    """Companion to IjIk_to_CSR_index().
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Returns the row and column index vectors corresponding to ALL nonzero
 entries
\end_layout

\begin_layout Plain Layout

    of a CSR matrix.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    In a sense, this is the inverse operation to IjIk_to_CSR_index(),
\end_layout

\begin_layout Plain Layout

    converting "to the other direction".
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Where this is needed: consider the following example, which takes in
\end_layout

\begin_layout Plain Layout

    sparse CSR matrices A and B, and creates another sparse CSR matrix C.
\end_layout

\begin_layout Plain Layout

    The sparsity patterns of A and B can be different (this is important
\end_layout

\begin_layout Plain Layout

    for the example to make any sense).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    C = A + B
\end_layout

\begin_layout Plain Layout

    Ij,Ik = CSR_location_of_nonzeros_as_IjIk(A)
\end_layout

\begin_layout Plain Layout

    dataind_A = IjIk_to_CSR_index(C, Ij, Ik)
\end_layout

\begin_layout Plain Layout

    Ij,Ik = CSR_location_of_nonzeros_as_IjIk(B)
\end_layout

\begin_layout Plain Layout

    dataind_B = IjIk_to_CSR_index(C, Ij, Ik)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Now "dataind_A" contains the raw CSR data vector indices of those elements
 in "C",
\end_layout

\begin_layout Plain Layout

    which correspond to the contribution of the CSR matrix "A".
 Likewise, "dataind_B"
\end_layout

\begin_layout Plain Layout

    contains the indices in "C" of the contribution from "B".
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    If all three matrices have sorted indices (guaranteeing that the internal
 data storage
\end_layout

\begin_layout Plain Layout

    order is the same), this allows us later to directly update the data
 of "C" with data
\end_layout

\begin_layout Plain Layout

    from another CSR matrix, which shares its sparsity pattern with the
 example's original
\end_layout

\begin_layout Plain Layout

    "A" (or "B").
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    This, in turn, can be useful e.g.
 in some implicit time integration schemes, which contain
\end_layout

\begin_layout Plain Layout

    expressions such as "C = A - dt*B".
 Here A and B have different sparsity patterns, and "C"
\end_layout

\begin_layout Plain Layout

    must be recomputed at each timestep, or in nonlinear problems, even
 at each iteration.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    The idea is to create the matrix C (creating the correct sparsity pattern)
 only once,
\end_layout

\begin_layout Plain Layout

    and then directly manipulate its data vector, avoiding unnecessary and
 expensive
\end_layout

\begin_layout Plain Layout

    regeneration of the sparsity pattern every time the data needs to be
 recomputed.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Continuing the example, the above expression can be computed efficiently
 as
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    C.data[:] = 0.0  # clear old data
\end_layout

\begin_layout Plain Layout

    C.data[ dataind_A ]  = A.data
\end_layout

\begin_layout Plain Layout

    C.data[ dataind_B ] -= dt*B.data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    (To be efficient, it is assumed that dataind_A and dataind_B are computed
 only once
\end_layout

\begin_layout Plain Layout

     and cached.)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    At this point, it should be clear why sorted indices are needed to guarantee
 that
\end_layout

\begin_layout Plain Layout

    this trick works.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Parameters:
\end_layout

\begin_layout Plain Layout

        A: CSR matrix (of type scipy.sparse.csr_matrix)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Returns:
\end_layout

\begin_layout Plain Layout

        tuple (Ij,Ik): pair of rank-1 np.arrays, each having length A.nnz.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    The matrix element stored at A.data[k] has row and column indices (Ij[k],Ik[k
]).
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

    Ij = []
\end_layout

\begin_layout Plain Layout

    Ik = []
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    dlen = np.diff( A.indptr )
\end_layout

\begin_layout Plain Layout

    for j,rowstart in enumerate(A.indptr[:-1]):
\end_layout

\begin_layout Plain Layout

        Ij.extend( [j for k in range(dlen[j])]  )  # [j, j, ..., j], dlen[j]
 copies
\end_layout

\begin_layout Plain Layout

        Ik.extend( A.indices[rowstart:(rowstart+dlen[j])] )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return (np.array(Ij, dtype=int), np.array(Ik, dtype=int))
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Assertions
\begin_inset Index idx
status open

\begin_layout Plain Layout
Assertions (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering!assertions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In software, as in many fields of engineering, reliability is important.
 If a failure occurs silently, the program state almost always becomes corrupted
 in some way.
 This will eventually lead to a visible error, but often much later, long
 after the context of the original failure has been lost.
 It is then almost impossible to find the bug that caused the error.
 The software engineering solution, to eliminate this situation, is to make
 the program 
\emph on
fail fast
\emph default
.
\end_layout

\begin_layout Standard
A program that fails fast
\begin_inset Index idx
status open

\begin_layout Plain Layout
Fail-fast (programming principle)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!principle!fail-fast
\end_layout

\end_inset

, immediately reports any condition that is likely to indicate failure and
 stops processing, rather than continuing with a possibly flawed process.
 When accompanied by a sufficiently informative error message, this makes
 the cause of the failure much easier to find, and fix early in software
 development.
\end_layout

\begin_layout Standard

\emph on
Assertions
\emph default
 are the key tool for the fail-fast approach.
 They catch when a critical assumption does not hold, halt program execution
 (i.e.
 intentionally cause a controlled crash), and display the specified error
 message (which can contain arbitrary information, as set by the programmer).
 Assertions should be made to trigger on failures of 
\emph on
internal
\emph default
 assumptions that should always hold, if the program is implemented correctly.
 Failures of assumptions about 
\emph on
external
\emph default
 state — such as invalid inputs, or memory allocation errors — should raise
 an exception instead.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Fail-fast"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Assertion_(software_development)"

\end_inset


\end_layout

\begin_layout Standard
Generally speaking, control flow in software can be complex; program state
 may change in nontrivial ways.
 Assertions make your assumptions explicit, even if you're sure that in
 your current code, they always hold.
 (If the code is good, you might reuse pieces of it much later, in a different
 context, with different internal assumptions.)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm
\end_layout

\end_inset

For example, if you have a function that generates a point inside a unit
 circle centered on 
\begin_inset Formula $x_{0}$
\end_inset

, and another (internal, not user-facing) function that then uses such a
 point as input, in this second function you can:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

assert np.sum( (x - x0)**2 ) < 1, "x = %s is not inside the circle" % (x)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

In any code following the assert (in the same function), you can then be
 certain that this 
\emph on
precondition
\emph default
 is fulfilled; because if not, the program will halt and alert you — the
 developer — to the invalid value that somehow got in.
\end_layout

\begin_layout Standard
We do not raise an exception; a failure here is an internal error.
 Contrast invalid inputs, which ultimately come from the user; or running
 out of memory, which is an external condition that may occur regardless
 of whether the program is implemented correctly.
 An exception alerts the 
\emph on
using
\emph default
 programmer; an assertion alerts the
\emph on
 developer
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm
\end_layout

\end_inset

There are also some finer points.
 Quoting:
\end_layout

\begin_layout Standard
Jim Shore: Fail Fast (IEEE Software, September/October 2004, 21–25):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://www.martinfowler.com/ieeeSoftware/failFast.pdf"

\end_inset


\end_layout

\begin_layout Standard

\emph on
When you’re writing a method, avoid writing assertions for problems in the
 method itself.
 Tests, particularly test-driven development, are a better way of ensuring
 the correctness of individual methods.
\end_layout

\begin_layout Standard

\emph on
Assertions shine in their ability to flush out problems in the seams of
 the system.
 Use them to show mistakes in how the rest of the system interacts with
 your method.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.2cm
\end_layout

\end_inset

Finally, assertions are related to the software design approach of 
\emph on
contract programming
\emph default
 (a.k.a.
 
\emph on
programming by contract; design by contract
\emph default
):
\begin_inset Index idx
status open

\begin_layout Plain Layout
Contract programming
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Programming!by contract
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Design by contract
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Design_by_contract"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://www.eiffel.com/values/design-by-contract/introduction/"

\end_inset


\end_layout

\begin_layout Standard
where they can be used to test 
\emph on
preconditions
\emph default
, 
\emph on
postconditions
\emph default
, and 
\emph on
invariants
\emph default
.
 For Python, programming by contract was proposed, in 2003, as PEP 316:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0316/"

\end_inset


\end_layout

\begin_layout Standard
This was, however, deferred, and the idea has not been proposed again.
 While there is currently no one obvious way to do it, as of late 2017,
 at least one actively maintained library exists:
\end_layout

\begin_layout Itemize
PyContracts
\begin_inset Note Note
status open

\begin_layout Plain Layout
 [as of late 2017, still actively maintained]
\end_layout

\end_inset

:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/AndreaCensi/contracts"

\end_inset


\end_layout

\begin_layout Itemize
There is also a DIY approach in the PythonDecoratorLibrary
\begin_inset Index idx
status open

\begin_layout Plain Layout
Decorator!for contract programming
\end_layout

\end_inset

:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://wiki.python.org/moin/PythonDecoratorLibrary#Pre-.2FPost-Conditions"

\end_inset


\begin_inset Note Note
status open

\begin_layout Itemize
Historical: reference implementation of PEP 316 [unmaintained]:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://www.wayforward.net/pycontract/"

\end_inset


\end_layout

\begin_layout Itemize
Historical: covenant [unmaintained]
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://bitbucket.org/kisielk/covenant/"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Tests
\begin_inset Index idx
status open

\begin_layout Plain Layout
Testing (software development)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering!tests
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Testing is an integral part of developing error-free software.
 Nowadays, much of testing is automated.
 To give some flavor of this, we will briefly introduce 
\emph on
unit testing
\emph default
, and just mention 
\emph on
coverage testing
\emph default
 and 
\emph on
integration testing
\emph default
.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Software_testing"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Unit_testing"

\end_inset


\family default

\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Integration_testing"

\end_inset


\end_layout

\begin_layout Standard
Unit testing
\begin_inset Index idx
status open

\begin_layout Plain Layout
Unit testing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Testing (software development)!unit
\end_layout

\end_inset

 aims to verify the correct working of 
\emph on
units
\emph default
, which are typically individual modules.
 
\emph on
Test-driven development
\emph default
 is a methodology related to this.
 Often unit tests come as separate modules, one for each unit of actual
 software to be tested.
 Unit tests must be manually created by the programmer, but software frameworks
 exist to automate the repetitive task of running them against each version
 of the software.
 For Python, popular testing frameworks include pytest
\begin_inset Index idx
status open

\begin_layout Plain Layout
pytest (testing framework)
\end_layout

\end_inset

 and nose
\begin_inset Index idx
status open

\begin_layout Plain Layout
nose (testing framework)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Unit testing is particularly applicable to scientific computing software,
 where the control flow is (almost) trivial, there are relatively few connection
s between parts, and many parts are of a nature that can be easily tested
 individually.
\end_layout

\begin_layout Standard
The main use of unit tests is to automatically catch any 
\emph on
regressions
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Regression (software bug)
\end_layout

\end_inset

, i.e.
 things that have worked previously, but have become broken when the code
 was modified.
\end_layout

\begin_layout Standard
Roughly speaking, a single test in a unit test module is a function invocation
 that produces a known result.
 The test module calls the function, and compares the computed result to
 the pre-determined answer.
 Any mismatch then triggers an assertion failure, or error logging, with
 a message identifying which test failed.
\end_layout

\begin_layout Standard
Any tricky corner cases can be listed once into a test script, and then
 all future versions of the software can be automatically verified whether
 they handle these cases correctly.
 (For example, even vs.
 odd length of input in some algorithms.)
\end_layout

\begin_layout Standard
Unit testing also helps test the handling of invalid inputs.
 Even if in your current code, you are certain there are no invalid inputs
 to a given routine, it may occur that when you later reuse the code in
 a different context, this is no longer the case.
 (For example, what to do if some size argument 
\begin_inset Formula $n$
\end_inset

 is negative, or of the wrong datatype.)
\end_layout

\begin_layout Standard
Why test invalid inputs? It is good practice to assume that the caller is
 actively trying to break your routine, especially in user-facing code,
 to protect the programmer using your routine (maybe you yourself) from
 innocent mistakes in calling code.
\end_layout

\begin_layout Standard
If the code is to be deployed for public use on the internet, things become
 more complicated.
 One must also take into account possible (likely!) black hat activity —
 i.e.
 intentional, often automated, attempts to take over control of the system
 hosting the code, by utilizing information security vulnerabilities in
 the code.
 For some material on such 
\emph on
dangerous programming mistakes
\emph default
, see, for example:
\end_layout

\begin_layout Standard

\family sans
\size small
\begin_inset CommandInset href
LatexCommand href
target "http://www.infoworld.com/article/2622611/application-security/developer-error--the-most-dangerous-programming-mistakes.html"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://cwe.mitre.org/top25/index.html"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset


\emph on
Coverage testing
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Coverage testing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Testing (software development)!coverage
\end_layout

\end_inset

 is a special kind of meta-testing that checks that the unit tests cover
 everything they should.
 Unless the unit tests are validated with such tools, it is likely that
 there exist some code paths that are overlooked (not executed) by the tests.
 For Python, there is Coverage.py:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://pypi.python.org/pypi/coverage"

\end_inset


\end_layout

\begin_layout Standard

\emph on
Coverage.py measures code coverage, typically during test execution.
 It uses the code analysis tools and tracing hooks provided in the Python
 standard library to determine which lines are executable, and which have
 been executed.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset

Finally, 
\emph on
integration testing
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Integration testing
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Testing (software development)!integration
\end_layout

\end_inset

 aims to verify that parts of the system (the units) work correctly as a
 whole.
 A recent trend in automated integration testing is 
\emph on
continuous integration
\emph default
, which automatically runs integration tests for the most recent version
 of the code daily.
 For open-source projects hosted on GitHub, Travis CI provides an online
 service that can be used for this.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Continuous_integration"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://travis-ci.org/"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Static analyzers and linting
\begin_inset Index idx
status open

\begin_layout Plain Layout
Static!code analysis
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Code analysis, static
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Roughly speaking, in its most basic form, 
\emph on
static code analysis
\emph default
 is a fancy name for looking at code, and reasoning about it 
\emph on
statically
\emph default
 — i.e.
 without running it.
 (To be technically correct, 
\emph on
static analysis
\emph default
 implies that any 
\emph on
dynamic
\emph default
 modifications to the code, e.g.
 class attributes created only at run time, will not be seen by the analysis.)
\end_layout

\begin_layout Standard
At this point it should come as no surprise that also for static code analysis,
 automated tools exist.
 If you have used an IDE such as the MATLAB
\begin_inset Index idx
status open

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset

 GUI, you may already be familiar with static analyzers.
 Many IDEs
\begin_inset Index idx
status open

\begin_layout Plain Layout
IDE (Integrated Development Environment)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Integrated Development Environment (IDE)
\end_layout

\end_inset

 use them to alert the programmer about things such as calls to undefined
 functions, and assigned to but unused variables.
\end_layout

\begin_layout Standard
The main benefit of using a static code analyzer is that it can catch many
 common mistakes before you even run your code.
 Also, static analysis may catch certain types of regressions
\begin_inset Index idx
status open

\begin_layout Plain Layout
Regression (software bug)
\end_layout

\end_inset

; e.g.
 search for the 
\begin_inset Quotes eld
\end_inset

old chestnut
\begin_inset Quotes erd
\end_inset

 in:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://medium.com/@acboulder/type-hints-are-scary-f52d07a36a31#.yt2e91emo"

\end_inset


\end_layout

\begin_layout Standard
(A variable was renamed, without changing the reference to it in the relevant
 exception handler.
 This broke error handling, causing the program to crash if an error occurred.)
\end_layout

\begin_layout Standard
The same tools may also perform automated quality control, such as keep
 track of remaining TODOs and FIXMEs, and of missing docstrings.
 They may also help enforce a particular 
\emph on
coding style
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Coding style
\end_layout

\end_inset

, which standardizes things such as the use of whitespace (where not semantic).
\end_layout

\begin_layout Standard
Python actually has an official coding style.
 You may want to look at it, if you want to go the extra mile to make your
 code look like 
\begin_inset Quotes eld
\end_inset

standard Python
\begin_inset Quotes erd
\end_inset

; anyone reading your code will appreciate this.
\end_layout

\begin_layout Standard
PEP 8: Style guide for Python code
\begin_inset Index idx
status open

\begin_layout Plain Layout
PEP 8 (Python style guide)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Python!style guide (PEP 8)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Style guide for Python (PEP 8)
\end_layout

\end_inset


\family sans
:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://www.python.org/dev/peps/pep-0008/"

\end_inset


\end_layout

\begin_layout Standard
Code Style in The Hitchhiker's Guide to Python:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://docs.python-guide.org/en/latest/writing/style/"

\end_inset


\end_layout

\begin_layout Standard
The Spyder
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset

 IDE for Python comes with two static analyzers, which perform different
 tasks: 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pyflakes (static code analyzer)
\end_layout

\end_inset

Pyflakes and Pylint
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pylint (static code analyzer)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Pyflakes is a fast and light tool to statically analyze single Python source
 files.
 In Spyder, it is integrated into the code editor, and by default runs automatic
ally every few seconds.
 It produces the exclamation marks in the margin (à la MATLAB) that alert
 about problems such as references to undefined names.
 Settings can be found in Tools 
\begin_inset Formula $\rhd$
\end_inset

 Preferences 
\begin_inset Formula $\rhd$
\end_inset

 Editor 
\begin_inset Formula $\rhd$
\end_inset

 Code Introspection/Analysis.
\end_layout

\begin_layout Standard
Pyflakes has a friend called pycodestyle
\begin_inset Index idx
status open

\begin_layout Plain Layout
pycodestyle (static code style analyzer)
\end_layout

\end_inset

 that checks the coding style against PEP
\begin_inset space ~
\end_inset

8.
 Both are packaged into flake8.
 Spyder includes this, too; realtime PEP
\begin_inset space ~
\end_inset

8 code style analysis can be toggled in the aforementioned settings.
\end_layout

\begin_layout Standard
For fixing the coding style of an existing code to conform to PEP
\begin_inset space ~
\end_inset

8, see the autopep8
\begin_inset Index idx
status open

\begin_layout Plain Layout
autopep8 (code style formatter)
\end_layout

\end_inset

 package on PyPI, which can automatically fix most issues detected by pycodestyl
e.
\end_layout

\begin_layout Standard
Pylint is more thorough, and takes some time to analyze the code when invoked.
 In Spyder, Pylint is found at Source 
\begin_inset Formula $\rhd$
\end_inset

 Run static code analysis.
 This produces a report, where the individual items can be clicked to jump
 to the relevant line in the code.
\end_layout

\begin_layout Standard
Very minimal settings can be found in Spyder in Tools 
\begin_inset Formula $\rhd$
\end_inset

 Preferences 
\begin_inset Formula $\rhd$
\end_inset

 Static code analysis, but customizing which warnings to emit requires supplying
 a configuration file (
\family typewriter
pylintrc
\family default
).
 Pylint is rather pedantic by default; for most users, I would recommend
 creating a configuration file to suppress any unwanted warnings, that may
 otherwise hide the useful ones under all the noise.
 For how to do this, see below.
\end_layout

\begin_layout Standard
Some links regarding static analyzers:
\end_layout

\begin_layout Itemize
The Python Code Quality Authority
\begin_inset Index idx
status open

\begin_layout Plain Layout
PyCQA (Python Code Quality Authority)
\end_layout

\end_inset

 is the home of many static analysis tools for Python:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://github.com/PyCQA"

\end_inset


\end_layout

\begin_layout Itemize
Pyflakes project page:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://github.com/PyCQA/pyflakes"

\end_inset


\end_layout

\begin_layout Itemize
Pylint documentation:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://pylint.readthedocs.io/en/latest/"

\end_inset


\end_layout

\begin_layout Itemize
Why static analyzers are often called some variant of 
\emph on
lint
\emph default
:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Lint_(software)"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Configuring pylint
\end_layout

\begin_layout Standard
To create a 
\family typewriter
pylintrc
\family default
, first invoke
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

pylint --generate-rcfile
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

to obtain a file containing up-to-date default settings.
 Then, a good first approximation of useful enable/disable settings can
 be found here (search for 
\begin_inset Quotes eld
\end_inset

pylintrc
\begin_inset Quotes erd
\end_inset

):
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://medium.com/@acboulder/type-hints-are-scary-f52d07a36a31"

\end_inset


\end_layout

\begin_layout Standard
As of late 2017, remove 
\family typewriter
unidiomatic-typecheck
\family default
 before pasting the rest into your config; this flag seems obsolete.
\end_layout

\begin_layout Standard
Additionally, you may want to make a few specific settings to suppress some
 noise in projects that use NumPy (i.e.
 probably all of your projects).
 See:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/a/35259944"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset

Explicitly, 
\series bold
here are all the customizations
\series default
 to 
\family typewriter
pylintrc
\family default
 (unchanged settings not shown):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

[MASTER]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

extension-pkg-whitelist=numpy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[TYPECHECK]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ignored-classes=SQLObject,numpy
\end_layout

\begin_layout Plain Layout

ignored-modules=numpy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[MESSAGES CONTROL]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

enable=bad-indentation,mixed-indentation,unnecessary-semicolon,superfluous-paren
s
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

disable=format,design,similarities,cyclic-import,import-error,broad-except,no-se
lf-use,
\end_layout

\begin_layout Plain Layout

        no-name-in-module,invalid-name,abstract-method,star-args,import-self,no-
init,
\end_layout

\begin_layout Plain Layout

        locally-disabled 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hsepline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All the disable flags are to be written on the same line.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset

Finally, save a copy of the modified 
\family typewriter
pylintrc
\family default
 somewhere safe (where you can find it later).
\end_layout

\begin_layout Standard
If you want to use the same Pylint settings for all of your projects, in
 *nix (Linux, OS X) you can save the configuration as 
\family typewriter
~/.pylintrc
\family default
.
\end_layout

\begin_layout Standard
If you want to customize the settings for different projects separately,
 make a copy of 
\family typewriter
pylintrc
\family default
 into the project directory of each project you want to check using Pylint.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Debuggers
\begin_inset Index idx
status open

\begin_layout Plain Layout
Debugging
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering!debugging
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
From the viewpoint of typical programming mistakes, it is interesting that
 in a sense, the development of GUI applications and scientific computing
 codes fall on the opposite ends of a spectrum.
 In GUI applications, algorithms are often trivial, but control flow is
 extremely nonlinear — event-driven and dependent on the user's actions.
 This leads to a combinatorial explosion of possible code paths, which makes
 difficult to cover all possibilities.
 In scientific computing, the control flow is often trivial, but the algorithms
 are complex — leaving room for bugs to hide in them.
\end_layout

\end_inset

There are many approaches to hunting down programming mistakes.
 Static analyzers help somewhat; judicious use of 
\family typewriter
print()
\family default
 (and plotting) helps a bit more; but there are bugs that are fastest found
 with an interactive debugger that allows setting breakpoints, and live
 inspection of program state.
 Many MATLAB users are likely already familiar with this.
\end_layout

\begin_layout Standard
Also in the Python world, IDEs
\begin_inset Index idx
status open

\begin_layout Plain Layout
IDE (Integrated Development Environment)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Integrated Development Environment (IDE)
\end_layout

\end_inset

 have a graphical debugger.
 How to use the debugger in Spyder
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
For interactive debugging, the program must be run inside the debugger.
\end_layout

\begin_deeper
\begin_layout Itemize
Instead of starting the program normally (Run 
\begin_inset Formula $\rhd$
\end_inset

 Run), in the Spyder menu choose Debug 
\begin_inset Formula $\rhd$
\end_inset

 Debug.
\end_layout

\begin_layout Itemize
As with all developer tools that hook into the code while it runs, this
 will make the program run more slowly than usual.
\end_layout

\end_deeper
\begin_layout Itemize
Program execution is paused when the debugger hits a 
\emph on
breakpoint
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Breakpoint (debugging)
\end_layout

\end_inset

 in your source code.
\end_layout

\begin_deeper
\begin_layout Itemize
You can set breakpoints basically on any 
\emph on
executable line
\emph default
 in the code (i.e.
 anywhere except in comments).
\end_layout

\begin_deeper
\begin_layout Itemize
In Spyder, breakpoints are added by double-clicking the marginal (on the
 left) at the source line where the breakpoint is to be set or cleared.
 Also in the menu as Debug 
\begin_inset Formula $\rhd$
\end_inset

 Set/Clear breakpoint.
\end_layout

\end_deeper
\begin_layout Itemize
The debugger will pause the program just 
\emph on
before
\emph default
 executing the line that has the breakpoint.
\end_layout

\begin_layout Itemize
In Python, setting a breakpoint on the 
\family typewriter
def
\family default
 line of a function means that you want to pause when the function becomes
 
\emph on
defined
\emph default
 (i.e.
 when the 
\family typewriter
def
\family default
 line is executed).
 If you want to pause when the function is 
\emph on
entered
\emph default
, place the breakpoint inside the function body.
\end_layout

\begin_layout Itemize
A 
\emph on
conditional breakpoint
\emph default
 will pause when hit, but only if a user-given expression evaluates to 
\family typewriter
True
\family default
.
 The expression is evaluated each time the breakpoint is hit.
\end_layout

\end_deeper
\begin_layout Itemize
Whenever the program is paused, you can inspect any variables in the current
 scope in Variable explorer.
\end_layout

\begin_deeper
\begin_layout Itemize
User manual:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://pythonhosted.org/spyder/variableexplorer.html"

\end_inset


\end_layout

\begin_layout Itemize
Some data structures such as lists and NumPy arrays can be double-clicked
 for details.
\end_layout

\begin_layout Itemize
Expressions can be entered in the console to print their values, but (as
 of Spyder 3.2.3) tab completion of variable names is not available while
 debugging.
\end_layout

\begin_deeper
\begin_layout Itemize
This is a current limitation of Spyder, according to the developers:
\begin_inset Newline newline
\end_inset


\family sans
\size small

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/25912291/no-autocompletion-with-the-ipdb-prompt-when-using-spyder"

\end_inset


\end_layout

\begin_layout Itemize
In bare IPython+ipdb, tab completion works:
\family sans

\begin_inset Newline newline
\end_inset


\size small

\begin_inset CommandInset href
LatexCommand href
target "https://stackoverflow.com/questions/15122375/get-ipython-tab-completion-for-ipdb"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
In the debug menu:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Debug
\emph default
 loads the program into the debugger, but does not start it yet.
\end_layout

\begin_deeper
\begin_layout Itemize
Use 
\emph on
Continue
\emph default
 to start the program.
\end_layout

\begin_layout Itemize
This is different from some graphical debuggers, where 
\emph on
Debug
\emph default
 both loads and starts the program.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Continue
\emph default
 resumes program execution until the next breakpoint is hit, or until the
 program terminates.
\end_layout

\begin_layout Itemize

\emph on
Step
\emph default
 executes one line and pauses.
\end_layout

\begin_layout Itemize

\emph on
Step Into
\emph default
 enters into the next function called on the current line and pauses.
\end_layout

\begin_layout Itemize

\emph on
Step Return
\emph default
 resumes until the current function returns, and pauses just before executing
 the return.
\end_layout

\begin_layout Itemize

\emph on
Stop
\emph default
 terminates the program and closes the debugger.
 (Also, red button above console window.)
\end_layout

\end_deeper
\begin_layout Itemize
There is no separate 
\begin_inset Quotes eld
\end_inset

Restart
\begin_inset Quotes erd
\end_inset

.
 To reset and debug from the beginning: 
\emph on
Stop
\emph default
, 
\emph on
Debug
\emph default
, 
\emph on
Continue
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Keyboard shortcuts: Ctrl+Shift+F12 to Stop, Ctrl+F5 to Debug, and Ctrl+F12
 to Continue.
\end_layout

\begin_layout Itemize
Or use the buttons in the toolbar.
\end_layout

\end_deeper
\begin_layout Standard
Other notes:
\end_layout

\begin_layout Itemize

\family sans
\begin_inset Note Note
status open

\begin_layout Plain Layout
Spyder docs on debugging (rather spartan):
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://pythonhosted.org/spyder/debugging.html"

\end_inset


\end_layout

\end_inset


\family typewriter
pdb
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
pdb (Python debugger)
\end_layout

\end_inset

 is Python's command-line debugger and Python module
\family sans
.
\end_layout

\begin_deeper
\begin_layout Itemize
If you really want to go there, see this hands-on introduction:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://pythonconquerstheuniverse.wordpress.com/2009/09/10/debugging-in-python/"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Currently Spyder does not provide a graphical frontend for debugging Cython
 programs.
\end_layout

\begin_deeper
\begin_layout Itemize
Cython comes with the command-line tool 
\family typewriter
cygdb
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout
cygdb (Cython debugger)
\end_layout

\end_inset

, which is a frontend to 
\family typewriter
gdb
\family default
 (the GNU Debugger), adding a layer that understands Cython code (if the
 binary is compiled with debug options enabled).
\end_layout

\begin_layout Itemize
We will not delve further into Cython debugging; for more, see the user
 manual:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://cython.readthedocs.io/en/latest/src/userguide/debugging.html"

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Profilers
\begin_inset Index idx
status open

\begin_layout Plain Layout
Profiling!performance
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Profiling!memory use
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Performance!profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Memory-use profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering!profiling
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Beside robustness, another obviously desirable characteristic of software
 is performance.
 In programming, there is the old adage known as the 
\emph on
80/20 rule
\emph default
, which states that very often, 20% of the code accounts for 80% of the
 run time.
\begin_inset Index idx
status open

\begin_layout Plain Layout
80/20 rule, the
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It also often occurs that this 
\begin_inset Quotes eld
\end_inset

20%
\begin_inset Quotes erd
\end_inset

 is not where one would intuitively expect; although in the specific context
 of scientific computing, one may reasonably have a faint idea.
 Still, developer time is much more expensive than computer time; performance
 profiling of the code is needed to make sure that any performance tuning
 effort is applied where it matters.
 In tuning the performance of a code, 
\emph on
premature optimization is the root of all evil
\emph default
 (D.
 Knuth).
\end_layout

\begin_layout Standard
(But in parallelized programs, keep in mind also Amdahl's law
\begin_inset Index idx
status open

\begin_layout Plain Layout
Amdahl's law (parallel computing)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Parallel computing!Amdahl's law
\end_layout

\end_inset

.)
\end_layout

\begin_layout Standard
Properly, the 80/20 rule is called the 
\emph on
Pareto principle
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pareto principle
\end_layout

\end_inset

 Compare 
\emph on
Zipf's law
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Zipf's law
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Pareto_principle"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Zipf%27s_law"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikiquote.org/wiki/Donald_Knuth"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?PrematureOptimization"

\end_inset


\end_layout

\begin_layout Standard
Python comes with a built-in function-level profiler called cProfile
\begin_inset Index idx
status open

\begin_layout Plain Layout
cProfile (performance profiler)
\end_layout

\end_inset

.
 It hooks into your program just like the debugger, and gathers performance
 statistics while the program runs.
 To obtain accurate results, you may want to avoid doing anything else on
 the computer while the program is being profiled.
 A report is generated when the program terminates.
\end_layout

\begin_layout Standard
The report will tell you the total time spent in each function (including
 any functions it calls), the local time spent in the code of that function
 itself, and the total number of calls to the function.
 Doing a test run (or a few), and sorting the report by any of the criteria
 quickly tells you where the potential performance problems are.
\end_layout

\begin_layout Standard
Note that performance profiling is dynamic; it will only gather statistics
 about the code paths that actually got executed during the profiling.
\end_layout

\begin_layout Standard
Sometimes, especially in scientific computing, where functions may sometimes
 be rather long, function-level information is not enough.
 In this case, line-level profiling helps.
 There is a package called line_profiler, which does this.
\end_layout

\begin_layout Standard
For profiling the memory use of your program, the package memory_profiler
 gives line-by-line information on this.
\end_layout

\begin_layout Standard
Both 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Line-level profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
line_profiler
\end_layout

\end_inset

line_profiler and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Memory-use profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
memory_profiler
\end_layout

\end_inset

memory_profiler require tagging the functions you want to profile with the
 
\family typewriter
@profile
\family default
 decorator
\begin_inset Index idx
status open

\begin_layout Plain Layout
Decorator!
\begin_inset ERT
status open

\begin_layout Plain Layout

"@
\end_layout

\end_inset

profile
\end_layout

\end_inset

.
 The decorator does not need to be imported; it becomes magically available
 when the program is run under profilers that require it.
 Note that trying to run the program normally, while the code contains 
\family typewriter
@profile
\family default
 decorators, raises an error.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Spyder
\begin_inset Index idx
status open

\begin_layout Plain Layout
Spyder (IDE)
\end_layout

\end_inset

 integrates all three profilers into the IDE
\begin_inset Index idx
status open

\begin_layout Plain Layout
IDE (Integrated Development Environment)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Integrated Development Environment (IDE)
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Function-level profiling is available as Run 
\begin_inset Formula $\rhd$
\end_inset

 Profile.
\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
Line-level profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
line_profiler
\end_layout

\end_inset

Line-level profiling requires first installing the line_profiler Python
 package, and an official Spyder add-on:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://github.com/spyder-ide/spyder-line-profiler"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Index idx
status open

\begin_layout Plain Layout
Memory-use profiling
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
memory_profiler
\end_layout

\end_inset

Memory-use profiling requires first installing the memory_profiler Python
 package, and an official Spyder add-on:
\family sans

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://github.com/spyder-ide/spyder-memory-profiler"

\end_inset


\end_layout

\begin_layout Itemize
To download the add-ons, get the clone URL from each add-on's GitHub page,
 and:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
git clone url_goes_here
\end_layout

\begin_layout Itemize
Both add-ons have been packaged using 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
setuptools
\end_layout

\end_inset

setuptools
\family default
, so to install, go to the relevant add-on's directory in the terminal (command
 prompt), and:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
python setup.py install --user
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

or possibly
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family typewriter
python3 setup.py install --user
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

as discussed earlier.
\end_layout

\begin_layout Itemize
Once the add-ons are installed, and Spyder is restarted, they appear in
 the Spyder menu as
\begin_inset Newline newline
\end_inset

Run 
\begin_inset Formula $\rhd$
\end_inset

 Profile line by line, and Run 
\begin_inset Formula $\rhd$
\end_inset

 Profile memory line by line.
\end_layout

\begin_layout Itemize
When you invoke a profiler, the report is generated when your program terminates.
\end_layout

\begin_layout Itemize
You can click in the reports to sort by the different columns, and to jump
 to the relevant line in the code.
\end_layout

\begin_layout Standard
Information on the command-line tools:
\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/library/profile.html"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/rkern/line_profiler"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python"

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Design patterns
\begin_inset Index idx
status open

\begin_layout Plain Layout
Patterns (programming)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Software engineering!patterns
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Design patterns
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In programming, a 
\emph on
design pattern
\emph default
 (or just 
\emph on
pattern
\emph default
) is a general reusable solution for a commonly occurring problem.
 Patterns play a role similar to methods in numerics; compare e.g.
 
\emph on
Galerkin method
\emph default
.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Software_design_pattern"

\end_inset


\end_layout

\begin_layout Standard
In this material, we have already seen a few patterns: 
\emph on
Bunch
\emph default
, 
\emph on
Mixin
\emph default
, 
\emph on
Function factory
\emph default
, and 
\emph on
MVC
\emph default
.
 The Python-specific 
\emph on
Conditional main
\emph default
 is usually called an 
\emph on
idiom
\emph default
 instead of a pattern, although it fits the definition — likely because
 it is language-specific:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?ProgrammingIdiom"

\end_inset


\end_layout

\begin_layout Standard
What we have seen here is just a small sample.
 Many different patterns exist; indeed entire books have been written on
 them.
\end_layout

\begin_layout Standard
The first book on patterns was published in 1994–1995, and is still considered
 a canonical reference: 
\emph on
Design Patterns: Elements of Reusable Object-Oriented Software
\emph default
 by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides; Addison–Wesley
, 1995.
\end_layout

\begin_layout Standard
For some more book recommendations on patterns, see:
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://softwareengineering.stackexchange.com/a/124114"

\end_inset


\end_layout

\begin_layout Standard
A good online source is the Portland Pattern Repository (a.k.a.
 C2 wiki
\begin_inset Index idx
status open

\begin_layout Plain Layout
C2 wiki (design patterns)
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Portland Pattern Repository
\end_layout

\end_inset

), which may be interesting to browse.
\end_layout

\begin_layout Standard

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?WelcomeVisitors"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?PeopleProjectsAndPatterns"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?PatternsForBeginners"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://wiki.c2.com/?PatternIndex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.3cm
\end_layout

\end_inset

This is a good place to stop.
 But before you go, there's one final bonus topic.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://jeffknupp.com/blog/2012/10/04/writing-idiomatic-python/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% We want our final bonus topic to be numbered infinity,
\end_layout

\begin_layout Plain Layout

% be located at subsection level, but not be prefixed
\end_layout

\begin_layout Plain Layout

% by the top-level section number in the heading or in the TOC.
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% SE to the rescue:
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% https://tex.stackexchange.com/questions/74529/sections-indexed-with-numbers-subs
ections-with-letters
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% E.g.
\end_layout

\begin_layout Plain Layout

% 
\backslash
renewcommand{
\backslash
thesubsection}{
\backslash
thesection.
\backslash
alph{subsection}}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% So, this does what we want:
\end_layout

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
thesubsection}{$
\backslash
infty$}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The behavior of floating point numbers
\begin_inset Index idx
status open

\begin_layout Plain Layout
IEEE-754 floating point
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Floating point number, IEEE-754
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Number!floating point, IEEE-754
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
The big picture
\series default
:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename floats.pdf

\end_inset


\end_layout

\begin_layout Standard
Code:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
name "[Based on a demo in University of Illinois, CS 357, spring 2017]"
target "https://relate.cs.illinois.edu/course/cs357-s17/file-version/66922aa3735332d7fb31c9fd9e8f7dde2fda1b37/demos/upload/fp/Density%20of%20Floating%20Point%20Numbers.html"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# Based on: University of Illinois, CS 357, spring 2017
\end_layout

\begin_layout Plain Layout

# https://relate.cs.illinois.edu/course/cs357-s17/file-version/
\end_layout

\begin_layout Plain Layout

#     66922aa3735332d7fb31c9fd9e8f7dde2fda1b37/
\end_layout

\begin_layout Plain Layout

#     demos/upload/fp/Density%20of%20Floating%20Point%20Numbers.html
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import matplotlib.pyplot as plt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# For illustration; see sys.float_info for real-world values.
\end_layout

\begin_layout Plain Layout

mant_dig =  4
\end_layout

\begin_layout Plain Layout

min_exp  = -3
\end_layout

\begin_layout Plain Layout

max_exp  =  4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

floats = []
\end_layout

\begin_layout Plain Layout

for k in range(min_exp, max_exp+1):
\end_layout

\begin_layout Plain Layout

    for i in range(2**mant_dig):
\end_layout

\begin_layout Plain Layout

        mantissa = 1 + i/2**mant_dig 
\end_layout

\begin_layout Plain Layout

        floats.append(mantissa * 2**k)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

plt.figure(1, figsize=(5,2))
\end_layout

\begin_layout Plain Layout

plt.clf()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Show where the exactly representable numbers in this floating point system
 are
\end_layout

\begin_layout Plain Layout

for x in floats:
\end_layout

\begin_layout Plain Layout

    plt.axvline(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# https://stackoverflow.com/questions/12998430/remove-xticks-in-a-matplotlib-plot
\end_layout

\begin_layout Plain Layout

plt.tick_params(
\end_layout

\begin_layout Plain Layout

    axis='y',          # changes apply to the y-axis
\end_layout

\begin_layout Plain Layout

    which='both',      # both major and minor ticks are affected
\end_layout

\begin_layout Plain Layout

    left='off',        # ticks along the left edge are off
\end_layout

\begin_layout Plain Layout

    right='off',       # ticks along the right edge are off
\end_layout

\begin_layout Plain Layout

    labelleft='off')   # labels along the left edge are off
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Floating point numbers can be subtle in many ways:
\end_layout

\begin_layout Itemize
In the big picture, 
\emph on
floats are logarithmically
\emph default
 
\emph on
spaced
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
This directly follows from the representation as 
\begin_inset Formula $m\cdot2^{k}$
\end_inset

.
 For a fixed exponent 
\begin_inset Formula $k$
\end_inset

, the mantissa values 
\begin_inset Formula $m$
\end_inset

 are spaced linearly.
 When 
\begin_inset Formula $k$
\end_inset

 increases, so does the spacing.
\end_layout

\begin_layout Itemize
The region of very small numbers around zero is spaced linearly, and consists
 of 
\emph on
subnormal numbers
\emph default
 (a.k.a.
 
\emph on
denormal numbers
\emph default
)
\begin_inset Index idx
status open

\begin_layout Plain Layout
Denormal number
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Subnormal number
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Number!denormal
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Number!subnormal
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
This is sometimes important for code performance.
 Even on modern PCs denormals may use a software implementation, which is
 very slow.
 Since these numbers are very, very small, it is sometimes a good strategy
 to truncate to zero once the result enters the subnormal range.
\end_layout

\begin_deeper
\begin_layout Itemize
Cython
\begin_inset Index idx
status open

\begin_layout Plain Layout
Cython
\end_layout

\end_inset

 and C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

 programmers note: 
\family typewriter
fpclassify()
\end_layout

\end_deeper
\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Denormal_number"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The 
\emph on
machine epsilon
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Machine epsilon
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Epsilon, machine
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
\begin_inset Formula $\epsilon$
\end_inset

 (machine epsilon)
\end_layout

\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset

 is defined as the smallest floating point number such that 
\begin_inset Formula $\mathrm{float}(1+\epsilon)\ne\mathrm{float}(1)$
\end_inset

.
 For IEEE-754 double precision, 
\begin_inset Formula $\epsilon\approx2.22\cdot10^{-16}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Roughly speaking, 
\begin_inset Formula $\epsilon$
\end_inset

 can be thought of as 
\begin_inset Quotes eld
\end_inset

the precision of floating point near unity
\begin_inset Quotes erd
\end_inset

, but naturally, this is not symmetric, since the exponent jumps at unity:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

eps = sys.float_info.epsilon
\end_layout

\begin_layout Plain Layout

1 + eps    # 1.0000000000000002
\end_layout

\begin_layout Plain Layout

1 - eps/2  # 0.9999999999999999
\end_layout

\begin_layout Plain Layout

1 + eps/2  # 1.0 (not representable)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Obviously, in principle floats are intended as a computer representation
 of 
\begin_inset Formula $\mathbb{R}$
\end_inset

, but any scheme using fixed-length storage to represent arbitrary numbers
 can only actually represent a finite subset of
\begin_inset space ~
\end_inset


\begin_inset Formula $\mathbb{Q}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
For given size of storage, choosing this subset is inherently a tradeoff
 of range vs.
 precision.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Floats are base-2
\emph default
.
 This implies e.g.
 that 1/10 cannot be represented exactly:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

x = 0.1
\end_layout

\begin_layout Plain Layout

x.as_integer_ratio()  # (3602879701896397, 36028797018963968)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

0.1 + 0.1 + 0.1 == 0.3  # False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sum(0.1 for j in range(100))  # 9.99999999999998
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

0.1 + 0.2 == 0.3        # False
\end_layout

\begin_layout Plain Layout

0.1 + 0.3 == 0.4        # True
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

This error source is called 
\emph on
representation error
\emph default
.
 Sometimes representation errors may cancel, or end up equal after rounding.
\end_layout

\begin_layout Itemize
Comparing floats and obtaining the intended result can sometimes be difficult:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

a = 0.15 + 0.15
\end_layout

\begin_layout Plain Layout

b = 0.1  + 0.2
\end_layout

\begin_layout Plain Layout

a == b  # False
\end_layout

\begin_layout Plain Layout

a >= b  # False
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Adding an absolute or relative tolerance is not the full solution:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://floating-point-gui.de/errors/comparison/"

\end_inset


\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.1cm
\end_layout

\end_inset

And in rare cases, it does make sense to compare floats for exact equality
 (e.g.
 in a termination condition for some iterative procedure that computes up
 to machine precision).
\end_layout

\begin_layout Itemize

\emph on
Cancellation
\emph default
 and 
\emph on
roundoff
\emph default
 introduce error to calculations using floating point numbers.
\end_layout

\begin_deeper
\begin_layout Itemize
Even the summation of three or more operands is already problematic to perform
 accurately.
\end_layout

\begin_layout Itemize

\emph on
Catastrophic cancellation
\emph default

\begin_inset Index idx
status open

\begin_layout Plain Layout
Catastrophic cancellation
\end_layout

\end_inset

 (a special case of 
\emph on
loss of significance
\emph default
):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Loss_of_significance"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Round-off_error"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Algorithms exist to mitigate this.
\end_layout

\begin_deeper
\begin_layout Itemize
Raymond Hettinger (2005): Binary floating point summation accurate to full
 precision [Python recipe]:
\begin_inset Newline newline
\end_inset


\family sans
\size footnotesize

\begin_inset CommandInset href
LatexCommand href
target "https://github.com/ActiveState/code/tree/master/recipes/Python/393090_Binary_floating_point_summatiaccurate_full"

\end_inset


\end_layout

\begin_layout Itemize
An early, well-known algorithm for 
\emph on
compensated summation
\emph default
 is due to William Kahan (1965):
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Kahan_summation_algorithm"

\end_inset


\end_layout

\begin_layout Itemize
See also 
\family typewriter
math.fsum()
\family default
 in the Python standard library.
\end_layout

\begin_layout Itemize
Modern processors offer a fused multiply-add (FMA)
\begin_inset Index idx
status open

\begin_layout Plain Layout
FMA (fused multiply add)
\end_layout

\end_inset

 that computes 
\begin_inset Formula $ax+y$
\end_inset

, rounding only once.
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://stackoverflow.com/questions/28630864/how-is-fma-implemented"

\end_inset


\end_layout

\begin_layout Itemize
In the context of evaluation of polynomials, the well-known Horner's method
 is fast, but not accurate.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.0cm
\end_layout

\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Horner's_method"

\end_inset


\end_layout

\begin_layout Itemize
There exists a compensated version: Langlois, Louvet (2007): 
\emph on
How to Ensure a Faithful Polynomial Evaluation With the Compensated Horner
 Algorithm
\emph default
:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://perso.ens-lyon.fr/nicolas.louvet/LaLo07.pdf"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Usually, applications of floating point numbers use either single precision
 (most non-scientific applications) or double precision (scientific applications
), but recently interest has arisen in 
\emph on
mixed-precision algorithms
\emph default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout
Mixed precision (floating point)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is due to the rise of GPGPU
\begin_inset Index idx
status open

\begin_layout Plain Layout
GPGPU
\end_layout

\end_inset

, and the fact that cheap (gaming) GPUs nowadays come with teraflops of
 raw computing power, but only for single precision.
\end_layout

\begin_layout Itemize
See e.g.
 the Ph.D.
 thesis by Dominik Göddeke (2010): 
\emph on
Fast and Accurate Finite-Element Multigrid Solvers for PDE Simulations on
 GPU Clusters
\family sans
\emph default
:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://hdl.handle.net/2003/27243"

\end_inset


\end_layout

\begin_layout Itemize
See also Andew Thall (2007): 
\emph on
Extended-Precision Floating-Point Numbers for GPU Computation
\emph default
:
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.486.8236&rep=rep1&type=pdf"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
David Goldberg: What Every Computer Scientist Should Know About Floating-Point
 Arithmetic (Computing Surveys, March 1991):
\begin_inset Newline newline
\end_inset


\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A recommended read, at least once.
 In my opinion, this title too should come with 
\begin_inset Quotes eld
\end_inset

(No Excuses!)
\begin_inset Quotes erd
\end_inset

.
 It's useful for any scientists writing nontrivial software that uses floating
 point numbers, not only for computer scientists.
 It's much more detailed than what is possible to fit here.
\end_layout

\end_deeper
\begin_layout Itemize
Bruce M.
 Bush (1996): The Perils of Floating Point:
\family sans

\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://www.lahey.com/float.htm"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "http://sandbox.mc.edu/~bennet/cs110/textbook/module4_2.html"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://docs.python.org/3/tutorial/floatingpoint.html"

\end_inset


\end_layout

\begin_layout Itemize

\family sans
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/Floating-point_arithmetic"

\end_inset


\end_layout

\begin_layout Standard

\series bold
Recommended
\series default
 book:
\end_layout

\begin_layout Standard
Press, Teukolsky, Vetterling, Flannery: 
\emph on
Numerical Recipes: The Art of Scientific Computing
\emph default
, 3rd ed., Cambridge University Press, 2007.
\end_layout

\begin_layout Standard
This book is a delight in that does not assume exact arithmetic; algorithms
 making the best of finite-precision arithmetic are an important theme.
\end_layout

\begin_layout Standard
But anyone writing open-source code, beware of the code examples in the
 book; they are all rights reserved.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Let us conclude the course with this:
\begin_inset Formula 
\[
7/3-4/3-1=\epsilon
\]

\end_inset


\begin_inset Formula 
\[
4/3-1/3-1=0
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip 0.5cm
\end_layout

\end_inset

...in IEEE-754 double precision floating point.
 Why? Observe that
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

7/3 = 1.001010101010101010101010101010101010101010101010101010...
 * 2**1    (exact)
\end_layout

\begin_layout Plain Layout

   -> 1.0010101010101010101010101010101010101010101010101011      * 2**1
    (IEEE-754)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

4/3 = 1.010101010101010101010101010101010101010101010101010101...
 * 2**0    (exact)
\end_layout

\begin_layout Plain Layout

   -> 1.0101010101010101010101010101010101010101010101010101      * 2**0
    (IEEE-754)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

1/3 = 1.010101010101010101010101010101010101010101010101010101...
 * 2**(-2) (exact)
\end_layout

\begin_layout Plain Layout

   -> 1.0101010101010101010101010101010101010101010101010101      * 2**(-2)
 (IEEE-754)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

(IEEE-754 doubles have 52 bits after the decimal point.) Hence, matching
 exponents to be able to perform the subtraction, we have
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

7/3 - 4/3:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(* 2**0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     10.0101010101010101010101010101010101010101010101010110
\end_layout

\begin_layout Plain Layout

-     1.0101010101010101010101010101010101010101010101010101
\end_layout

\begin_layout Plain Layout

=     1.0000000000000000000000000000000000000000000000000001
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which is the definition of 
\begin_inset Formula $1+\epsilon$
\end_inset

 (note the 1 in the least-significant bit), but
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

4/3 - 1/3:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(* 2**(-2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    101.0101010101010101010101010101010101010101010101010100
\end_layout

\begin_layout Plain Layout

-     1.0101010101010101010101010101010101010101010101010101
\end_layout

\begin_layout Plain Layout

=    10.1111111111111111111111111111111111111111111111111111
\end_layout

\begin_layout Plain Layout

->  100.0000000000000000000000000000000000000000000000000000
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

which is exactly 
\begin_inset Formula $1$
\end_inset

.
\end_layout

\begin_layout Standard
(E.g.
 
\family sans

\begin_inset CommandInset href
LatexCommand href
target "http://stackoverflow.com/questions/19141432/python-numpy-machine-epsilon"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% https://wiki.lyx.org/FAQ/TOC#idxtotoc
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
myIndex
\backslash
theindex
\backslash
renewcommand{
\backslash
theindex}{
\backslash
cleardoublepage
\backslash
myIndex
\backslash
addcontentsline{toc}{section}{
\backslash
indexname}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
